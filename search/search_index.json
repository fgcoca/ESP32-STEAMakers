{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Notas sobre ESP32 STEAMakers \u00b6 Estas notas se dedican a la programaci\u00f3n de la placa de control ESP32 Plus STEAMakers por si misma o junto con la shield Imagina TDR STEAM y otros equipamientos y todo con ArduinoBlocks. El kit base esta formado por la placa ESP32 STEAMakers con la shield TDR STEAM colocada encima. Recuerda que tenemos un tutorial, que vamos actualizando, de estas dos placas. Tambi\u00e9n encontrar\u00e1s c\u00f3mo utilizar y conectar muchos otros sensores. En Miscelanea puedes acceder al mismo. Portada del manual Documentaci\u00f3n y software ESP32 STEAMakers \u00b6 Aqu\u00ed ten\u00e9is un enlace a un documento de Robolot.org con la documentaci\u00f3n de la placa ESP32 STEAMakers y el software asociado . Lo mas conveniente es descargar el archivo, que est\u00e1 en formato zip para descomprimirlo en un directorio local y as\u00ed poder trabajar con este material. El kit \u00b6 En el archivo pdf est\u00e1n las explicaciones para montar en el panel todos los elementos del kit en su versi\u00f3n completa y nos sirve perfectamente para el montaje de los elementos de nuestro kit. El panel tiene el aspecto siguiente: Aspecto del panel En la imagen vemos el aspecto de los componentes que tenemos que montar en nuestro caso. Componentes del kit Los elementos incluidos son: Placa ESP32 STEAMaker Imagina TdR STEAM Micr\u00f3fono Mando o control remoto Pantalla LCD 1602 I2C direccionable con dos connectores I2C macho y uno hembra Sensor de infrarrojos evita obstaculos Micro Servomotor de Rotaci\u00f3n de 0 a 180 grados Tira de Neopixel con 8 LEDs Cables de connexiones Elementos 3D y torniller\u00eda","title":"Introducci\u00f3n"},{"location":"#notas-sobre-esp32-steamakers","text":"Estas notas se dedican a la programaci\u00f3n de la placa de control ESP32 Plus STEAMakers por si misma o junto con la shield Imagina TDR STEAM y otros equipamientos y todo con ArduinoBlocks. El kit base esta formado por la placa ESP32 STEAMakers con la shield TDR STEAM colocada encima. Recuerda que tenemos un tutorial, que vamos actualizando, de estas dos placas. Tambi\u00e9n encontrar\u00e1s c\u00f3mo utilizar y conectar muchos otros sensores. En Miscelanea puedes acceder al mismo. Portada del manual","title":"Notas sobre ESP32 STEAMakers"},{"location":"#documentacion-y-software-esp32-steamakers","text":"Aqu\u00ed ten\u00e9is un enlace a un documento de Robolot.org con la documentaci\u00f3n de la placa ESP32 STEAMakers y el software asociado . Lo mas conveniente es descargar el archivo, que est\u00e1 en formato zip para descomprimirlo en un directorio local y as\u00ed poder trabajar con este material.","title":"Documentaci\u00f3n y software ESP32 STEAMakers"},{"location":"#el-kit","text":"En el archivo pdf est\u00e1n las explicaciones para montar en el panel todos los elementos del kit en su versi\u00f3n completa y nos sirve perfectamente para el montaje de los elementos de nuestro kit. El panel tiene el aspecto siguiente: Aspecto del panel En la imagen vemos el aspecto de los componentes que tenemos que montar en nuestro caso. Componentes del kit Los elementos incluidos son: Placa ESP32 STEAMaker Imagina TdR STEAM Micr\u00f3fono Mando o control remoto Pantalla LCD 1602 I2C direccionable con dos connectores I2C macho y uno hembra Sensor de infrarrojos evita obstaculos Micro Servomotor de Rotaci\u00f3n de 0 a 180 grados Tira de Neopixel con 8 LEDs Cables de connexiones Elementos 3D y torniller\u00eda","title":"El kit"},{"location":"A01/","text":"Actividad-01. LED \u00b6 Enunciado \u00b6 Realizar un programa que encienda y apague el LED rojo conectado al pin D12. Teor\u00eda \u00b6 El diodo LED (Light Emitting Diode) es un diodo semiconductor capaz de emitir luz, lo mas usuales dentro del espectro visible aunque tambi\u00e9n pueden ser de infrarrojos, laser, etc. Su uso mas habitual es como indicador y, \u00faltimamente cada vez mas frecuentes en iluminaci\u00f3n. Sus principales ventajas frente a luces incandescentes son: Menor consumo de energ\u00eda Mayor vida \u00fatil Menor tama\u00f1o Gran durabilidad y fiabilidad En la imagen siguiente vemos el aspecto f\u00edsico que tiene y su s\u00edmbolo electr\u00f3nico. Aspecto y s\u00edmbolo del LED El color de la c\u00e1psula es simplemente orientativo de la longitud de onda que define realmente el color de la luz emitida. Por ello el LED con la c\u00e1psula transparente puede emitir en cualquiera de los colores del espectro visible. El LED es un dispositivo que tiene polaridad siendo su comportamiento el siguiente: En polarizaci\u00f3n directa (\u00e1nodo a positivo y c\u00e1todo a negativo) el LED emite luz y en polarizaci\u00f3n inversa (\u00e1nodo negativo y c\u00e1todo positivo) se comporta pr\u00e1cticamente como un interruptor abierto. Para su correcto funcionamiento el diodo LED se polariza poni\u00e9ndole en serie una resistencia que limita la corriente que pasa a trav\u00e9s del mismo y, por tanto, determina el nivel de brillo de la luz emitida. Sin entrar en detalles en la tabla siguiente se dan los valores de tensi\u00f3n directa (VF) y corriente directa (IF) para los colores mas habituales de LEDs. A partir de estos valores y el valor de tensi\u00f3n de alimentaci\u00f3n de nuestro LED podemos calcular el valor de la resistencia serie sin mas que aplicar la formula indicada. Tensi\u00f3n y corriente para distintos colores En la TdR STEAM \u00b6 La placa Imagina TDR STEAM dispone de un LED rojo conectado al pin D12 tal y como se indica en la serigraf\u00eda de la propia placa y que podemos ver en la imagen siguiente: LED rojo en la TdR STEAM Programando la Actividad \u00b6 Entramos en ArduinoBlocks y nos identificamos convenientemente. Vamos a crear un nuevo proyecto para la placa ESP32 STEAMakers + TdR STEAM. Escogemos el bloque LED de TDR STEAM y lo colocamos en el bucle, quedando algo similar a la imagen siguiente: Bloque LED de TDR STEAM Podemos comprobar haciendo clic sobre las flechas como podemos cambiar de LED y tambi\u00e9n como podemos cambiar de estado al LED. Si solamente dejamos este bloque el LED permanecer\u00e1 encendido de forma permanente y para que se acabe debemos ponerlo en estado OFF. En la imagen siguiente vemos el programa como quedar\u00eda. LED D12 a ON y OFF Pero este programa no nos permite ver el efecto de encendido y apagado del LED debido a la velocidad de procesamiento que tiene la placa UNO que tipicamente trabaja a 16 MHz. Esto supone que el micro tarda en ejecutar una instrucci\u00f3n algo mas de 0,06 microsegundos que es mucho menor que la persistencia visual humana de 0,1 segundo aproximadamente. Es decir, en realidad el LED se enciende y se apaga, pero nuestro ojo no puede apreciarlo y lo ver\u00e1 siempre encendido debido a la persistencia visual. Tenemos por tanto que dejar el diodo un tiempo encendido y otro apagado (pueden ser el mismo tiempo) y para ello vamos a colocar un bloque Esperar desde el bloque de Tiempo. Si dejamos el tiempo por defecto en 100 milisegundos el diodo se encender\u00e1 y apagar\u00e1 cada segundo (1000 ms = 1s). El programa final queda como vemos en la imagen siguiente y lo tenemos disponible en el enlace ESP32-SM-Actividad-01 . Programa final para el LED rojo Conectamos nuestra placa a un puerto USB del ordenador, ponemos en marcha el programa Connector y cargamos el programa. Podemos observar como el diodo LED rojo parpadea con un intervalo de un segundo. De esta forma el programa queda grabado en la memoria de programa del microcontrolador y el ciclo se repetir\u00e1 por tiempo indefinido o hasta que quitemos la alimentaci\u00f3n a la placa. Si alimentamos la placa externamente con una fuente de alimentaci\u00f3n se ejecutar\u00e1 el programa en memoria. Retos de ampliaci\u00f3n \u00b6 R1.A1 . Cambiar los tiempos para que el parpadeo sea m\u00e1s r\u00e1pido, mas lento y que los tiempos de encendido y apagado no coincidan. R2.A1 . Repetir el ejercicio A1 utilizando el LED azul conectado al pin D13. | | Diodo LED azul conectado a D13","title":"Actividad-01. LED"},{"location":"A01/#actividad-01-led","text":"","title":"Actividad-01. LED"},{"location":"A01/#enunciado","text":"Realizar un programa que encienda y apague el LED rojo conectado al pin D12.","title":"Enunciado"},{"location":"A01/#teoria","text":"El diodo LED (Light Emitting Diode) es un diodo semiconductor capaz de emitir luz, lo mas usuales dentro del espectro visible aunque tambi\u00e9n pueden ser de infrarrojos, laser, etc. Su uso mas habitual es como indicador y, \u00faltimamente cada vez mas frecuentes en iluminaci\u00f3n. Sus principales ventajas frente a luces incandescentes son: Menor consumo de energ\u00eda Mayor vida \u00fatil Menor tama\u00f1o Gran durabilidad y fiabilidad En la imagen siguiente vemos el aspecto f\u00edsico que tiene y su s\u00edmbolo electr\u00f3nico. Aspecto y s\u00edmbolo del LED El color de la c\u00e1psula es simplemente orientativo de la longitud de onda que define realmente el color de la luz emitida. Por ello el LED con la c\u00e1psula transparente puede emitir en cualquiera de los colores del espectro visible. El LED es un dispositivo que tiene polaridad siendo su comportamiento el siguiente: En polarizaci\u00f3n directa (\u00e1nodo a positivo y c\u00e1todo a negativo) el LED emite luz y en polarizaci\u00f3n inversa (\u00e1nodo negativo y c\u00e1todo positivo) se comporta pr\u00e1cticamente como un interruptor abierto. Para su correcto funcionamiento el diodo LED se polariza poni\u00e9ndole en serie una resistencia que limita la corriente que pasa a trav\u00e9s del mismo y, por tanto, determina el nivel de brillo de la luz emitida. Sin entrar en detalles en la tabla siguiente se dan los valores de tensi\u00f3n directa (VF) y corriente directa (IF) para los colores mas habituales de LEDs. A partir de estos valores y el valor de tensi\u00f3n de alimentaci\u00f3n de nuestro LED podemos calcular el valor de la resistencia serie sin mas que aplicar la formula indicada. Tensi\u00f3n y corriente para distintos colores","title":"Teor\u00eda"},{"location":"A01/#en-la-tdr-steam","text":"La placa Imagina TDR STEAM dispone de un LED rojo conectado al pin D12 tal y como se indica en la serigraf\u00eda de la propia placa y que podemos ver en la imagen siguiente: LED rojo en la TdR STEAM","title":"En la TdR STEAM"},{"location":"A01/#programando-la-actividad","text":"Entramos en ArduinoBlocks y nos identificamos convenientemente. Vamos a crear un nuevo proyecto para la placa ESP32 STEAMakers + TdR STEAM. Escogemos el bloque LED de TDR STEAM y lo colocamos en el bucle, quedando algo similar a la imagen siguiente: Bloque LED de TDR STEAM Podemos comprobar haciendo clic sobre las flechas como podemos cambiar de LED y tambi\u00e9n como podemos cambiar de estado al LED. Si solamente dejamos este bloque el LED permanecer\u00e1 encendido de forma permanente y para que se acabe debemos ponerlo en estado OFF. En la imagen siguiente vemos el programa como quedar\u00eda. LED D12 a ON y OFF Pero este programa no nos permite ver el efecto de encendido y apagado del LED debido a la velocidad de procesamiento que tiene la placa UNO que tipicamente trabaja a 16 MHz. Esto supone que el micro tarda en ejecutar una instrucci\u00f3n algo mas de 0,06 microsegundos que es mucho menor que la persistencia visual humana de 0,1 segundo aproximadamente. Es decir, en realidad el LED se enciende y se apaga, pero nuestro ojo no puede apreciarlo y lo ver\u00e1 siempre encendido debido a la persistencia visual. Tenemos por tanto que dejar el diodo un tiempo encendido y otro apagado (pueden ser el mismo tiempo) y para ello vamos a colocar un bloque Esperar desde el bloque de Tiempo. Si dejamos el tiempo por defecto en 100 milisegundos el diodo se encender\u00e1 y apagar\u00e1 cada segundo (1000 ms = 1s). El programa final queda como vemos en la imagen siguiente y lo tenemos disponible en el enlace ESP32-SM-Actividad-01 . Programa final para el LED rojo Conectamos nuestra placa a un puerto USB del ordenador, ponemos en marcha el programa Connector y cargamos el programa. Podemos observar como el diodo LED rojo parpadea con un intervalo de un segundo. De esta forma el programa queda grabado en la memoria de programa del microcontrolador y el ciclo se repetir\u00e1 por tiempo indefinido o hasta que quitemos la alimentaci\u00f3n a la placa. Si alimentamos la placa externamente con una fuente de alimentaci\u00f3n se ejecutar\u00e1 el programa en memoria.","title":"Programando la Actividad"},{"location":"A01/#retos-de-ampliacion","text":"R1.A1 . Cambiar los tiempos para que el parpadeo sea m\u00e1s r\u00e1pido, mas lento y que los tiempos de encendido y apagado no coincidan. R2.A1 . Repetir el ejercicio A1 utilizando el LED azul conectado al pin D13. | | Diodo LED azul conectado a D13","title":"Retos de ampliaci\u00f3n"},{"location":"A02/","text":"Actividad-02. LEDs rojo y azul \u00b6 Enunciado \u00b6 Como ya hemos visto anteriormente la placa dispone de dos LED (uno rojo y otro azul). Vamos a realizar un programa para que se vayan alternando en su encendido y apagado. Teor\u00eda \u00b6 Vamos a ver como se hacen los ciclos de repetici\u00f3n o bucles en ArduinoBlocks. Repetir . En el men\u00fa de Control existe el bloque 'Repetir (valor) veces hacer\u2026', como el de la imagen siguiente: Bucle repetir Lo que pongamos en hacer se va a repetir tantas veces como indiquemos en el n\u00famero de veces, que por defecto estar\u00e1 a 10. En realidad lo que estamos haciendo es lo que en programaci\u00f3n se conoce como bucle for. Repetir seg\u00fan condici\u00f3n . En la imagen siguiente vemos dos bloques que repiten su interior mientras, o hasta, que se cumpla una condici\u00f3n. Bucle repetir seg\u00fan condici\u00f3n Contador . Realiza un bucle contando con un variable \u00edndice (normalmente i o j). Se define un valor de inicio, una valor de fin y los incrementos que se realizar\u00e1n en cada iteraci\u00f3n del bucle. Dentro del bucle podremos usar esta variable \u00edndice. Bucle contador En la TdR STEAM \u00b6 Los dos LEDs de la TdR-STEAM Programando la Actividad \u00b6 Vamos a hacer que ambos diodos se enciendan y apaguen de forma simultanea con un programa como el siguiente, que lo tenemos disponible en Actividad-02. LED-rojo-azul Intermitencia LEDs rojo y azul Retos de ampliaci\u00f3n \u00b6 A2.R1 . Hacer que los LEDs rojo y azul se enciendan simult\u00e1neamente con tiempos de espera de 300ms y 150ms respectivamente. A2.R2 . Realizar 4 intermitencias de 500ms con el LED azul y cuando estas acaben dejar el LED rojo encendido durante 1.5 segundos. Esperar un segundo para iniciar de nuevo el proceso. A2.R3 . Realiza 5 intermitencias de 500ms con el LED azul cada vez que el LED rojo lo hace 3 veces a intervalos de 150ms. Esperar un segundo para iniciar de nuevo el proceso. Soluci\u00f3n A22.R2 \u00b6 El Programa es el de la imagen siguiente: Soluci\u00f3n al Reto 2 de la Actividad 2 Soluci\u00f3n A2.R3 \u00b6 El Programa es el de la imagen siguiente: | | Soluci\u00f3n al Reto 3 de la Actividad 2","title":"Actividad-02. LEDs rojo y azul"},{"location":"A02/#actividad-02-leds-rojo-y-azul","text":"","title":"Actividad-02. LEDs rojo y azul"},{"location":"A02/#enunciado","text":"Como ya hemos visto anteriormente la placa dispone de dos LED (uno rojo y otro azul). Vamos a realizar un programa para que se vayan alternando en su encendido y apagado.","title":"Enunciado"},{"location":"A02/#teoria","text":"Vamos a ver como se hacen los ciclos de repetici\u00f3n o bucles en ArduinoBlocks. Repetir . En el men\u00fa de Control existe el bloque 'Repetir (valor) veces hacer\u2026', como el de la imagen siguiente: Bucle repetir Lo que pongamos en hacer se va a repetir tantas veces como indiquemos en el n\u00famero de veces, que por defecto estar\u00e1 a 10. En realidad lo que estamos haciendo es lo que en programaci\u00f3n se conoce como bucle for. Repetir seg\u00fan condici\u00f3n . En la imagen siguiente vemos dos bloques que repiten su interior mientras, o hasta, que se cumpla una condici\u00f3n. Bucle repetir seg\u00fan condici\u00f3n Contador . Realiza un bucle contando con un variable \u00edndice (normalmente i o j). Se define un valor de inicio, una valor de fin y los incrementos que se realizar\u00e1n en cada iteraci\u00f3n del bucle. Dentro del bucle podremos usar esta variable \u00edndice. Bucle contador","title":"Teor\u00eda"},{"location":"A02/#en-la-tdr-steam","text":"Los dos LEDs de la TdR-STEAM","title":"En la TdR STEAM"},{"location":"A02/#programando-la-actividad","text":"Vamos a hacer que ambos diodos se enciendan y apaguen de forma simultanea con un programa como el siguiente, que lo tenemos disponible en Actividad-02. LED-rojo-azul Intermitencia LEDs rojo y azul","title":"Programando la Actividad"},{"location":"A02/#retos-de-ampliacion","text":"A2.R1 . Hacer que los LEDs rojo y azul se enciendan simult\u00e1neamente con tiempos de espera de 300ms y 150ms respectivamente. A2.R2 . Realizar 4 intermitencias de 500ms con el LED azul y cuando estas acaben dejar el LED rojo encendido durante 1.5 segundos. Esperar un segundo para iniciar de nuevo el proceso. A2.R3 . Realiza 5 intermitencias de 500ms con el LED azul cada vez que el LED rojo lo hace 3 veces a intervalos de 150ms. Esperar un segundo para iniciar de nuevo el proceso.","title":"Retos de ampliaci\u00f3n"},{"location":"A02/#solucion-a22r2","text":"El Programa es el de la imagen siguiente: Soluci\u00f3n al Reto 2 de la Actividad 2","title":"Soluci\u00f3n A22.R2"},{"location":"A02/#solucion-a2r3","text":"El Programa es el de la imagen siguiente: | | Soluci\u00f3n al Reto 3 de la Actividad 2","title":"Soluci\u00f3n A2.R3"},{"location":"A03/","text":"Actividad-03. Parpadeo intermitente. Multitarea \u00b6 Enunciado \u00b6 Ya hemos visto como hacer funcionar a los LEDs de diferentes formas, pero ahora vamos a introducir un concepto que nos puede resultar bastante \u00fatil en el futuro, se trata de la multitarea en ArduinoBlocks. Teor\u00eda \u00b6 Este apartado se extrae de ArduinoBlocks - FreeBook disponible en Free Book (online & updated) . ArduinoBlocks nos permite utilizar una capa para implementar un sistema multitarea avanzado basado en FreeRTOS (del ingl\u00e9s Real Time Operating System), que es un sistema operativo de tiempo real kernel para dispositivos embebidos para plataformas de microcontrolador que se distribuye bajo licencia MIT. Este sistema permite crear tareas que se ejecutar\u00e1n de forma paralela (virtualmente). En microcontroladores modestos como el Arduino UNO, Nano o incluso MEGA la multitarea con FreeRTOS es bastante limitada y consume gran parte de los recursos de nuestro Arduino, en caso de necesitar de un sistema multitarea m\u00e1s potente podemos optar por usarlo en placas basadas en ESP8266 o ESP32 con mucha m\u00e1s potencia y recursos (especialmente el ESP32 con doble n\u00facleo y gran potencia de procesamiento y memoria interna) Los sistemas software de multitarea utilizan un planificador o scheduler que se encarga de repartir el tiempo de procesamiento entre las distintas tareas, de forma que a cada una le toca un tiempo de microcontrolador para ejecutar un poquito de su parte de programa. En las web de freeRTOS , en su entrada de men\u00fa Kernel podemos encontrar los conceptos b\u00e1sicos de multitarea y de programaci\u00f3n que vamos a extractar seguidamente. Conceptos b\u00e1sicos de multitarea \u00b6 Un procesador convencional como el de Arduino UNO solo puede ejecutar una tarea a la vez, pero al cambiar r\u00e1pidamente entre tareas, un sistema operativo multitarea puede hacer que parezca que cada tarea se ejecuta simult\u00e1neamente. Esto es lo que se representa en el diagrama de la Figura siguiente que muestra el patr\u00f3n de ejecuci\u00f3n de tres tareas con respecto al tiempo. Los nombres de las tareas est\u00e1n codificados por colores y escritos a la izquierda. El tiempo se mueve de izquierda a derecha y las l\u00edneas de colores muestran qu\u00e9 tarea se est\u00e1 ejecutando en un momento determinado. El diagrama superior demuestra el patr\u00f3n de ejecuci\u00f3n concurrente percibido, y el inferior el patr\u00f3n de ejecuci\u00f3n multitarea real. Patr\u00f3n de ejecuci\u00f3n de tres tareas con respecto al tiempo Programaci\u00f3n \u00b6 El programador es quien debe decidir qu\u00e9 tarea debe ejecutarse en un momento determinado. El kernel o n\u00facleo puede suspender y luego reanudar una tarea muchas veces durante el tiempo de vida de la tarea. Adem\u00e1s de ser suspendida involuntariamente por el n\u00facleo o kernel, una tarea puede optar por suspenderse a s\u00ed misma. Har\u00e1 esto si desea retrasar ( dormir ) por un per\u00edodo fijo o esperar ( bloquear ) a que un recurso (por ejemplo, un puerto serie) est\u00e9 disponible, o que ocurra un evento (por ejemplo, presionar una pulsador). Una tarea bloqueada o inactiva no se puede ejecutar y no se le asignar\u00e1 ning\u00fan tiempo de procesamiento. En la Figura siguiente vemos un posible diagrama de ejecuci\u00f3n de tres tareas analizado punto por punto en distintos instantes de tiempo. En los c\u00edrculos se representan los instantes de tiempo t1 a t10. Diagrama de ejecuci\u00f3n de tres tareas en el tiempo t1: la tarea 1 se est\u00e1 ejecutando. t2: en el kernel se suspende, o mejor dicho se intercambia, la tarea 1 . t3: se reanuda la tarea 2 . t4: mientras se ejecuta la tarea 2 el procesador bloquea el puerto serie para su acceso exclusivo. t5: el kernel suspende la tarea 2 . t6: el kernel reanuda la tarea 3 . t1: la tarea 3 intenta acceder al puerto serie y lo encuentra bloqueado por lo que no puede continuar y se suspende. t8: el kernel reanuda la tarea 1 . t9: al ejecutarse de nuevo la tarea 2 se desbloquea el puerto serie. t10: la tarea 3 ahora si puede acceder al puerto serie y se ejecuta al completo Planificadores \u00b6 Los planificadores de multitarea permiten asignar a cada tarea una prioridad, para as\u00ed darle preferencia a las tareas m\u00e1s cr\u00edticas o que necesitan m\u00e1s tiempo de procesamiento. Si creamos muchas tareas con \u201calta\u201d prioridad puede que afectemos a las dem\u00e1s dejando poco tiempo de procesamiento para ellas. En la Figura siguiente vemos un esquema de varias tareas con distintas prioridades, variando as\u00ed su tiempo de microprocesador asignado. Distintas prioridades en tres tareas Cada tarea tiene su propio espacio de memoria, por lo que crear demasiadas tareas tambi\u00e9n puede dejarnos el procesador sin memoria. Si la memoria asignada a las tareas tampoco es suficiente para almacenar los datos se podr\u00eda reiniciar de forma inesperada el Arduino, o funcionar incorrectamente, es decir que como siempre, hay que ser consciente de los limitados recursos de los que disponemos. Sem\u00e1foros \u00b6 Con la introducci\u00f3n te\u00f3rica a la multitarea vista, debemos hacernos otra pregunta: \u00bfQu\u00e9 pasa si una tarea accede a un recurso o variable, y el sistema multitarea le da el control a otra tarea y por tanto ese proceso falla o quiz\u00e1s otra tarea acceda al mismo recurso y se solapen? Para ese problema de convivencia entre tareas se inventaron los \u201csem\u00e1foros\u201d, en concreto el que m\u00e1s nos interesa es el sem\u00e1foro \u201cmutex\u201d o de exclusi\u00f3n mutua, que permite que bloqueemos el sistema multitarea, hagamos lo que tengamos que hacer cr\u00edtico, y luego liberemos el control. Por supuesto estas tareas cr\u00edticas deben ser lo m\u00e1s cortas y at\u00f3micas posibles: una escritura cr\u00edtica en una variable, un env\u00edo de un dato, una actualizaci\u00f3n de una pantalla LCD,... siempre cosas simples. Los sem\u00e1foros debemos usarlos en casos que tengamos claro que se pueden crear conflictos, pues su abuso puede hacer que el sistema multitarea empiece a fallar. En la Figura siguiente vemos el esquema de acceso a un recurso desde dos tareas diferentes. Esquema de acceso a un mismo recurso por parte de 2 tareas diferentes En la ESP32 STEAMakers \u00b6 Una ventaja que posee la ESP32 Plus STEAMakers es que, al estar basado en un ESP32 con dos microcontroladores internos, podemos hacer que cada microcontrolador trabaje en una tarea y esto si ser\u00eda multitarea real, o en varias tareas mezclando la multitarea real con la simulada. Esto tambi\u00e9n se puede hacer en las placas Arduino UNO, pero con el ESP32 tenemos m\u00e1s potencia para realizar estas tareas. Bloques esperar \u00b6 \u00bfQu\u00e9 pasa con los bloques tipo \u201cesperar\u201d que estaban tan prohibidos en la programaci\u00f3n de Arduino cuando quer\u00edamos simular una multitarea antes de tener estos bloques? Pues seguimos teni\u00e9ndoles bastante tirria. Aunque en teor\u00eda podr\u00edamos usarlos, un bloque esperar hace pensar al microcontrolador que est\u00e1 haciendo algo \u00fatil, cuando en realidad no es as\u00ed, por lo que el sistema multitarea querr\u00e1 asignarle tiempo de procesamiento a la tarea, aunque sea para eso, \u00a1para no hacer nada! Tenemos una soluci\u00f3n, tenemos un nuevo bloque de esperar \u201ctask friendly\u201d que en lugar de esperar sin hacer nada le dice al sistema: \u00a1voy a estar un rato sin hacer nada, permite ejecutar otras tareas mientras y luego vuelves! \u2026.Mucho m\u00e1s \u201cfriendly\u201d, claro que s\u00ed. Bloques \u00b6 Con toda esta informaci\u00f3n pasamos a ver los bloques disponibles para poner todo \u00e9sto en marcha. Bloque Descripci\u00f3n Permite crear una nueva tarea con su bloque de \u201cinicializar\u201d y su \u201cbucle\u201d al igual que la tarea original de Arduino. Debemos asignar una prioridad a cada tarea, por defecto dejar\u00eda todas a \u201cbaja\u201d y luego ir\u00eda ajustando si hace falta. Para gestionar mejor las prioridades, es recomendable en algunos casos no utilizar el \u201cinicializar\u201d y \u201cbucle\u201d propio de Arduino que suele tener preferencia sobre todas estas tareas y es m\u00e1s dif\u00edcil de equilibrar las prioridades. El bloque esperar \u00f3ptimo para tareas, pues deja funcionar al resto de tareas de forma m\u00e1s \u00f3ptima mientras se espera en \u00e9sta. Este bloque tiene menos precisi\u00f3n que el bloque \u201cesperar\u201d original, si necesitamos hacer esperas muy precisas (o de menos de 20 ms) debemos usar el \u201cesperar\u201d tradicional. Pero nos servir\u00e1 en la mayor\u00eda de casos. Si tenemos que hacer alguna acci\u00f3n cr\u00edtica que no queremos que sea interrumpida internamente por el planificador del sistema multitarea podemos poner este bloque y dentro los bloques cr\u00edticos. (no utilizar si no es estrictamente necesario) Cada tarea tiene su propio espacio de memoria reservado, esta es la cantidad por defecto para las tareas (192 bytes), si necesitamos ajustarla podemos utilizar este bloque en el \u201cinicializar\u201d principal y se ajustar\u00e1 para todas las tareas. Un mal ajuste puede provocar reinicios del microcontrolador o mal funcionamiento. Las tareas en principio, igual que el bucle de Arduino, est\u00e1n pensadas para ejecutarse de forma indefinida, si en un caso una tarea deja de ser necesaria la forma de terminarla es con este bloque que parar\u00e1 la ejecuci\u00f3n y liberar\u00e1 la memoria de la tarea en la que se ejecuta. En la TdR STEAM \u00b6 Los dos LEDs de la TdR-STEAM Programando la Actividad \u00b6 Vamos a hacer que los dos diodos parpadeen de forma independiente con un programa como el siguiente, que lo tenemos disponible en Actividad-03. Parpadeo intermitente. Multitarea Intermitencia LEDs rojo y azul Retos de ampliaci\u00f3n \u00b6 A3.R1 . Hacer que los LEDs rojo y azul trabajen en multitarea modificando los tiempos.","title":"Actividad-03. Parpadeo intermitente"},{"location":"A03/#actividad-03-parpadeo-intermitente-multitarea","text":"","title":"Actividad-03. Parpadeo intermitente. Multitarea"},{"location":"A03/#enunciado","text":"Ya hemos visto como hacer funcionar a los LEDs de diferentes formas, pero ahora vamos a introducir un concepto que nos puede resultar bastante \u00fatil en el futuro, se trata de la multitarea en ArduinoBlocks.","title":"Enunciado"},{"location":"A03/#teoria","text":"Este apartado se extrae de ArduinoBlocks - FreeBook disponible en Free Book (online & updated) . ArduinoBlocks nos permite utilizar una capa para implementar un sistema multitarea avanzado basado en FreeRTOS (del ingl\u00e9s Real Time Operating System), que es un sistema operativo de tiempo real kernel para dispositivos embebidos para plataformas de microcontrolador que se distribuye bajo licencia MIT. Este sistema permite crear tareas que se ejecutar\u00e1n de forma paralela (virtualmente). En microcontroladores modestos como el Arduino UNO, Nano o incluso MEGA la multitarea con FreeRTOS es bastante limitada y consume gran parte de los recursos de nuestro Arduino, en caso de necesitar de un sistema multitarea m\u00e1s potente podemos optar por usarlo en placas basadas en ESP8266 o ESP32 con mucha m\u00e1s potencia y recursos (especialmente el ESP32 con doble n\u00facleo y gran potencia de procesamiento y memoria interna) Los sistemas software de multitarea utilizan un planificador o scheduler que se encarga de repartir el tiempo de procesamiento entre las distintas tareas, de forma que a cada una le toca un tiempo de microcontrolador para ejecutar un poquito de su parte de programa. En las web de freeRTOS , en su entrada de men\u00fa Kernel podemos encontrar los conceptos b\u00e1sicos de multitarea y de programaci\u00f3n que vamos a extractar seguidamente.","title":"Teor\u00eda"},{"location":"A03/#conceptos-basicos-de-multitarea","text":"Un procesador convencional como el de Arduino UNO solo puede ejecutar una tarea a la vez, pero al cambiar r\u00e1pidamente entre tareas, un sistema operativo multitarea puede hacer que parezca que cada tarea se ejecuta simult\u00e1neamente. Esto es lo que se representa en el diagrama de la Figura siguiente que muestra el patr\u00f3n de ejecuci\u00f3n de tres tareas con respecto al tiempo. Los nombres de las tareas est\u00e1n codificados por colores y escritos a la izquierda. El tiempo se mueve de izquierda a derecha y las l\u00edneas de colores muestran qu\u00e9 tarea se est\u00e1 ejecutando en un momento determinado. El diagrama superior demuestra el patr\u00f3n de ejecuci\u00f3n concurrente percibido, y el inferior el patr\u00f3n de ejecuci\u00f3n multitarea real. Patr\u00f3n de ejecuci\u00f3n de tres tareas con respecto al tiempo","title":"Conceptos b\u00e1sicos de multitarea"},{"location":"A03/#programacion","text":"El programador es quien debe decidir qu\u00e9 tarea debe ejecutarse en un momento determinado. El kernel o n\u00facleo puede suspender y luego reanudar una tarea muchas veces durante el tiempo de vida de la tarea. Adem\u00e1s de ser suspendida involuntariamente por el n\u00facleo o kernel, una tarea puede optar por suspenderse a s\u00ed misma. Har\u00e1 esto si desea retrasar ( dormir ) por un per\u00edodo fijo o esperar ( bloquear ) a que un recurso (por ejemplo, un puerto serie) est\u00e9 disponible, o que ocurra un evento (por ejemplo, presionar una pulsador). Una tarea bloqueada o inactiva no se puede ejecutar y no se le asignar\u00e1 ning\u00fan tiempo de procesamiento. En la Figura siguiente vemos un posible diagrama de ejecuci\u00f3n de tres tareas analizado punto por punto en distintos instantes de tiempo. En los c\u00edrculos se representan los instantes de tiempo t1 a t10. Diagrama de ejecuci\u00f3n de tres tareas en el tiempo t1: la tarea 1 se est\u00e1 ejecutando. t2: en el kernel se suspende, o mejor dicho se intercambia, la tarea 1 . t3: se reanuda la tarea 2 . t4: mientras se ejecuta la tarea 2 el procesador bloquea el puerto serie para su acceso exclusivo. t5: el kernel suspende la tarea 2 . t6: el kernel reanuda la tarea 3 . t1: la tarea 3 intenta acceder al puerto serie y lo encuentra bloqueado por lo que no puede continuar y se suspende. t8: el kernel reanuda la tarea 1 . t9: al ejecutarse de nuevo la tarea 2 se desbloquea el puerto serie. t10: la tarea 3 ahora si puede acceder al puerto serie y se ejecuta al completo","title":"Programaci\u00f3n"},{"location":"A03/#planificadores","text":"Los planificadores de multitarea permiten asignar a cada tarea una prioridad, para as\u00ed darle preferencia a las tareas m\u00e1s cr\u00edticas o que necesitan m\u00e1s tiempo de procesamiento. Si creamos muchas tareas con \u201calta\u201d prioridad puede que afectemos a las dem\u00e1s dejando poco tiempo de procesamiento para ellas. En la Figura siguiente vemos un esquema de varias tareas con distintas prioridades, variando as\u00ed su tiempo de microprocesador asignado. Distintas prioridades en tres tareas Cada tarea tiene su propio espacio de memoria, por lo que crear demasiadas tareas tambi\u00e9n puede dejarnos el procesador sin memoria. Si la memoria asignada a las tareas tampoco es suficiente para almacenar los datos se podr\u00eda reiniciar de forma inesperada el Arduino, o funcionar incorrectamente, es decir que como siempre, hay que ser consciente de los limitados recursos de los que disponemos.","title":"Planificadores"},{"location":"A03/#semaforos","text":"Con la introducci\u00f3n te\u00f3rica a la multitarea vista, debemos hacernos otra pregunta: \u00bfQu\u00e9 pasa si una tarea accede a un recurso o variable, y el sistema multitarea le da el control a otra tarea y por tanto ese proceso falla o quiz\u00e1s otra tarea acceda al mismo recurso y se solapen? Para ese problema de convivencia entre tareas se inventaron los \u201csem\u00e1foros\u201d, en concreto el que m\u00e1s nos interesa es el sem\u00e1foro \u201cmutex\u201d o de exclusi\u00f3n mutua, que permite que bloqueemos el sistema multitarea, hagamos lo que tengamos que hacer cr\u00edtico, y luego liberemos el control. Por supuesto estas tareas cr\u00edticas deben ser lo m\u00e1s cortas y at\u00f3micas posibles: una escritura cr\u00edtica en una variable, un env\u00edo de un dato, una actualizaci\u00f3n de una pantalla LCD,... siempre cosas simples. Los sem\u00e1foros debemos usarlos en casos que tengamos claro que se pueden crear conflictos, pues su abuso puede hacer que el sistema multitarea empiece a fallar. En la Figura siguiente vemos el esquema de acceso a un recurso desde dos tareas diferentes. Esquema de acceso a un mismo recurso por parte de 2 tareas diferentes","title":"Sem\u00e1foros"},{"location":"A03/#en-la-esp32-steamakers","text":"Una ventaja que posee la ESP32 Plus STEAMakers es que, al estar basado en un ESP32 con dos microcontroladores internos, podemos hacer que cada microcontrolador trabaje en una tarea y esto si ser\u00eda multitarea real, o en varias tareas mezclando la multitarea real con la simulada. Esto tambi\u00e9n se puede hacer en las placas Arduino UNO, pero con el ESP32 tenemos m\u00e1s potencia para realizar estas tareas.","title":"En la ESP32 STEAMakers"},{"location":"A03/#bloques-esperar","text":"\u00bfQu\u00e9 pasa con los bloques tipo \u201cesperar\u201d que estaban tan prohibidos en la programaci\u00f3n de Arduino cuando quer\u00edamos simular una multitarea antes de tener estos bloques? Pues seguimos teni\u00e9ndoles bastante tirria. Aunque en teor\u00eda podr\u00edamos usarlos, un bloque esperar hace pensar al microcontrolador que est\u00e1 haciendo algo \u00fatil, cuando en realidad no es as\u00ed, por lo que el sistema multitarea querr\u00e1 asignarle tiempo de procesamiento a la tarea, aunque sea para eso, \u00a1para no hacer nada! Tenemos una soluci\u00f3n, tenemos un nuevo bloque de esperar \u201ctask friendly\u201d que en lugar de esperar sin hacer nada le dice al sistema: \u00a1voy a estar un rato sin hacer nada, permite ejecutar otras tareas mientras y luego vuelves! \u2026.Mucho m\u00e1s \u201cfriendly\u201d, claro que s\u00ed.","title":"Bloques esperar"},{"location":"A03/#bloques","text":"Con toda esta informaci\u00f3n pasamos a ver los bloques disponibles para poner todo \u00e9sto en marcha. Bloque Descripci\u00f3n Permite crear una nueva tarea con su bloque de \u201cinicializar\u201d y su \u201cbucle\u201d al igual que la tarea original de Arduino. Debemos asignar una prioridad a cada tarea, por defecto dejar\u00eda todas a \u201cbaja\u201d y luego ir\u00eda ajustando si hace falta. Para gestionar mejor las prioridades, es recomendable en algunos casos no utilizar el \u201cinicializar\u201d y \u201cbucle\u201d propio de Arduino que suele tener preferencia sobre todas estas tareas y es m\u00e1s dif\u00edcil de equilibrar las prioridades. El bloque esperar \u00f3ptimo para tareas, pues deja funcionar al resto de tareas de forma m\u00e1s \u00f3ptima mientras se espera en \u00e9sta. Este bloque tiene menos precisi\u00f3n que el bloque \u201cesperar\u201d original, si necesitamos hacer esperas muy precisas (o de menos de 20 ms) debemos usar el \u201cesperar\u201d tradicional. Pero nos servir\u00e1 en la mayor\u00eda de casos. Si tenemos que hacer alguna acci\u00f3n cr\u00edtica que no queremos que sea interrumpida internamente por el planificador del sistema multitarea podemos poner este bloque y dentro los bloques cr\u00edticos. (no utilizar si no es estrictamente necesario) Cada tarea tiene su propio espacio de memoria reservado, esta es la cantidad por defecto para las tareas (192 bytes), si necesitamos ajustarla podemos utilizar este bloque en el \u201cinicializar\u201d principal y se ajustar\u00e1 para todas las tareas. Un mal ajuste puede provocar reinicios del microcontrolador o mal funcionamiento. Las tareas en principio, igual que el bucle de Arduino, est\u00e1n pensadas para ejecutarse de forma indefinida, si en un caso una tarea deja de ser necesaria la forma de terminarla es con este bloque que parar\u00e1 la ejecuci\u00f3n y liberar\u00e1 la memoria de la tarea en la que se ejecuta.","title":"Bloques"},{"location":"A03/#en-la-tdr-steam","text":"Los dos LEDs de la TdR-STEAM","title":"En la TdR STEAM"},{"location":"A03/#programando-la-actividad","text":"Vamos a hacer que los dos diodos parpadeen de forma independiente con un programa como el siguiente, que lo tenemos disponible en Actividad-03. Parpadeo intermitente. Multitarea Intermitencia LEDs rojo y azul","title":"Programando la Actividad"},{"location":"A03/#retos-de-ampliacion","text":"A3.R1 . Hacer que los LEDs rojo y azul trabajen en multitarea modificando los tiempos.","title":"Retos de ampliaci\u00f3n"},{"location":"A04/","text":"Actividad-04. LED RGB \u00b6 Enunciado \u00b6 La actividad b\u00e1sics consistir\u00e1 en ver los colores primarios y su mezcla mediante el uso del LED RGB y tambi\u00e9n habr\u00e1 una actividad secundaria sobre el control de intensidad mediante PWM. Teor\u00eda \u00b6 LED RGB \u00b6 Un LED RGB es en realidad un encapsulado que incorpora tres diodos LED, uno por cada color fundamental. Los colores primarios en \u00f3ptica son el rojo, el verde y el azul y la correcta combinaci\u00f3n, en t\u00e9rminos de intensidad, de ellos originar\u00e1 cualquiera de los colores secundarios. Las siglas RGB son el acr\u00f3nimo de Red, Green y Blue. En el caso de la TDR-STEAM se utiliza un LED RGB con los tres LEDs unidos por su c\u00e1todo o terminal negativo, es decir es un LED RGB de c\u00e1todo com\u00fan. En la imagen siguiente vemos el modelo aditivo de los colores rojo, verde y azul. | RGB El s\u00edmbolo y la representaci\u00f3n mas comunes de este componente lo vemos en la imagen siguiente: S\u00edmbolo y representaci\u00f3n Te\u00f3ricamente en Arduino, cada uno de esos LEDs podr\u00eda adoptar 256 (valores entre 0 y 255) colores diferentes, es decir, un total de 16.777.216 posibles colores diferentes con un LED RGB. PWM \u00b6 PWM son siglas en ingl\u00e9s que significan Pulse Width Modulation y que lo podemos traducir a espa\u00f1ol como Modulaci\u00f3n de ancho de pulso. Los pines PWM permiten generar una se\u00f1al anal\u00f3gica mediante una salida digital mapeada con 8 bits, o lo que es lo mismo, valores del 0 al 255, es decir mediante una salida PWM podemos emular una se\u00f1al anal\u00f3gica. En realidad una placa tipo UNO no es capaz de generar una salida anal\u00f3gica y lo que se hace es emplear un truco que consiste en activar una salida digital durante un tiempo y el resto del tiempo del ciclo mantenerla desactivada. El valor promedio de la salida es el valor anal\u00f3gico. En el tipo de modulaci\u00f3n PWM mantendremos constante la frecuencia, o lo que es lo mismo, el tiempo entre pulsos y lo que se hace es variar la anchura del pulso. La proporci\u00f3n de tiempo que est\u00e1 encendida la se\u00f1al, respecto al total del ciclo, se denomina ciclo de trabajo o Duty cycle, y generalmente se expresa en tanto por ciento. En la imagen siguiente vemos se\u00f1ales con distintos ciclos de trabajo. Distintos Duty cicle Es importante recordar que en una salida PWM el valor de la tensi\u00f3n es 5V por lo que si alimentamos un dispositivo de 3V a partir de una salida de 5V lo da\u00f1aremos de forma irreversible. Las se\u00f1ales PWM emula una se\u00f1al anal\u00f3gica para aplicaciones como variar la luminosidad de un LED y variar la velocidad de motores de corriente continua. La placa ESP32 Pus STEAMakers tiene muchas salidas PWM, pero en la placa Imagina TDR STEAM s\u00f3lo se puede controlar por PWM el led RGB (pines 6, 9 y 10) y los tres pines que quedan libres para conectar elementos externos. En la TdR STEAM \u00b6 En la placa existe un LED RGB 5050 de 6 pines como el de la imagen siguiente conectado a los pines D6 (Red), D9 (Green) y D10(Blue). Estos tres pines son PWM y nos van a permitir regular su intensidad. RGB 5050 En la placa TdR STEAM se localiza donde vemos en la imagen siguiente: LED RGB Programando la actividad \u00b6 En ArduinoBlocks disponemos de los dos bloques que vemos en la imagen siguiente para el control PWM del LED RGB. Bloques ArduinoBlocks para control PWM del LED RGB El bloque superior permite asignar el color a partir de la paleta que se despliega al hacer clic sobre el cuadrado de color y en el inferior debemos introducir el valor num\u00e9rico (entre 0 y 255) correspondiente a cada color primario en cada uno de los tres colores RGB. Con estos bloques no tenemos que preocuparnos por saber las conexiones de cada diodo ya que est\u00e1n asignadas internamente en el bloque. Tambi\u00e9n hemos visto que el LED RGB tiene asociados tres pines y por tanto podemos tratar a cada LED de forma individual. Pero para poder hacerlo debemos crear un tipo de proyecto \"ESP32 STEAMakers\" y no como hasta ahora \"ESP32 STEAMakers + Imagina TdR STEAM\". Esto nos va a permitir disponer del bloque LED que est\u00e1 dentro de \"Actuadores\" con todos los pines digitales configurables. De esta forma un programa como el de la imagen siguiente nos va a permitir activar de forma individual cada diodo LED. La soluci\u00f3n a esta actividad la tenemos disponible en Actividad-04 . Actividad 04 Retos de ampliaci\u00f3n \u00b6 A4.R1 . A partir de la idea del reto realizar un programa que muestre sucesivamente los siguientes colores: magenta o violeta, cian o azul claro, amarillo y blanco. Ay\u00fadate del gr\u00e1fico que muestra el modelo aditivo de colores que hemos puesto al principio de la teor\u00eda. A4.R2 . Realizar un programa que nos muestre los tres colores primarios a partir de un proyecto tipo \"ESP32 STEAMakers + Imagina TdR STEAM\" y el bloque con la paleta de colores. A4.R3 . Realizar un programa que nos muestre los tres colores primarios a partir de un proyecto tipo \"ESP32 STEAMakers + Imagina TdR STEAM\" y el bloque con el valor num\u00e9rico de cada color. A4.R4 . Realizar un programa que muestre de manera secuencial los colores del arcoiris en el orden que vemos en la imagen siguiente. Colores del arcoiris Soluci\u00f3n A4.R2 \u00b6 El Programa es el de la imagen siguiente: Soluci\u00f3n A4.R2 Soluci\u00f3n A4.R3 \u00b6 El Programa es el de la imagen siguiente: Soluci\u00f3n A4.R3","title":"Actividad-04. LED RGB"},{"location":"A04/#actividad-04-led-rgb","text":"","title":"Actividad-04. LED RGB"},{"location":"A04/#enunciado","text":"La actividad b\u00e1sics consistir\u00e1 en ver los colores primarios y su mezcla mediante el uso del LED RGB y tambi\u00e9n habr\u00e1 una actividad secundaria sobre el control de intensidad mediante PWM.","title":"Enunciado"},{"location":"A04/#teoria","text":"","title":"Teor\u00eda"},{"location":"A04/#led-rgb","text":"Un LED RGB es en realidad un encapsulado que incorpora tres diodos LED, uno por cada color fundamental. Los colores primarios en \u00f3ptica son el rojo, el verde y el azul y la correcta combinaci\u00f3n, en t\u00e9rminos de intensidad, de ellos originar\u00e1 cualquiera de los colores secundarios. Las siglas RGB son el acr\u00f3nimo de Red, Green y Blue. En el caso de la TDR-STEAM se utiliza un LED RGB con los tres LEDs unidos por su c\u00e1todo o terminal negativo, es decir es un LED RGB de c\u00e1todo com\u00fan. En la imagen siguiente vemos el modelo aditivo de los colores rojo, verde y azul. | RGB El s\u00edmbolo y la representaci\u00f3n mas comunes de este componente lo vemos en la imagen siguiente: S\u00edmbolo y representaci\u00f3n Te\u00f3ricamente en Arduino, cada uno de esos LEDs podr\u00eda adoptar 256 (valores entre 0 y 255) colores diferentes, es decir, un total de 16.777.216 posibles colores diferentes con un LED RGB.","title":"LED RGB"},{"location":"A04/#pwm","text":"PWM son siglas en ingl\u00e9s que significan Pulse Width Modulation y que lo podemos traducir a espa\u00f1ol como Modulaci\u00f3n de ancho de pulso. Los pines PWM permiten generar una se\u00f1al anal\u00f3gica mediante una salida digital mapeada con 8 bits, o lo que es lo mismo, valores del 0 al 255, es decir mediante una salida PWM podemos emular una se\u00f1al anal\u00f3gica. En realidad una placa tipo UNO no es capaz de generar una salida anal\u00f3gica y lo que se hace es emplear un truco que consiste en activar una salida digital durante un tiempo y el resto del tiempo del ciclo mantenerla desactivada. El valor promedio de la salida es el valor anal\u00f3gico. En el tipo de modulaci\u00f3n PWM mantendremos constante la frecuencia, o lo que es lo mismo, el tiempo entre pulsos y lo que se hace es variar la anchura del pulso. La proporci\u00f3n de tiempo que est\u00e1 encendida la se\u00f1al, respecto al total del ciclo, se denomina ciclo de trabajo o Duty cycle, y generalmente se expresa en tanto por ciento. En la imagen siguiente vemos se\u00f1ales con distintos ciclos de trabajo. Distintos Duty cicle Es importante recordar que en una salida PWM el valor de la tensi\u00f3n es 5V por lo que si alimentamos un dispositivo de 3V a partir de una salida de 5V lo da\u00f1aremos de forma irreversible. Las se\u00f1ales PWM emula una se\u00f1al anal\u00f3gica para aplicaciones como variar la luminosidad de un LED y variar la velocidad de motores de corriente continua. La placa ESP32 Pus STEAMakers tiene muchas salidas PWM, pero en la placa Imagina TDR STEAM s\u00f3lo se puede controlar por PWM el led RGB (pines 6, 9 y 10) y los tres pines que quedan libres para conectar elementos externos.","title":"PWM"},{"location":"A04/#en-la-tdr-steam","text":"En la placa existe un LED RGB 5050 de 6 pines como el de la imagen siguiente conectado a los pines D6 (Red), D9 (Green) y D10(Blue). Estos tres pines son PWM y nos van a permitir regular su intensidad. RGB 5050 En la placa TdR STEAM se localiza donde vemos en la imagen siguiente: LED RGB","title":"En la TdR STEAM"},{"location":"A04/#programando-la-actividad","text":"En ArduinoBlocks disponemos de los dos bloques que vemos en la imagen siguiente para el control PWM del LED RGB. Bloques ArduinoBlocks para control PWM del LED RGB El bloque superior permite asignar el color a partir de la paleta que se despliega al hacer clic sobre el cuadrado de color y en el inferior debemos introducir el valor num\u00e9rico (entre 0 y 255) correspondiente a cada color primario en cada uno de los tres colores RGB. Con estos bloques no tenemos que preocuparnos por saber las conexiones de cada diodo ya que est\u00e1n asignadas internamente en el bloque. Tambi\u00e9n hemos visto que el LED RGB tiene asociados tres pines y por tanto podemos tratar a cada LED de forma individual. Pero para poder hacerlo debemos crear un tipo de proyecto \"ESP32 STEAMakers\" y no como hasta ahora \"ESP32 STEAMakers + Imagina TdR STEAM\". Esto nos va a permitir disponer del bloque LED que est\u00e1 dentro de \"Actuadores\" con todos los pines digitales configurables. De esta forma un programa como el de la imagen siguiente nos va a permitir activar de forma individual cada diodo LED. La soluci\u00f3n a esta actividad la tenemos disponible en Actividad-04 . Actividad 04","title":"Programando la actividad"},{"location":"A04/#retos-de-ampliacion","text":"A4.R1 . A partir de la idea del reto realizar un programa que muestre sucesivamente los siguientes colores: magenta o violeta, cian o azul claro, amarillo y blanco. Ay\u00fadate del gr\u00e1fico que muestra el modelo aditivo de colores que hemos puesto al principio de la teor\u00eda. A4.R2 . Realizar un programa que nos muestre los tres colores primarios a partir de un proyecto tipo \"ESP32 STEAMakers + Imagina TdR STEAM\" y el bloque con la paleta de colores. A4.R3 . Realizar un programa que nos muestre los tres colores primarios a partir de un proyecto tipo \"ESP32 STEAMakers + Imagina TdR STEAM\" y el bloque con el valor num\u00e9rico de cada color. A4.R4 . Realizar un programa que muestre de manera secuencial los colores del arcoiris en el orden que vemos en la imagen siguiente. Colores del arcoiris","title":"Retos de ampliaci\u00f3n"},{"location":"A04/#solucion-a4r2","text":"El Programa es el de la imagen siguiente: Soluci\u00f3n A4.R2","title":"Soluci\u00f3n A4.R2"},{"location":"A04/#solucion-a4r3","text":"El Programa es el de la imagen siguiente: Soluci\u00f3n A4.R3","title":"Soluci\u00f3n A4.R3"},{"location":"A05/","text":"Actividad-05. Zumbador \u00b6 Enunciado \u00b6 Trabajaremos con el buzzer o zumbador partiendo de la reproducci\u00f3n de sonidos b\u00e1sicos hasta llegar a la reproducci\u00f3n de melod\u00edas completas. Teor\u00eda \u00b6 El buzzer, zumbador o altavoz es un transductor electroac\u00fastico (convierte una se\u00f1al el\u00e9ctrica en una onda de sonido) que produce un determinado zumbido o sonido. Existen de dos tipos: Pasivos : no disponen de electr\u00f3nica interna, por lo que tenemos que proporcionar una se\u00f1al el\u00e9ctrica para conseguir el sonido deseado. Activos : disponen de un oscilador interno, por lo que \u00fanicamente tenemos que alimentar el dispositivo para que se produzca el sonido. Zumbador pasivo \u00b6 El zumbador que incorpora la placa TdR STEAM es de tipo pasivo y est\u00e1 conectado al pin D8. Una de los par\u00e1metros que caracterizan a un sonido es su frecuencia de emisi\u00f3n, siendo la frecuencia el n\u00famero de veces que se repite por unidad de tiempo (segundo). La transmisi\u00f3n del sonido se realiza por ondas a trav\u00e9s en cualquier medio (s\u00f3lido, l\u00edquido o gaseoso) excepto en el vac\u00edo. La frecuencia de un sonido nos indica cuantos ciclos por segundo tiene una onda. En la imagen y la tabla siguientes vemos un dibujo con un fragmento de las teclas de un piano estando todo referido a una nota est\u00e1ndar, la nota \"La\" central que tiene una frecuencia de 440 Hz. Podemos ver la nota musical que reproduce, en las dos notaciones m\u00e1s comunes de los sonidos (Ingl\u00e9s: C D E F G A B, Alem\u00e1n: C D E F G A H, Espa\u00f1ol, italiano y franc\u00e9s: Do Re Mi Fa Sol La Si) y adem\u00e1s se encuentra la frecuencia que produce esa nota musical. Secci\u00f3n de piano y notas Bloques de programaci\u00f3n \u00b6 En ArduinoBlocks disponemos de un bloque que nos permite reproducir cualquier melod\u00eda RTTTL (del ingl\u00e9s, Ring Tone Text Transfer Language) y es el que vemos en la imagen siguiente: Bloque Reproducir RTTTL Este bloque permite reproducir una melod\u00eda a partir de un texto con formato RTTTL, formato desarrollado por Nokia para ser usado para transferir tonos de llamada a tel\u00e9fonos m\u00f3viles. El formato RTTTL es una cadena dividida en tres secciones: nombre, valor predeterminado y datos. Por ejemplo, la siguiente cadena de texto se corresponde con la Intro de Donkey Kong: d=4,o=5,b=140:8a#,8p,8d6,16p,16f.6,16g.6,16f.6,8a#,8p,8d6,16p,16f.6,16g.6,16f.6,8a#,8p,8d6,16p,16f.6,16g.6,16f.6,8a#,8p,8d6,16p,16f.6,16g.6,16f.6 Lo \u00fanico que tenemos que hacer para reproducir la melod\u00eda es pegar esta cadena en la zona de texto del bloque. ArduinoBlocks nos suministra informaci\u00f3n y enlaces referentes al tema accediendo desde nuestro proyecto a herramientas y escogiendo RTTTL Info, tal y como vemos en la imagen siguiente: Acceso a RTTTL Info En la imagen siguiente tenemos desplegada la informaci\u00f3n que nos ofrece esta herramienta. Informaci\u00f3n RTTTL Tambi\u00e9n podemos acceder a esta informaci\u00f3n haciendo clic derecho sobre el bloque y escogiendo la opci\u00f3n \"Ayuda\" de entre las mostradas en la ventana emergente. Zumbador activo \u00b6 Existe otro tipo de zumbador que incluye un oscilador que genera una frecuencia audible fija y que se conoce como zumbador pasivo y en realidad es el que de forma correcta se puede denominar como zumbador. Este es mucho mas sencillo de usar ya que basta con conectarlo a un pin digital y cuando pongamos a nivel alto este pin el zumbador generar\u00e1 su zumbido caracter\u00edstico durante el tiempo que establezcamos. Con este tipo de zumbador no se pueden generar melod\u00edas. Cuando est\u00e1 nuevo se distingue del zumbador pasivo o altavoz por la pegatina de protecci\u00f3n que lo acompa\u00f1a, pero esta hay que quitarla para oir el zumbido y sin ella es dif\u00edcil distinguir un tipo del otro, as\u00ed que en este caso deberemos crear un programa con alguna melod\u00eda y si no se reproduce correctamente es que tenemos conectado el zumbador activo en lugar del pasivo. Lo mejor es marcar alguno de los dos cuando podemos distinguirlos. Una buena idea puede ser utilizar la propia pegatina en el lateral del mismo. En la TdR STEAM \u00b6 El buzzer en la TdR STEAM Programando la actividad \u00b6 Los cuatro bloques destinados a trabajar con el zumbador los vemos en la imagen siguiente: Los 4 bloques para trabajar con el zumbador En el bloque Zumbador podemos modificar dos par\u00e1metros, el tiempo que dura cada sonido expresado en milisegundos (campo Ms) y la frecuencia en Hz a la que reproducir\u00e1 el sonido el zumbador (campo Hz). Vamos a comenzar haciendo un programa que reproduzca tres de las notas de la escala musical vista anteriormente. La soluci\u00f3n al reto la tenemos disponible en Actividad-05 . Actividad-05 Retos de ampliaci\u00f3n \u00b6 A5.R1 . Reproducir la escala musical con las notas b\u00e1sicas utilizando los bloques Zumbador y Tono A5.R2 . Reproducir la melod\u00eda de la imagen siguiente sabiendo que las negras tienen una duraci\u00f3n de 500ms, las negras con un puntito 750ms y las blancas 1000ms. Himno a la alegria A5.R3 . Reproducir diferentes melod\u00edas a partir de los bloques RTTTL (Ring Tone Text Transfer Language o lenguaje de tonos de llamada). A5.R4 . Reproducir alguna otra melod\u00eda que descarguemos de las p\u00e1ginas web propuestas.","title":"Actividad-05. Zumbador"},{"location":"A05/#actividad-05-zumbador","text":"","title":"Actividad-05. Zumbador"},{"location":"A05/#enunciado","text":"Trabajaremos con el buzzer o zumbador partiendo de la reproducci\u00f3n de sonidos b\u00e1sicos hasta llegar a la reproducci\u00f3n de melod\u00edas completas.","title":"Enunciado"},{"location":"A05/#teoria","text":"El buzzer, zumbador o altavoz es un transductor electroac\u00fastico (convierte una se\u00f1al el\u00e9ctrica en una onda de sonido) que produce un determinado zumbido o sonido. Existen de dos tipos: Pasivos : no disponen de electr\u00f3nica interna, por lo que tenemos que proporcionar una se\u00f1al el\u00e9ctrica para conseguir el sonido deseado. Activos : disponen de un oscilador interno, por lo que \u00fanicamente tenemos que alimentar el dispositivo para que se produzca el sonido.","title":"Teor\u00eda"},{"location":"A05/#zumbador-pasivo","text":"El zumbador que incorpora la placa TdR STEAM es de tipo pasivo y est\u00e1 conectado al pin D8. Una de los par\u00e1metros que caracterizan a un sonido es su frecuencia de emisi\u00f3n, siendo la frecuencia el n\u00famero de veces que se repite por unidad de tiempo (segundo). La transmisi\u00f3n del sonido se realiza por ondas a trav\u00e9s en cualquier medio (s\u00f3lido, l\u00edquido o gaseoso) excepto en el vac\u00edo. La frecuencia de un sonido nos indica cuantos ciclos por segundo tiene una onda. En la imagen y la tabla siguientes vemos un dibujo con un fragmento de las teclas de un piano estando todo referido a una nota est\u00e1ndar, la nota \"La\" central que tiene una frecuencia de 440 Hz. Podemos ver la nota musical que reproduce, en las dos notaciones m\u00e1s comunes de los sonidos (Ingl\u00e9s: C D E F G A B, Alem\u00e1n: C D E F G A H, Espa\u00f1ol, italiano y franc\u00e9s: Do Re Mi Fa Sol La Si) y adem\u00e1s se encuentra la frecuencia que produce esa nota musical. Secci\u00f3n de piano y notas","title":"Zumbador pasivo"},{"location":"A05/#bloques-de-programacion","text":"En ArduinoBlocks disponemos de un bloque que nos permite reproducir cualquier melod\u00eda RTTTL (del ingl\u00e9s, Ring Tone Text Transfer Language) y es el que vemos en la imagen siguiente: Bloque Reproducir RTTTL Este bloque permite reproducir una melod\u00eda a partir de un texto con formato RTTTL, formato desarrollado por Nokia para ser usado para transferir tonos de llamada a tel\u00e9fonos m\u00f3viles. El formato RTTTL es una cadena dividida en tres secciones: nombre, valor predeterminado y datos. Por ejemplo, la siguiente cadena de texto se corresponde con la Intro de Donkey Kong: d=4,o=5,b=140:8a#,8p,8d6,16p,16f.6,16g.6,16f.6,8a#,8p,8d6,16p,16f.6,16g.6,16f.6,8a#,8p,8d6,16p,16f.6,16g.6,16f.6,8a#,8p,8d6,16p,16f.6,16g.6,16f.6 Lo \u00fanico que tenemos que hacer para reproducir la melod\u00eda es pegar esta cadena en la zona de texto del bloque. ArduinoBlocks nos suministra informaci\u00f3n y enlaces referentes al tema accediendo desde nuestro proyecto a herramientas y escogiendo RTTTL Info, tal y como vemos en la imagen siguiente: Acceso a RTTTL Info En la imagen siguiente tenemos desplegada la informaci\u00f3n que nos ofrece esta herramienta. Informaci\u00f3n RTTTL Tambi\u00e9n podemos acceder a esta informaci\u00f3n haciendo clic derecho sobre el bloque y escogiendo la opci\u00f3n \"Ayuda\" de entre las mostradas en la ventana emergente.","title":"Bloques de programaci\u00f3n"},{"location":"A05/#zumbador-activo","text":"Existe otro tipo de zumbador que incluye un oscilador que genera una frecuencia audible fija y que se conoce como zumbador pasivo y en realidad es el que de forma correcta se puede denominar como zumbador. Este es mucho mas sencillo de usar ya que basta con conectarlo a un pin digital y cuando pongamos a nivel alto este pin el zumbador generar\u00e1 su zumbido caracter\u00edstico durante el tiempo que establezcamos. Con este tipo de zumbador no se pueden generar melod\u00edas. Cuando est\u00e1 nuevo se distingue del zumbador pasivo o altavoz por la pegatina de protecci\u00f3n que lo acompa\u00f1a, pero esta hay que quitarla para oir el zumbido y sin ella es dif\u00edcil distinguir un tipo del otro, as\u00ed que en este caso deberemos crear un programa con alguna melod\u00eda y si no se reproduce correctamente es que tenemos conectado el zumbador activo en lugar del pasivo. Lo mejor es marcar alguno de los dos cuando podemos distinguirlos. Una buena idea puede ser utilizar la propia pegatina en el lateral del mismo.","title":"Zumbador activo"},{"location":"A05/#en-la-tdr-steam","text":"El buzzer en la TdR STEAM","title":"En la TdR STEAM"},{"location":"A05/#programando-la-actividad","text":"Los cuatro bloques destinados a trabajar con el zumbador los vemos en la imagen siguiente: Los 4 bloques para trabajar con el zumbador En el bloque Zumbador podemos modificar dos par\u00e1metros, el tiempo que dura cada sonido expresado en milisegundos (campo Ms) y la frecuencia en Hz a la que reproducir\u00e1 el sonido el zumbador (campo Hz). Vamos a comenzar haciendo un programa que reproduzca tres de las notas de la escala musical vista anteriormente. La soluci\u00f3n al reto la tenemos disponible en Actividad-05 . Actividad-05","title":"Programando la actividad"},{"location":"A05/#retos-de-ampliacion","text":"A5.R1 . Reproducir la escala musical con las notas b\u00e1sicas utilizando los bloques Zumbador y Tono A5.R2 . Reproducir la melod\u00eda de la imagen siguiente sabiendo que las negras tienen una duraci\u00f3n de 500ms, las negras con un puntito 750ms y las blancas 1000ms. Himno a la alegria A5.R3 . Reproducir diferentes melod\u00edas a partir de los bloques RTTTL (Ring Tone Text Transfer Language o lenguaje de tonos de llamada). A5.R4 . Reproducir alguna otra melod\u00eda que descarguemos de las p\u00e1ginas web propuestas.","title":"Retos de ampliaci\u00f3n"},{"location":"A06/","text":"Actividad-06. Pulsadores \u00b6 Enunciado \u00b6 Utilizaremos uno, o ambos pulsadores, para llevar a cabo determinadas tareas como respuesta al accionamiento de los mismos. Teor\u00eda \u00b6 El pulsador \u00b6 En la tabla siguiente vemos la simbolog\u00eda y algunos ejemplos del aspecto f\u00edsico de estos elementos. S\u00edmbolos y aspecto real de un pulsador Se trata de un dispositivo que es capaz de abrir o cerrar el paso de la corriente el\u00e9ctrica mientras permanece accionado, es decir, su funci\u00f3n no queda anclada como por ejemplo en los interruptores de la luz de casa, en donde el accionamiento permanece hasta que no se vuelve a accionar. En un pulsador, por contra, su activaci\u00f3n dura mientras lo mantenemos pulsado y vuelve a su estado de reposo en cuanto dejemos de pulsarlo. Mediante la configuraci\u00f3n adecuada podemos convertir un pulsador en un elemento de entrada a alg\u00fan pin de nuestra placa UNO. Las configuraciones m\u00e1s b\u00e1sicas posibles con pulsadores las podemos ver en la imagen siguiente. Configuraci\u00f3n circuito elemental con pulsador En el caso de la TdR STEAM los pulsadores se han configurado para que en reposo pongan a cero su entrada digital correspondiente y que se ponga a uno cuando son accionados. Concepto de variable y de contador \u00b6 El concepto de variable en programaci\u00f3n consiste simplemente en asignarle un nombre significativo a un espacio de memoria donde almacenar determinada informaci\u00f3n durante la ejecuci\u00f3n normal del programa. El concepto es muy amplio y complejo y en nuestro caso no vamos a entrar en detalles sobre el mismo, pero si indicar que no se debe confundir con el concepto de variable matem\u00e1tica, ya que una expresi\u00f3n como x = x + 1 que es una aberraci\u00f3n en matem\u00e1ticas tiene todo el sentido en programaci\u00f3n. L\u00f3gicamente en matem\u00e1ticas no se puede cumplir pero en programaci\u00f3n significa que a la variable x se le sume uno y el resultado se vuelva a guardar en la misma variable. En ArduinoBlocks podemos crear tres tipos de variables, num\u00e9ricas, de texto o booleanas. En la animaci\u00f3n siguiente podemos ver como se pueden crear, eliminar y renombrar variables. Crear, renombrar y eliminar variables En programaci\u00f3n, llamamos contador a una variable cuyo valor se incrementa o decrementa en un valor fijo para cada iteraci\u00f3n del bucle para el que se ha definido. El uso habitual de un contador es simplemente contar el n\u00famero de veces que itera un bucle en general o de forma mas extensa contar, solamente, aquellas iteraciones en las que se cumpla una determinada condici\u00f3n. Por ejemplo, supongamos que tenemos una variable de nombre Estado de valor inicial cero y que se incremente cada vez que accionamos un pulsador, de esta forma si en un bucle vamos incrementando la variable de uno en uno, tenemos: Estado = 0 // valor inicial Estado = 1 // Estado = Estado + 1 Estado = 2 // Estado = Estado + 1 ... Condicionales \u00b6 Las sentencias condicionales son aquellas que nos permiten tomar decisiones en funci\u00f3n de si ocurre o no ocurre determinada cosa. En el caso de ArduinoBlocks estas las podemos encontrar en el bloque l\u00f3gica. Este bloque contiene los elementos que vemos en la imagen siguiente: Bloques de l\u00f3gica El funcionamiento es el siguiente: se eval\u00faa la condici\u00f3n que ponemos en \"si\" y si el resultado es verdadero, o sea condici\u00f3n cierta, se realizan las acciones que pongamos en \"hacer\" y si no es cierta dichas acciones no se realizan. En el apartado condici\u00f3n se pueden poner infinidad de factores como pueden ser el estado de sensores, realizar comparaciones, hacer operaciones matem\u00e1ticas, etc. L\u00f3gicamente el resultado de evaluar la condici\u00f3n debe ser verdadero o falso lo que se resuelve en el caso de la programaci\u00f3n en Arduino diciendo que si el resultado es 0, el resultado de la evaluaci\u00f3n es falso y si es 1 o cualquier otro valor es verdadero. Si hemos sido observadores hemos visto en los bloques \"si\" de \"L\u00f3gica\" un signo mas (+) en la parte superior izquierda tanto del condicional \"if\" como la del \"if ... else\" tal y como se destaca en la imagen siguiente. A\u00f1adir opciones else if Cada vez que pulsemos sobre el signo mas se a\u00f1adir\u00e1 una cl\u00e1usula \"else if\" a la principal y podemos a\u00f1adir tantas como necesitemos. Esta cl\u00e1usula nos va a permitir establecer una nueva condici\u00f3n.En la imagen siguiente vemos a\u00f1adidas dos para el caso de \"if ... else\". En la imagen observamos el c\u00f3digo equivalente y las distintas condiciones que se pueden establecer. Clausula if...else con dos else if El signo menos (-) que aparece en la imagen sirve para eliminar la correspondiente cl\u00e1usula \"else if\". En la TdR STEAM \u00b6 La placa TdR STEAM dispone de dos pulsadores denominados SW1 y SW2 y conectados a los pines digitales D2 y D7 respectivamente. Pulsadores en la TdR STEAM Programando la actividad \u00b6 La aplicaci\u00f3n de un pulsador para hacer algo requiere saber si este esta pulsado o no lo est\u00e1 y para ello vamos a necesitar de las sentencias condicionales que hemos visto anteriormente. Vamos a hacer un programa en el que preguntemos si el pulsador SW1 (D2) est\u00e1 o no pulsado y si lo est\u00e1 que se encienda el LED rojo (D12) y si no lo pulsamos que permanezca apagado. La soluci\u00f3n al reto la tenemos disponible en Actividad-06 . A modo de comentario se ha colocado otra forma de realizar la misma programaci\u00f3n que podemos probar simplemente arrastrando el bloque que hay en bucle fuera del mismo y colocando el otro en su lugar. Actividad-06 Ampliaci\u00f3n sobre programaci\u00f3n de la actividad \u00b6 Ya se ha explicado el funcionamiento del signo mas (+) de la parte superior izquierda tanto del condicional \"if\" como la del \"if ... else\". Cada vez que pulsemos sobre el signo mas se a\u00f1adir\u00e1 una cl\u00e1usula \"else if\" a la principal y podemos a\u00f1adir tantas como necesitemos. Esta cl\u00e1usula nos va a permitir establecer una nueva condici\u00f3n. El signo menos (-) que aparece en la imagen sirve para eliminar la correspondiente cl\u00e1usula \"else if\". Vamos a hace un programa similar a la Actividad-06 para hacer que si pulsamos SW2 se encienda el LED azul y si no est\u00e1 pulsado permanecer\u00e1 apagado. La soluci\u00f3n la tenemos disponible en Actividad-06-ampliaci\u00f3n-1 . Actividad-06-ampliacion-1 El siguiente programa har\u00e1 que se encienda el LED azul al pulsar SW1 y el LED rojo al pulsar SW2 se encienda el rojo permaneciendo apagados si no est\u00e1n pulsados. Observese la primera condici\u00f3n AND (Y) que impide que si pulsamos ambos pulsadores al mismo tiempo se enciendan los LEDs. La soluci\u00f3n la tenemos disponible en Actividad-06-ampliaci\u00f3n-2 . Actividad-06-ampliacion-2 Retos de ampliaci\u00f3n \u00b6 A6.R1 . Resolver el reto inicial de forma que el funcionamiento sea al contrario, es decir, que el LED rojo est\u00e9 siempre encendido y al pulsar SW1 se apague. A6.R2 . Hacer un programa que al pulsar SW1 se encienda el LED azul y que al pulsar SW2 se apague. Como ampliaci\u00f3n se sugiere modificar el programa para que encienda y apague los dos LEDs a un tiempo. A6.R3 . Hacer un programa que emita, usando SW1 como si fuese un tel\u00e9grafo, el c\u00f3digo Morse universal de solicitud de socorro, SOS. A6.R4 . Hacer un programa que al pulsar SW1 encienda el LED azul y que este permanezca encendido hasta que no pulsemos SW1 dos veces mas (3 pulsaciones en total), en cuyo caso se apagar\u00e1. Soluci\u00f3n A6.R1 \u00b6 La soluci\u00f3n est\u00e1 en utilizar el operador NOT. El Programa es el de la imagen siguiente: Reto 1 de la actividad 6 Soluci\u00f3n A6.R2 \u00b6 La soluci\u00f3n en esta ocasi\u00f3n est\u00e1 en utilizar el operador NOT y el operador AND. El Programa es el de la imagen siguiente: Reto 2 de la actividad 6 Soluci\u00f3n A6.R3 \u00b6 El alfabeto Morse lo vemos en la imagen siguiente, donde podemos observar que la S son tres puntos o pulsaciones cortas y la O son tres rayas o pulsaciones largas. Sin entrar en mas detalles daremos la soluci\u00f3n considerando SOS como una palabra (es lo universalmente adoptado) de forma que no haremos pausas entre letras. Alfabeto Morse El Programa es el de la imagen siguiente: Reto 3 de la actividad 6 Soluci\u00f3n A6.R4 \u00b6 Definimos una variable y la utilizamos para resolver el programa mediante un contador. El Programa es el de la imagen siguiente: Reto 4 de la actividad 6","title":"Actividad-06. Pulsadores"},{"location":"A06/#actividad-06-pulsadores","text":"","title":"Actividad-06. Pulsadores"},{"location":"A06/#enunciado","text":"Utilizaremos uno, o ambos pulsadores, para llevar a cabo determinadas tareas como respuesta al accionamiento de los mismos.","title":"Enunciado"},{"location":"A06/#teoria","text":"","title":"Teor\u00eda"},{"location":"A06/#el-pulsador","text":"En la tabla siguiente vemos la simbolog\u00eda y algunos ejemplos del aspecto f\u00edsico de estos elementos. S\u00edmbolos y aspecto real de un pulsador Se trata de un dispositivo que es capaz de abrir o cerrar el paso de la corriente el\u00e9ctrica mientras permanece accionado, es decir, su funci\u00f3n no queda anclada como por ejemplo en los interruptores de la luz de casa, en donde el accionamiento permanece hasta que no se vuelve a accionar. En un pulsador, por contra, su activaci\u00f3n dura mientras lo mantenemos pulsado y vuelve a su estado de reposo en cuanto dejemos de pulsarlo. Mediante la configuraci\u00f3n adecuada podemos convertir un pulsador en un elemento de entrada a alg\u00fan pin de nuestra placa UNO. Las configuraciones m\u00e1s b\u00e1sicas posibles con pulsadores las podemos ver en la imagen siguiente. Configuraci\u00f3n circuito elemental con pulsador En el caso de la TdR STEAM los pulsadores se han configurado para que en reposo pongan a cero su entrada digital correspondiente y que se ponga a uno cuando son accionados.","title":"El pulsador"},{"location":"A06/#concepto-de-variable-y-de-contador","text":"El concepto de variable en programaci\u00f3n consiste simplemente en asignarle un nombre significativo a un espacio de memoria donde almacenar determinada informaci\u00f3n durante la ejecuci\u00f3n normal del programa. El concepto es muy amplio y complejo y en nuestro caso no vamos a entrar en detalles sobre el mismo, pero si indicar que no se debe confundir con el concepto de variable matem\u00e1tica, ya que una expresi\u00f3n como x = x + 1 que es una aberraci\u00f3n en matem\u00e1ticas tiene todo el sentido en programaci\u00f3n. L\u00f3gicamente en matem\u00e1ticas no se puede cumplir pero en programaci\u00f3n significa que a la variable x se le sume uno y el resultado se vuelva a guardar en la misma variable. En ArduinoBlocks podemos crear tres tipos de variables, num\u00e9ricas, de texto o booleanas. En la animaci\u00f3n siguiente podemos ver como se pueden crear, eliminar y renombrar variables. Crear, renombrar y eliminar variables En programaci\u00f3n, llamamos contador a una variable cuyo valor se incrementa o decrementa en un valor fijo para cada iteraci\u00f3n del bucle para el que se ha definido. El uso habitual de un contador es simplemente contar el n\u00famero de veces que itera un bucle en general o de forma mas extensa contar, solamente, aquellas iteraciones en las que se cumpla una determinada condici\u00f3n. Por ejemplo, supongamos que tenemos una variable de nombre Estado de valor inicial cero y que se incremente cada vez que accionamos un pulsador, de esta forma si en un bucle vamos incrementando la variable de uno en uno, tenemos: Estado = 0 // valor inicial Estado = 1 // Estado = Estado + 1 Estado = 2 // Estado = Estado + 1 ...","title":"Concepto de variable y de contador"},{"location":"A06/#condicionales","text":"Las sentencias condicionales son aquellas que nos permiten tomar decisiones en funci\u00f3n de si ocurre o no ocurre determinada cosa. En el caso de ArduinoBlocks estas las podemos encontrar en el bloque l\u00f3gica. Este bloque contiene los elementos que vemos en la imagen siguiente: Bloques de l\u00f3gica El funcionamiento es el siguiente: se eval\u00faa la condici\u00f3n que ponemos en \"si\" y si el resultado es verdadero, o sea condici\u00f3n cierta, se realizan las acciones que pongamos en \"hacer\" y si no es cierta dichas acciones no se realizan. En el apartado condici\u00f3n se pueden poner infinidad de factores como pueden ser el estado de sensores, realizar comparaciones, hacer operaciones matem\u00e1ticas, etc. L\u00f3gicamente el resultado de evaluar la condici\u00f3n debe ser verdadero o falso lo que se resuelve en el caso de la programaci\u00f3n en Arduino diciendo que si el resultado es 0, el resultado de la evaluaci\u00f3n es falso y si es 1 o cualquier otro valor es verdadero. Si hemos sido observadores hemos visto en los bloques \"si\" de \"L\u00f3gica\" un signo mas (+) en la parte superior izquierda tanto del condicional \"if\" como la del \"if ... else\" tal y como se destaca en la imagen siguiente. A\u00f1adir opciones else if Cada vez que pulsemos sobre el signo mas se a\u00f1adir\u00e1 una cl\u00e1usula \"else if\" a la principal y podemos a\u00f1adir tantas como necesitemos. Esta cl\u00e1usula nos va a permitir establecer una nueva condici\u00f3n.En la imagen siguiente vemos a\u00f1adidas dos para el caso de \"if ... else\". En la imagen observamos el c\u00f3digo equivalente y las distintas condiciones que se pueden establecer. Clausula if...else con dos else if El signo menos (-) que aparece en la imagen sirve para eliminar la correspondiente cl\u00e1usula \"else if\".","title":"Condicionales"},{"location":"A06/#en-la-tdr-steam","text":"La placa TdR STEAM dispone de dos pulsadores denominados SW1 y SW2 y conectados a los pines digitales D2 y D7 respectivamente. Pulsadores en la TdR STEAM","title":"En la TdR STEAM"},{"location":"A06/#programando-la-actividad","text":"La aplicaci\u00f3n de un pulsador para hacer algo requiere saber si este esta pulsado o no lo est\u00e1 y para ello vamos a necesitar de las sentencias condicionales que hemos visto anteriormente. Vamos a hacer un programa en el que preguntemos si el pulsador SW1 (D2) est\u00e1 o no pulsado y si lo est\u00e1 que se encienda el LED rojo (D12) y si no lo pulsamos que permanezca apagado. La soluci\u00f3n al reto la tenemos disponible en Actividad-06 . A modo de comentario se ha colocado otra forma de realizar la misma programaci\u00f3n que podemos probar simplemente arrastrando el bloque que hay en bucle fuera del mismo y colocando el otro en su lugar. Actividad-06","title":"Programando la actividad"},{"location":"A06/#ampliacion-sobre-programacion-de-la-actividad","text":"Ya se ha explicado el funcionamiento del signo mas (+) de la parte superior izquierda tanto del condicional \"if\" como la del \"if ... else\". Cada vez que pulsemos sobre el signo mas se a\u00f1adir\u00e1 una cl\u00e1usula \"else if\" a la principal y podemos a\u00f1adir tantas como necesitemos. Esta cl\u00e1usula nos va a permitir establecer una nueva condici\u00f3n. El signo menos (-) que aparece en la imagen sirve para eliminar la correspondiente cl\u00e1usula \"else if\". Vamos a hace un programa similar a la Actividad-06 para hacer que si pulsamos SW2 se encienda el LED azul y si no est\u00e1 pulsado permanecer\u00e1 apagado. La soluci\u00f3n la tenemos disponible en Actividad-06-ampliaci\u00f3n-1 . Actividad-06-ampliacion-1 El siguiente programa har\u00e1 que se encienda el LED azul al pulsar SW1 y el LED rojo al pulsar SW2 se encienda el rojo permaneciendo apagados si no est\u00e1n pulsados. Observese la primera condici\u00f3n AND (Y) que impide que si pulsamos ambos pulsadores al mismo tiempo se enciendan los LEDs. La soluci\u00f3n la tenemos disponible en Actividad-06-ampliaci\u00f3n-2 . Actividad-06-ampliacion-2","title":"Ampliaci\u00f3n sobre programaci\u00f3n de la actividad"},{"location":"A06/#retos-de-ampliacion","text":"A6.R1 . Resolver el reto inicial de forma que el funcionamiento sea al contrario, es decir, que el LED rojo est\u00e9 siempre encendido y al pulsar SW1 se apague. A6.R2 . Hacer un programa que al pulsar SW1 se encienda el LED azul y que al pulsar SW2 se apague. Como ampliaci\u00f3n se sugiere modificar el programa para que encienda y apague los dos LEDs a un tiempo. A6.R3 . Hacer un programa que emita, usando SW1 como si fuese un tel\u00e9grafo, el c\u00f3digo Morse universal de solicitud de socorro, SOS. A6.R4 . Hacer un programa que al pulsar SW1 encienda el LED azul y que este permanezca encendido hasta que no pulsemos SW1 dos veces mas (3 pulsaciones en total), en cuyo caso se apagar\u00e1.","title":"Retos de ampliaci\u00f3n"},{"location":"A06/#solucion-a6r1","text":"La soluci\u00f3n est\u00e1 en utilizar el operador NOT. El Programa es el de la imagen siguiente: Reto 1 de la actividad 6","title":"Soluci\u00f3n A6.R1"},{"location":"A06/#solucion-a6r2","text":"La soluci\u00f3n en esta ocasi\u00f3n est\u00e1 en utilizar el operador NOT y el operador AND. El Programa es el de la imagen siguiente: Reto 2 de la actividad 6","title":"Soluci\u00f3n A6.R2"},{"location":"A06/#solucion-a6r3","text":"El alfabeto Morse lo vemos en la imagen siguiente, donde podemos observar que la S son tres puntos o pulsaciones cortas y la O son tres rayas o pulsaciones largas. Sin entrar en mas detalles daremos la soluci\u00f3n considerando SOS como una palabra (es lo universalmente adoptado) de forma que no haremos pausas entre letras. Alfabeto Morse El Programa es el de la imagen siguiente: Reto 3 de la actividad 6","title":"Soluci\u00f3n A6.R3"},{"location":"A06/#solucion-a6r4","text":"Definimos una variable y la utilizamos para resolver el programa mediante un contador. El Programa es el de la imagen siguiente: Reto 4 de la actividad 6","title":"Soluci\u00f3n A6.R4"},{"location":"A07/","text":"Actividad-07. El potenci\u00f3metro \u00b6 Enunciado \u00b6 Introducir el uso de las entradas anal\u00f3gicas para visualizar los cambios que hagamos con el potenci\u00f3metro en el terminal serie o consola serie. Cuando hablamos de lecturas anal\u00f3gicas suele ser muy \u00fatil el uso del mapeo, concepto que tambi\u00e9n vamos a introducir y que veremos en la segunda parte del reto. Teor\u00eda \u00b6 Antes de nada ya hemos indicado que el potenciometro va conectado a un pin anal\u00f3gico y es en este momento cuando vamos a establecer la diferencia entre los conceptos de anal\u00f3gico y de digital. Una clasificaci\u00f3n de los circuitos electr\u00f3nicos es dividirlos en dos grandes categor\u00edas: digitales y anal\u00f3gicos. La electr\u00f3nica digital utiliza magnitudes con dos valores discretos conocidos como 0 - 1, alto - bajo, on - off, etc, y que se corresponden con la presencia o no de tensi\u00f3n en un determinado punto. La electr\u00f3nica anal\u00f3gica emplea magnitudes con valores continuos. En concreto en las placas En la ESP32 Plus STEAMakers, las entradas anal\u00f3gicas pueden tener 2^12 valores (12 bits de resoluci\u00f3n = 4.096 valores), es decir, valores comprendidos entre 0 y 4.095. Estos valores se pueden expresar de forma num\u00e9rica o de forma porcentual, correspondiendo el 0 a un 0% y el 4.095 al 100%. El potenci\u00f3metro \u00b6 En la imagen siguiente vemos el aspecto de un modelo concreto de potenci\u00f3metro as\u00ed como los s\u00edmbolos habituales del mismo. La numeraci\u00f3n indica lo siguiente: Terminales 1 y 3 son los contactos unidos a los extremos de la resistencia fija o resistencia total del potenci\u00f3metro. Terminal 2 es el contacto que va unido al cursor o parte m\u00f3vil que se desliza sobre la resistencia fija haciendo que la resistencia entre un terminal y el cursor var\u00ede en funci\u00f3n de la posici\u00f3n de este. Aspecto y s\u00edmbolo del potenci\u00f3metro La posici\u00f3n del cursor se determina de forma mec\u00e1nica y son adecuados para usarlos como elementos de control de tensi\u00f3n (conexi\u00f3n en serie) o de corriente (conexi\u00f3n en paralelo). Los potenci\u00f3metros del tipo que estamos viendo (existen de otros muchos tipos) tienen un funcionamiento en forma de rotaci\u00f3n con un \u00e1ngulo de unos 270 grados entre los puntos mas extremos. El terminal o consola serie \u00b6 Sirve para visualizar en un ordenador los datos recibidos a trav\u00e9s del puerto serie y en realidad es una aplicaci\u00f3n que controla las comunicaciones bidireccionales a trav\u00e9s de la UART integrada en el microcontrolador. Es muy importante tener siempre presente que el puerto serie es el que se utiliza para \"subir\" el firmware o programa a la placa, tarea que se realiza a trav\u00e9s de una aplicaci\u00f3n pregrabada en el microntrolador y que se denomina \"bootloader\". En ArduinoBlocks es posible usar la consola serie solamente si tenemos instalada y en funcionamiento la aplicaci\u00f3n ArduinoBlocks-Connector que es la encargada de establecer las comunicaciones locales de nuestra placa con las remotas de la aplicaci\u00f3n. En la imagen siguiente vemos el aspecto de la consola. Aspecto de la Consola en AB A la hora de establecer una conexi\u00f3n serie los dos extremos que intervienen en la conexi\u00f3n (placa ESP32 STEAMakers y ordenador) deben establecer el mismo valor en la velocidad de la conexi\u00f3n. Por defecto esta velocidad es de 115200 baudios o bits por segundo en el bloque inicializar y otras velocidades comunmente utilizadas son: 4800, 9600, 19200, 38400, 57600. Es por lo tanto imprescindible incluir en el bloque \"Inicializar\" el bloque \"Iniciar\" y establecer la velocidad de comunicaci\u00f3n. Serial Plotter - Datalogger \u00b6 Es otra funcionalidad relacionada con la comunicaci\u00f3n serie que nos permite visualizar informaci\u00f3n en forma de gr\u00e1fica en tiempo real. Adem\u00e1s el \u201cSerial Plotter\u201d implementa un sencillo datalogger con el que podemos ir grabando los datos para exportarlos posteriormente. En ArduinoBlocks existen bloques que nos permiten trabajar con el serial plotter. El serial plotter + datalogger se activa haciendo clic en la flecha a la derecha de Consola y tiene el aspecto que vemos en la imagen siguiente: Serial Plotter + Datalogger Mapeo \u00b6 Hemos indicado que las entradas anal\u00f3gicas trabajan con 12 bits, o sea valores comprendidos entre 0 y 4095 (2^12) y tambi\u00e9n que las salidas digitales trabajan con 8 bits, o sea valores entre 0 y 255 (28), por lo que si queremos combinar en nuestro programa entradas anal\u00f3gicas con salidas digitales debemos realizar un ajuste de escala en los datos. A este ajuste se le conoce como \"mapear\" y es un bloque disponible en el men\u00fa Matem\u00e1ticas con el aspecto de la imagen siguiente: Bloque mapear En la TdR STEAM \u00b6 El potenciometro de la TdR STEAM Programando la actividad \u00b6 Parte 1 . Vamos a guardar los datos le\u00eddos del potenci\u00f3metro en una variable y mostrarlos a trav\u00e9s de la consola serie. La soluci\u00f3n la tenemos disponible en Actividad-07: Parte 1 que es el programa que vemos en la imagen siguiente: Parte 1 de la actividad 7 Si cargamos el programa en nuestra placa y posteriormente activamos la consola y conectamos ArduinoBlocks con nuestro ordenador podemos ver un resultado similar al de la imagen siguiente que se corresponde con variaciones de extremo a extremo del potenci\u00f3metro. Aspecto de la consola Para entender el significado del check \"salto de linea\" del bloque \"Enviar\" podemos desactivarlo y volver a hacer el mismo proceso. \u00a1MUY IMPORTANTE! cuando terminemos de manipular el potenci\u00f3metro que el mismo est\u00e9 totalmente girado a la posici\u00f3n izquierda (punto de color magenta), ya que comparte la conexi\u00f3n A0 (GPIO02) con el sistema de grabaci\u00f3n del programa. Si no est\u00e1 en esa posici\u00f3n se producir\u00e1 un error en el env\u00edo del programa. Parte 2 . Vamos a modificar el programa de la parte 1 del reto para mapear los datos antes de enviarlos a la consola serie. La soluci\u00f3n la tenemos disponible en Actividad-07: Parte 2 que es el programa que vemos en la imagen siguiente: Parte 2 de la actividad 7 El resultado ahora lo vemos en la imagen siguiente: Aspecto de la consola Ampliaci\u00f3n . Vamos ahora a mapear y mostrar los datos le\u00eddos del potenci\u00f3metro en el Serial Plotter. La soluci\u00f3n la tenemos disponible en Actividad-07: Ampliacion que es el programa que vemos en la imagen siguiente: Ampliaci\u00f3n de la actividad 7, serial plotter Si activamos el Serial Plotter y vamos variando el potenciometro veremos el resultado en el mismo, obteniendo algo similar a la imagen siguiente: Aspecto del Serial plotter Retos de ampliaci\u00f3n \u00b6 A7.R1 . Utilizaci\u00f3n del bloque \"crear texto con ...\" del men\u00fa \"Texto\". Utilizaremos cualquiera de los programas vistos en la actividad y configuraremos el nuevo bloque para que en cada l\u00ednea nos muestre el mensaje \"El valor del potenciometro es: \", a continuaci\u00f3n nos muestre el valor y tras el mismo el s\u00edmbolo % porque configuraremos la lectura en porcentaje. Dejaremos transcurrir un tiempo de 3s entre cada muestra de salida por consola. A7.R2 . Control del LED RGB con el potenciometro. Vamos a dividir el rango total en 8 partes y asignarle a cada una de ellas uno de los colores RGB seg\u00fan vemos en la tabla siguiente: Color Rango R G B Rojo 0 a 512 255 0 0 Verde 513 a 1023 0 255 0 Azul 1024 a 1536 0 0 255 Amarillo 1537 a 2048 255 255 0 Cian 2049 a 2560 0 255 255 Magenta 2561 a 3072 255 0 255 Blanco 3073 a 3584 255 255 255 Naranja 3584 a 4096 255 127 0 A7.R3 . Repetir el reto 2 de esta actividad pero ahora adem\u00e1s mostrando por consola el valor del potenciometro.","title":"Actividad-07. El potenci\u00f3metro"},{"location":"A07/#actividad-07-el-potenciometro","text":"","title":"Actividad-07. El potenci\u00f3metro"},{"location":"A07/#enunciado","text":"Introducir el uso de las entradas anal\u00f3gicas para visualizar los cambios que hagamos con el potenci\u00f3metro en el terminal serie o consola serie. Cuando hablamos de lecturas anal\u00f3gicas suele ser muy \u00fatil el uso del mapeo, concepto que tambi\u00e9n vamos a introducir y que veremos en la segunda parte del reto.","title":"Enunciado"},{"location":"A07/#teoria","text":"Antes de nada ya hemos indicado que el potenciometro va conectado a un pin anal\u00f3gico y es en este momento cuando vamos a establecer la diferencia entre los conceptos de anal\u00f3gico y de digital. Una clasificaci\u00f3n de los circuitos electr\u00f3nicos es dividirlos en dos grandes categor\u00edas: digitales y anal\u00f3gicos. La electr\u00f3nica digital utiliza magnitudes con dos valores discretos conocidos como 0 - 1, alto - bajo, on - off, etc, y que se corresponden con la presencia o no de tensi\u00f3n en un determinado punto. La electr\u00f3nica anal\u00f3gica emplea magnitudes con valores continuos. En concreto en las placas En la ESP32 Plus STEAMakers, las entradas anal\u00f3gicas pueden tener 2^12 valores (12 bits de resoluci\u00f3n = 4.096 valores), es decir, valores comprendidos entre 0 y 4.095. Estos valores se pueden expresar de forma num\u00e9rica o de forma porcentual, correspondiendo el 0 a un 0% y el 4.095 al 100%.","title":"Teor\u00eda"},{"location":"A07/#el-potenciometro","text":"En la imagen siguiente vemos el aspecto de un modelo concreto de potenci\u00f3metro as\u00ed como los s\u00edmbolos habituales del mismo. La numeraci\u00f3n indica lo siguiente: Terminales 1 y 3 son los contactos unidos a los extremos de la resistencia fija o resistencia total del potenci\u00f3metro. Terminal 2 es el contacto que va unido al cursor o parte m\u00f3vil que se desliza sobre la resistencia fija haciendo que la resistencia entre un terminal y el cursor var\u00ede en funci\u00f3n de la posici\u00f3n de este. Aspecto y s\u00edmbolo del potenci\u00f3metro La posici\u00f3n del cursor se determina de forma mec\u00e1nica y son adecuados para usarlos como elementos de control de tensi\u00f3n (conexi\u00f3n en serie) o de corriente (conexi\u00f3n en paralelo). Los potenci\u00f3metros del tipo que estamos viendo (existen de otros muchos tipos) tienen un funcionamiento en forma de rotaci\u00f3n con un \u00e1ngulo de unos 270 grados entre los puntos mas extremos.","title":"El potenci\u00f3metro"},{"location":"A07/#el-terminal-o-consola-serie","text":"Sirve para visualizar en un ordenador los datos recibidos a trav\u00e9s del puerto serie y en realidad es una aplicaci\u00f3n que controla las comunicaciones bidireccionales a trav\u00e9s de la UART integrada en el microcontrolador. Es muy importante tener siempre presente que el puerto serie es el que se utiliza para \"subir\" el firmware o programa a la placa, tarea que se realiza a trav\u00e9s de una aplicaci\u00f3n pregrabada en el microntrolador y que se denomina \"bootloader\". En ArduinoBlocks es posible usar la consola serie solamente si tenemos instalada y en funcionamiento la aplicaci\u00f3n ArduinoBlocks-Connector que es la encargada de establecer las comunicaciones locales de nuestra placa con las remotas de la aplicaci\u00f3n. En la imagen siguiente vemos el aspecto de la consola. Aspecto de la Consola en AB A la hora de establecer una conexi\u00f3n serie los dos extremos que intervienen en la conexi\u00f3n (placa ESP32 STEAMakers y ordenador) deben establecer el mismo valor en la velocidad de la conexi\u00f3n. Por defecto esta velocidad es de 115200 baudios o bits por segundo en el bloque inicializar y otras velocidades comunmente utilizadas son: 4800, 9600, 19200, 38400, 57600. Es por lo tanto imprescindible incluir en el bloque \"Inicializar\" el bloque \"Iniciar\" y establecer la velocidad de comunicaci\u00f3n.","title":"El terminal o consola serie"},{"location":"A07/#serial-plotter-datalogger","text":"Es otra funcionalidad relacionada con la comunicaci\u00f3n serie que nos permite visualizar informaci\u00f3n en forma de gr\u00e1fica en tiempo real. Adem\u00e1s el \u201cSerial Plotter\u201d implementa un sencillo datalogger con el que podemos ir grabando los datos para exportarlos posteriormente. En ArduinoBlocks existen bloques que nos permiten trabajar con el serial plotter. El serial plotter + datalogger se activa haciendo clic en la flecha a la derecha de Consola y tiene el aspecto que vemos en la imagen siguiente: Serial Plotter + Datalogger","title":"Serial Plotter - Datalogger"},{"location":"A07/#mapeo","text":"Hemos indicado que las entradas anal\u00f3gicas trabajan con 12 bits, o sea valores comprendidos entre 0 y 4095 (2^12) y tambi\u00e9n que las salidas digitales trabajan con 8 bits, o sea valores entre 0 y 255 (28), por lo que si queremos combinar en nuestro programa entradas anal\u00f3gicas con salidas digitales debemos realizar un ajuste de escala en los datos. A este ajuste se le conoce como \"mapear\" y es un bloque disponible en el men\u00fa Matem\u00e1ticas con el aspecto de la imagen siguiente: Bloque mapear","title":"Mapeo"},{"location":"A07/#en-la-tdr-steam","text":"El potenciometro de la TdR STEAM","title":"En la TdR STEAM"},{"location":"A07/#programando-la-actividad","text":"Parte 1 . Vamos a guardar los datos le\u00eddos del potenci\u00f3metro en una variable y mostrarlos a trav\u00e9s de la consola serie. La soluci\u00f3n la tenemos disponible en Actividad-07: Parte 1 que es el programa que vemos en la imagen siguiente: Parte 1 de la actividad 7 Si cargamos el programa en nuestra placa y posteriormente activamos la consola y conectamos ArduinoBlocks con nuestro ordenador podemos ver un resultado similar al de la imagen siguiente que se corresponde con variaciones de extremo a extremo del potenci\u00f3metro. Aspecto de la consola Para entender el significado del check \"salto de linea\" del bloque \"Enviar\" podemos desactivarlo y volver a hacer el mismo proceso. \u00a1MUY IMPORTANTE! cuando terminemos de manipular el potenci\u00f3metro que el mismo est\u00e9 totalmente girado a la posici\u00f3n izquierda (punto de color magenta), ya que comparte la conexi\u00f3n A0 (GPIO02) con el sistema de grabaci\u00f3n del programa. Si no est\u00e1 en esa posici\u00f3n se producir\u00e1 un error en el env\u00edo del programa. Parte 2 . Vamos a modificar el programa de la parte 1 del reto para mapear los datos antes de enviarlos a la consola serie. La soluci\u00f3n la tenemos disponible en Actividad-07: Parte 2 que es el programa que vemos en la imagen siguiente: Parte 2 de la actividad 7 El resultado ahora lo vemos en la imagen siguiente: Aspecto de la consola Ampliaci\u00f3n . Vamos ahora a mapear y mostrar los datos le\u00eddos del potenci\u00f3metro en el Serial Plotter. La soluci\u00f3n la tenemos disponible en Actividad-07: Ampliacion que es el programa que vemos en la imagen siguiente: Ampliaci\u00f3n de la actividad 7, serial plotter Si activamos el Serial Plotter y vamos variando el potenciometro veremos el resultado en el mismo, obteniendo algo similar a la imagen siguiente: Aspecto del Serial plotter","title":"Programando la actividad"},{"location":"A07/#retos-de-ampliacion","text":"A7.R1 . Utilizaci\u00f3n del bloque \"crear texto con ...\" del men\u00fa \"Texto\". Utilizaremos cualquiera de los programas vistos en la actividad y configuraremos el nuevo bloque para que en cada l\u00ednea nos muestre el mensaje \"El valor del potenciometro es: \", a continuaci\u00f3n nos muestre el valor y tras el mismo el s\u00edmbolo % porque configuraremos la lectura en porcentaje. Dejaremos transcurrir un tiempo de 3s entre cada muestra de salida por consola. A7.R2 . Control del LED RGB con el potenciometro. Vamos a dividir el rango total en 8 partes y asignarle a cada una de ellas uno de los colores RGB seg\u00fan vemos en la tabla siguiente: Color Rango R G B Rojo 0 a 512 255 0 0 Verde 513 a 1023 0 255 0 Azul 1024 a 1536 0 0 255 Amarillo 1537 a 2048 255 255 0 Cian 2049 a 2560 0 255 255 Magenta 2561 a 3072 255 0 255 Blanco 3073 a 3584 255 255 255 Naranja 3584 a 4096 255 127 0 A7.R3 . Repetir el reto 2 de esta actividad pero ahora adem\u00e1s mostrando por consola el valor del potenciometro.","title":"Retos de ampliaci\u00f3n"},{"location":"A08/","text":"Actividad-08. La fotorresistencia o LDR \u00b6 Enunciado \u00b6 Utilizaremos la consola serie para mostrar los valores de luz detectados por la resistencia LDR o fotoc\u00e9lula. Teor\u00eda \u00b6 Una fotorresistencia o fotorresistor es un componente electr\u00f3nico cuya resistencia disminuye de forma exponencial con el aumento de la intensidad de luz incidente. Las siglas LDR vienen de su nombre en ingl\u00e9s, que es Light Dependent Resistor. En la imagen siguiente tenemos el s\u00edmbolo, el aspecto real de una LDR y su curva caracter\u00edstica de variaci\u00f3n de resistencia con la iluminaci\u00f3n. S\u00edmbolo y aspecto de la LDR y curva caracter\u00edstica En la TdR STEAM \u00b6 La LDR en la TdR STEAM Programando la actividad \u00b6 Dado que en el men\u00fa TDR STEAM de ArduinoBlocks tenemos disponible un bloque que nos devuelve el nivel de luz en porcentaje o de forma num\u00e9rica, resolver la actividad es sumamente sencillo. La soluci\u00f3n la tenemos disponible en ESP32-SM-Actividad-08 que es el programa que vemos en la imagen siguiente: Actividad-08 Esto nos generar\u00e1 algo como lo de la imagen siguiente en la consola: Consola que produce la actividad 8 Retos de ampliaci\u00f3n \u00b6 A8.R1 . Detectar el nivel de iluminaci\u00f3n de la sala y condiciones de iluminaci\u00f3n en las que estemos utilizando la LDR y enviar el resultado a la consola. A8.R2 . Programar un interruptor crepuscular utilizando la LDR y uno de los LEDs para simular el farol. El nivel de luz m\u00ednimo permitido antes de encender el farol depender\u00e1 del resultado obtenido en la reto 1, de forma que con un valor menor o igual se encienda el LED y con un valor mayor permanezca apagado. A8.R3 . Hacer el interruptor crepuscular utilizando como farol en LED RGB que se encender\u00e1 en color blanco.","title":"Actividad-08. La fotorresistencia o LDR"},{"location":"A08/#actividad-08-la-fotorresistencia-o-ldr","text":"","title":"Actividad-08. La fotorresistencia o LDR"},{"location":"A08/#enunciado","text":"Utilizaremos la consola serie para mostrar los valores de luz detectados por la resistencia LDR o fotoc\u00e9lula.","title":"Enunciado"},{"location":"A08/#teoria","text":"Una fotorresistencia o fotorresistor es un componente electr\u00f3nico cuya resistencia disminuye de forma exponencial con el aumento de la intensidad de luz incidente. Las siglas LDR vienen de su nombre en ingl\u00e9s, que es Light Dependent Resistor. En la imagen siguiente tenemos el s\u00edmbolo, el aspecto real de una LDR y su curva caracter\u00edstica de variaci\u00f3n de resistencia con la iluminaci\u00f3n. S\u00edmbolo y aspecto de la LDR y curva caracter\u00edstica","title":"Teor\u00eda"},{"location":"A08/#en-la-tdr-steam","text":"La LDR en la TdR STEAM","title":"En la TdR STEAM"},{"location":"A08/#programando-la-actividad","text":"Dado que en el men\u00fa TDR STEAM de ArduinoBlocks tenemos disponible un bloque que nos devuelve el nivel de luz en porcentaje o de forma num\u00e9rica, resolver la actividad es sumamente sencillo. La soluci\u00f3n la tenemos disponible en ESP32-SM-Actividad-08 que es el programa que vemos en la imagen siguiente: Actividad-08 Esto nos generar\u00e1 algo como lo de la imagen siguiente en la consola: Consola que produce la actividad 8","title":"Programando la actividad"},{"location":"A08/#retos-de-ampliacion","text":"A8.R1 . Detectar el nivel de iluminaci\u00f3n de la sala y condiciones de iluminaci\u00f3n en las que estemos utilizando la LDR y enviar el resultado a la consola. A8.R2 . Programar un interruptor crepuscular utilizando la LDR y uno de los LEDs para simular el farol. El nivel de luz m\u00ednimo permitido antes de encender el farol depender\u00e1 del resultado obtenido en la reto 1, de forma que con un valor menor o igual se encienda el LED y con un valor mayor permanezca apagado. A8.R3 . Hacer el interruptor crepuscular utilizando como farol en LED RGB que se encender\u00e1 en color blanco.","title":"Retos de ampliaci\u00f3n"},{"location":"A09/","text":"Actividad-09. El sensor de temperatura LM35D \u00b6 Enunciado \u00b6 Utilizaremos este sensor de temperatura para medir la temperatura de la habitaci\u00f3n en la que estemos resolviendo el reto mostrando el resultado en la consola. Teor\u00eda \u00b6 LM35 \u00b6 El LM35 es un circuito integrado de medida de temperatura de precisi\u00f3n con una tensi\u00f3n de salida lineal y proporcional a la temperatura en grados cent\u00edgrados. Algunas de las caracter\u00edsticas que se pueden extraer de la hoja de datos del LM35 son: Directamente calibrado en grados Celsius (Cent\u00edgrados) Factor de escala lineal de +10-mV/\u00b0C Resoluci\u00f3n asegurada de 0.5\u00b0C Rango de medida de \u221255\u00b0C a 150\u00b0C En la imagen siguiente vemos su representaci\u00f3n en circuito y el aspecto f\u00edsico que tiene en uno de sus encapsulados mas usual. Representaci\u00f3n esquem\u00e1tica y aspecto Bloques de tiempo \u00b6 Para esta actividad vamos a explicar los bloques de tiempo que se implementan en ArduinoBlocks. Las funciones de tiempo o retardo nos permiten realizar pausas y obtener informaci\u00f3n sobre el tiempo transcurrido dentro del microcontrolador. 1.- Bloques esperar . Realizan una pausa del tiempo que establezcamos hasta seguir con la ejecuci\u00f3n del siguiente bloque. Se corresponden con las instrucciones delay(1000) y delayMicroseconds(1000). Tenemos disponibles los dos de la imagen siguiente: Bloques esperar 2.- Tiempo transcurrido . Obtiene un valor con el tiempo transcurrido desde el inicio o reset del microcontrolador de la placa ESP32 STEAMakers. Se trata de las funciones millis() y micros(). El valor puede ser en milisegundos o microsegundos, tal y como vemos en la imagen siguiente: Bloques tiempo transcurrido En la imagen siguiente tenemos un ejemplo de uso sacado del manual del programa : Ejecutar la Tarea1 cada 3 segundos y la Tarea2 cada 7 segundos sin bloquear la ejecuci\u00f3n del programa : Ejemplo de uso del bloque tiempo transcurrido 3.- Esperar por siempre . Bloquea indefinidamente la ejecuci\u00f3n finalizando por tanto el programa. Vemos el bloque en la imagen siguiente: Bloque esperar por siempre 4.- Ejecutar cada . Es un bloque que NO bloquea la ejecuci\u00f3n del programa y que implementa autom\u00e1ticamente la funci\u00f3n millis(). En la imagen siguiente vemos su aspecto: Bloque ejecutar cada El resto de bloque y la ampliaci\u00f3n de informaci\u00f3n la podemos consultar en el manual del programa . Funciones \u00b6 Una funci\u00f3n permite crear un grupo de bloques de c\u00f3digo que realizan una determinada tarea y que se repite a lo largo del programa principal en varias ocasiones. Con la creaci\u00f3n de una funci\u00f3n evitamos repetir todos esos bloques y simplemente tendremos que invocar a la funci\u00f3n. Es muy conveniente que los nombre que usemos sean lo mas descriptivos posibles de lo que hace la funci\u00f3n. Existen dos tipos de funciones: las que no retornan un valor y las que si lo hacen. En la imagen siguiente vemos los bloques correspondientes a las mismas: Bloques para crear funciones en ArduinoBlocks Cuando creamos funciones autom\u00e1ticamente se crea el bloque con su nombre que permite invocarla, tal y como vemos en la imagen siguiente: Bloques para llamada a funciones Tambi\u00e9n es posible crear funciones a las que se le env\u00edan datos o par\u00e1metros haciendo uso del signo + que aparece en los bloques. En la imagen siguiente vemos como le hemos a\u00f1adido un par de par\u00e1metros a cada tipo de funci\u00f3n y como se han modificado sus respectivos bloques de invocaci\u00f3n. Bloques para llamada a funciones con par\u00e1metros Un ejemplo t\u00edpico descriptivo del funcionamiento de las funciones es el de calculo del \u00e1rea de un tri\u00e1ngulo. Para ello definimos la funci\u00f3n que realiza el c\u00e1lculo, le pasamos dos par\u00e1metros, la base y la altura, realizamos los c\u00e1lculos pitag\u00f3ricos y nos devuelve el \u00e1rea del tri\u00e1ngulo para esos datos. En la imagen siguiente tenemos la idea de resoluci\u00f3n con la funci\u00f3n creada y el bloque para llamarla. Ejemplo de calculo del \u00e1rea de un tri\u00e1ngulo En las im\u00e1genes siguiente vemos como se han creado diferentes funciones y la forma de llamarlas. En concreto se corresponden con la base del programa de Educacont para configurar y grabar en la correspondiente estaci\u00f3n. La primera funci\u00f3n es \"leer sensores\" y la vemos en la imagen siguiente: Funci\u00f3n leer sensores de Educacont En la imagen siguiente podemos ver la funci\u00f3n encargada de subir los datos le\u00eddos a la nube. Funci\u00f3n subir datos a la nube de Educacont La siguiente funci\u00f3n permite detener las mediciones durante 15 minutos. Funci\u00f3n detener medici\u00f3n nn minutos de Educacont El bucle principal tiene la configuraci\u00f3n que vemos en la imagen siguiente: Llamada a las funciones definidas En la TdR STEAM \u00b6 El LM35 en la TdR STEAM Programando la actividad \u00b6 La programaci\u00f3n de la actividad es muy similar a la de las anteriores y el programa ESP32-SM-Actividad-09 es el que vemos en la imagen siguiente: Actividad-09 Esto nos generar\u00e1 algo como lo de la imagen siguiente en la consola: Consola que produce la actividad 9 Retos de ampliaci\u00f3n \u00b6 A9.R1 . Alarma \u00f3ptico/ac\u00fastica por sobrepasar una temperatura de 25\u00baC. Utilizaremos el zumbador para emitir alg\u00fan pitido y el LED rojo para la indicaci\u00f3n \u00f3ptica. A9.R2 . Sem\u00e1foro indicador de rangos de temperatura. Se trata de programar un sem\u00e1foro con un LED RGB que mostrar\u00e1 color verde si la temperatura est\u00e1 por debajo de 25\u00baC, rojo si est\u00e1 por encima de 35\u00baC y amarillo si est\u00e1 entre ambos valores.","title":"Actividad-09. El sensor de temperatura LM35D"},{"location":"A09/#actividad-09-el-sensor-de-temperatura-lm35d","text":"","title":"Actividad-09. El sensor de temperatura LM35D"},{"location":"A09/#enunciado","text":"Utilizaremos este sensor de temperatura para medir la temperatura de la habitaci\u00f3n en la que estemos resolviendo el reto mostrando el resultado en la consola.","title":"Enunciado"},{"location":"A09/#teoria","text":"","title":"Teor\u00eda"},{"location":"A09/#lm35","text":"El LM35 es un circuito integrado de medida de temperatura de precisi\u00f3n con una tensi\u00f3n de salida lineal y proporcional a la temperatura en grados cent\u00edgrados. Algunas de las caracter\u00edsticas que se pueden extraer de la hoja de datos del LM35 son: Directamente calibrado en grados Celsius (Cent\u00edgrados) Factor de escala lineal de +10-mV/\u00b0C Resoluci\u00f3n asegurada de 0.5\u00b0C Rango de medida de \u221255\u00b0C a 150\u00b0C En la imagen siguiente vemos su representaci\u00f3n en circuito y el aspecto f\u00edsico que tiene en uno de sus encapsulados mas usual. Representaci\u00f3n esquem\u00e1tica y aspecto","title":"LM35"},{"location":"A09/#bloques-de-tiempo","text":"Para esta actividad vamos a explicar los bloques de tiempo que se implementan en ArduinoBlocks. Las funciones de tiempo o retardo nos permiten realizar pausas y obtener informaci\u00f3n sobre el tiempo transcurrido dentro del microcontrolador. 1.- Bloques esperar . Realizan una pausa del tiempo que establezcamos hasta seguir con la ejecuci\u00f3n del siguiente bloque. Se corresponden con las instrucciones delay(1000) y delayMicroseconds(1000). Tenemos disponibles los dos de la imagen siguiente: Bloques esperar 2.- Tiempo transcurrido . Obtiene un valor con el tiempo transcurrido desde el inicio o reset del microcontrolador de la placa ESP32 STEAMakers. Se trata de las funciones millis() y micros(). El valor puede ser en milisegundos o microsegundos, tal y como vemos en la imagen siguiente: Bloques tiempo transcurrido En la imagen siguiente tenemos un ejemplo de uso sacado del manual del programa : Ejecutar la Tarea1 cada 3 segundos y la Tarea2 cada 7 segundos sin bloquear la ejecuci\u00f3n del programa : Ejemplo de uso del bloque tiempo transcurrido 3.- Esperar por siempre . Bloquea indefinidamente la ejecuci\u00f3n finalizando por tanto el programa. Vemos el bloque en la imagen siguiente: Bloque esperar por siempre 4.- Ejecutar cada . Es un bloque que NO bloquea la ejecuci\u00f3n del programa y que implementa autom\u00e1ticamente la funci\u00f3n millis(). En la imagen siguiente vemos su aspecto: Bloque ejecutar cada El resto de bloque y la ampliaci\u00f3n de informaci\u00f3n la podemos consultar en el manual del programa .","title":"Bloques de tiempo"},{"location":"A09/#funciones","text":"Una funci\u00f3n permite crear un grupo de bloques de c\u00f3digo que realizan una determinada tarea y que se repite a lo largo del programa principal en varias ocasiones. Con la creaci\u00f3n de una funci\u00f3n evitamos repetir todos esos bloques y simplemente tendremos que invocar a la funci\u00f3n. Es muy conveniente que los nombre que usemos sean lo mas descriptivos posibles de lo que hace la funci\u00f3n. Existen dos tipos de funciones: las que no retornan un valor y las que si lo hacen. En la imagen siguiente vemos los bloques correspondientes a las mismas: Bloques para crear funciones en ArduinoBlocks Cuando creamos funciones autom\u00e1ticamente se crea el bloque con su nombre que permite invocarla, tal y como vemos en la imagen siguiente: Bloques para llamada a funciones Tambi\u00e9n es posible crear funciones a las que se le env\u00edan datos o par\u00e1metros haciendo uso del signo + que aparece en los bloques. En la imagen siguiente vemos como le hemos a\u00f1adido un par de par\u00e1metros a cada tipo de funci\u00f3n y como se han modificado sus respectivos bloques de invocaci\u00f3n. Bloques para llamada a funciones con par\u00e1metros Un ejemplo t\u00edpico descriptivo del funcionamiento de las funciones es el de calculo del \u00e1rea de un tri\u00e1ngulo. Para ello definimos la funci\u00f3n que realiza el c\u00e1lculo, le pasamos dos par\u00e1metros, la base y la altura, realizamos los c\u00e1lculos pitag\u00f3ricos y nos devuelve el \u00e1rea del tri\u00e1ngulo para esos datos. En la imagen siguiente tenemos la idea de resoluci\u00f3n con la funci\u00f3n creada y el bloque para llamarla. Ejemplo de calculo del \u00e1rea de un tri\u00e1ngulo En las im\u00e1genes siguiente vemos como se han creado diferentes funciones y la forma de llamarlas. En concreto se corresponden con la base del programa de Educacont para configurar y grabar en la correspondiente estaci\u00f3n. La primera funci\u00f3n es \"leer sensores\" y la vemos en la imagen siguiente: Funci\u00f3n leer sensores de Educacont En la imagen siguiente podemos ver la funci\u00f3n encargada de subir los datos le\u00eddos a la nube. Funci\u00f3n subir datos a la nube de Educacont La siguiente funci\u00f3n permite detener las mediciones durante 15 minutos. Funci\u00f3n detener medici\u00f3n nn minutos de Educacont El bucle principal tiene la configuraci\u00f3n que vemos en la imagen siguiente: Llamada a las funciones definidas","title":"Funciones"},{"location":"A09/#en-la-tdr-steam","text":"El LM35 en la TdR STEAM","title":"En la TdR STEAM"},{"location":"A09/#programando-la-actividad","text":"La programaci\u00f3n de la actividad es muy similar a la de las anteriores y el programa ESP32-SM-Actividad-09 es el que vemos en la imagen siguiente: Actividad-09 Esto nos generar\u00e1 algo como lo de la imagen siguiente en la consola: Consola que produce la actividad 9","title":"Programando la actividad"},{"location":"A09/#retos-de-ampliacion","text":"A9.R1 . Alarma \u00f3ptico/ac\u00fastica por sobrepasar una temperatura de 25\u00baC. Utilizaremos el zumbador para emitir alg\u00fan pitido y el LED rojo para la indicaci\u00f3n \u00f3ptica. A9.R2 . Sem\u00e1foro indicador de rangos de temperatura. Se trata de programar un sem\u00e1foro con un LED RGB que mostrar\u00e1 color verde si la temperatura est\u00e1 por debajo de 25\u00baC, rojo si est\u00e1 por encima de 35\u00baC y amarillo si est\u00e1 entre ambos valores.","title":"Retos de ampliaci\u00f3n"},{"location":"A10/","text":"Actividad-10. El sensor de temperatura y humedad DHT-11 \u00b6 Enunciado \u00b6 Realizar un programa b\u00e1sico de medida de temperatura y humedad relativa de la habitaci\u00f3n en la que estamos trabajando con nuestra TdR STEAM. Teor\u00eda \u00b6 DHTxx \u00b6 El DHT11 es un modelo de sensor que permiten realizar la medici\u00f3n simult\u00e1nea de temperatura y humedad. Dispone de un procesador interno que es el encargado de realizar la medici\u00f3n entregando la informaci\u00f3n mediante una se\u00f1al digital. Se presenta en un encapsulado pl\u00e1stico t\u00edpico de color azul. Sus principales caracter\u00edsticas son: Rango de temperatura: 0 a 50\u00baC Precisi\u00f3n de la medida de temperatura: \u00b12\u00baC Rango de humedad: 20 a 80% Precisi\u00f3n en la medida de humedad: \u00b15%. Frecuencia de muestreo: 1 muestra por segundo (1 Hz) El DHT11 es un sensor bastante limitado que podemos usar con fines de formaci\u00f3n, pruebas, o en proyectos que realmente no requieran una medici\u00f3n precisa. Si necesitamos mayor precisi\u00f3n y rango podemos recurrir al DHT22 que es de la misma familia y lo \u00fanico que cambia es sus caracter\u00edsticas y el precio. Sus caracter\u00edsticas son: Rango de temperatura: -40 a 125\u00baC Precisi\u00f3n de la medida de temperatura: \u00b10.5\u00baC Rango de humedad: 0 a 100% Precisi\u00f3n en la medida de humedad: \u00b12 a 5% Frecuencia de muestreo: 2 muestras por segundo (2 Hz) En la imagen siguiente vemos el aspecto de ambos sensores: Aspecto DHT11 y DHT22 Estado de confort \u00b6 En la web ARQUITECTURA & ENERG\u00cdA podemos encontrar un art\u00edculo donde se nos explica con bastante profundad el tema del corfort t\u00e9rmico . Puede definirse confort t\u00e9rmico, o m\u00e1s propiamente comodidad higrot\u00e9rmica, como la ausencia de malestar t\u00e9rmico. En fisiolog\u00eda, se dice que hay confort higrot\u00e9rmico cuando no tienen que intervenir los mecanismos termorreguladores del cuerpo para una actividad sedentaria y con una indumentaria ligera. Esta situaci\u00f3n puede registrarse mediante \u00edndices que no deben ser sobrepasados para que no se pongan en funcionamiento los sistemas termorreguladores (metabolismo, sudoraci\u00f3n y otros). En la imagen siguiente vemos los valores de temperatura y humedad que delimitan las zonas de confortabilidad. Confort t\u00e9rmico en funci\u00f3n de temperatura y humedad Sobre el gr\u00e1fico vamos a delimitar zonas de temperatura y humedad para establecer su color. Por motivos de simplicidad lo vamos a hacer delimitando zonas rectangulares, pero comprobamos que no cometemos grandes errores y para nuestro prop\u00f3sito nos sirve. 1.- Zona Roja : en la imagen siguiente tenemos delimitadas las zonas: Humedad Relativa: superior al 85% e inferior al 20% Temperatura: superior a 27\u00baC e inferior a 16\u00baC Delimitaci\u00f3n color rojo zona de confort 2.- Zona Amarilla : en la imagen siguiente tenemos delimitadas las zonas: Humedad Relativa: entre el 20% y el 40% y entre el 65% y el 85% Temperatura: entre 16\u00baC y 18\u00baC y entre 24\u00baC y 27\u00baC Delimitaci\u00f3n color amarillo zona de confort 3.- Zona Verde, rojo y amarillo : en la imagen siguiente tenemos delimitadas todas las zonas, correspondiendo a la verde los siguientes datos: Humedad Relativa: entre el 40% y el 65% Temperatura: entre 18\u00baC y 24\u00baC Delimitaci\u00f3n colores zona de confort Con este enlace al archivo colores-A10.svg puedes descargarte el archivo vectorial, editarlo con Inkscape y ver como se han realizado estos gr\u00e1ficos. En la TdR STEAM \u00b6 El DHT11 en la TdR STEAM Programando la actividad \u00b6 De nuevo realizaremos la programaci\u00f3n como en las actividades anteriores, utilizando el monitor serie para mostrar los datos. El programa ESP32-SM-Actividad-10 lo vemos en la imagen siguiente: Actividad-10 Esto nos generar\u00e1 algo como lo de la imagen siguiente en la consola: Consola que produce la actividad 10 Retos de ampliaci\u00f3n \u00b6 A10.R1 . Realizar un programa que nos muestre el estado de confort seg\u00fan las explicaciones vista y la idea de un sem\u00e1foro que utilice el LED RGB para componer esos colores rojo, verde y amarillo. Para resolver la actividad vamos a necesitar varios bloques del men\u00fa \"L\u00f3gica\" y especialmente combinando funciones AND y OR m\u00faltiples. Si necesitamos, por ejemplo, aumentar el n\u00famero de operadores AND dentro de un bloque simplemente tenemos que combinarlo como vemos en la imagen siguiente, donde se han combinado cuatro bloques AND. Combinacion de 4 bloques AND El Programa es el de la imagen siguiente y est\u00e1 disponible en ESP32-SM-Reto-1-A10 . Reto 1 de la actividad 10 A10.R2 . Idear un m\u00e9todo para probar de forma completa la funcionalidad del programa anterior, aunque se requiera modificarlo. Tambi\u00e9n se pide explicar la misi\u00f3n de la funci\u00f3n \"limite-confort\" creada en el reto 1 de la actividad 10.","title":"Actividad-10. El sensor de temperatura y humedad DHT-11"},{"location":"A10/#actividad-10-el-sensor-de-temperatura-y-humedad-dht-11","text":"","title":"Actividad-10. El sensor de temperatura y humedad DHT-11"},{"location":"A10/#enunciado","text":"Realizar un programa b\u00e1sico de medida de temperatura y humedad relativa de la habitaci\u00f3n en la que estamos trabajando con nuestra TdR STEAM.","title":"Enunciado"},{"location":"A10/#teoria","text":"","title":"Teor\u00eda"},{"location":"A10/#dhtxx","text":"El DHT11 es un modelo de sensor que permiten realizar la medici\u00f3n simult\u00e1nea de temperatura y humedad. Dispone de un procesador interno que es el encargado de realizar la medici\u00f3n entregando la informaci\u00f3n mediante una se\u00f1al digital. Se presenta en un encapsulado pl\u00e1stico t\u00edpico de color azul. Sus principales caracter\u00edsticas son: Rango de temperatura: 0 a 50\u00baC Precisi\u00f3n de la medida de temperatura: \u00b12\u00baC Rango de humedad: 20 a 80% Precisi\u00f3n en la medida de humedad: \u00b15%. Frecuencia de muestreo: 1 muestra por segundo (1 Hz) El DHT11 es un sensor bastante limitado que podemos usar con fines de formaci\u00f3n, pruebas, o en proyectos que realmente no requieran una medici\u00f3n precisa. Si necesitamos mayor precisi\u00f3n y rango podemos recurrir al DHT22 que es de la misma familia y lo \u00fanico que cambia es sus caracter\u00edsticas y el precio. Sus caracter\u00edsticas son: Rango de temperatura: -40 a 125\u00baC Precisi\u00f3n de la medida de temperatura: \u00b10.5\u00baC Rango de humedad: 0 a 100% Precisi\u00f3n en la medida de humedad: \u00b12 a 5% Frecuencia de muestreo: 2 muestras por segundo (2 Hz) En la imagen siguiente vemos el aspecto de ambos sensores: Aspecto DHT11 y DHT22","title":"DHTxx"},{"location":"A10/#estado-de-confort","text":"En la web ARQUITECTURA & ENERG\u00cdA podemos encontrar un art\u00edculo donde se nos explica con bastante profundad el tema del corfort t\u00e9rmico . Puede definirse confort t\u00e9rmico, o m\u00e1s propiamente comodidad higrot\u00e9rmica, como la ausencia de malestar t\u00e9rmico. En fisiolog\u00eda, se dice que hay confort higrot\u00e9rmico cuando no tienen que intervenir los mecanismos termorreguladores del cuerpo para una actividad sedentaria y con una indumentaria ligera. Esta situaci\u00f3n puede registrarse mediante \u00edndices que no deben ser sobrepasados para que no se pongan en funcionamiento los sistemas termorreguladores (metabolismo, sudoraci\u00f3n y otros). En la imagen siguiente vemos los valores de temperatura y humedad que delimitan las zonas de confortabilidad. Confort t\u00e9rmico en funci\u00f3n de temperatura y humedad Sobre el gr\u00e1fico vamos a delimitar zonas de temperatura y humedad para establecer su color. Por motivos de simplicidad lo vamos a hacer delimitando zonas rectangulares, pero comprobamos que no cometemos grandes errores y para nuestro prop\u00f3sito nos sirve. 1.- Zona Roja : en la imagen siguiente tenemos delimitadas las zonas: Humedad Relativa: superior al 85% e inferior al 20% Temperatura: superior a 27\u00baC e inferior a 16\u00baC Delimitaci\u00f3n color rojo zona de confort 2.- Zona Amarilla : en la imagen siguiente tenemos delimitadas las zonas: Humedad Relativa: entre el 20% y el 40% y entre el 65% y el 85% Temperatura: entre 16\u00baC y 18\u00baC y entre 24\u00baC y 27\u00baC Delimitaci\u00f3n color amarillo zona de confort 3.- Zona Verde, rojo y amarillo : en la imagen siguiente tenemos delimitadas todas las zonas, correspondiendo a la verde los siguientes datos: Humedad Relativa: entre el 40% y el 65% Temperatura: entre 18\u00baC y 24\u00baC Delimitaci\u00f3n colores zona de confort Con este enlace al archivo colores-A10.svg puedes descargarte el archivo vectorial, editarlo con Inkscape y ver como se han realizado estos gr\u00e1ficos.","title":"Estado de confort"},{"location":"A10/#en-la-tdr-steam","text":"El DHT11 en la TdR STEAM","title":"En la TdR STEAM"},{"location":"A10/#programando-la-actividad","text":"De nuevo realizaremos la programaci\u00f3n como en las actividades anteriores, utilizando el monitor serie para mostrar los datos. El programa ESP32-SM-Actividad-10 lo vemos en la imagen siguiente: Actividad-10 Esto nos generar\u00e1 algo como lo de la imagen siguiente en la consola: Consola que produce la actividad 10","title":"Programando la actividad"},{"location":"A10/#retos-de-ampliacion","text":"A10.R1 . Realizar un programa que nos muestre el estado de confort seg\u00fan las explicaciones vista y la idea de un sem\u00e1foro que utilice el LED RGB para componer esos colores rojo, verde y amarillo. Para resolver la actividad vamos a necesitar varios bloques del men\u00fa \"L\u00f3gica\" y especialmente combinando funciones AND y OR m\u00faltiples. Si necesitamos, por ejemplo, aumentar el n\u00famero de operadores AND dentro de un bloque simplemente tenemos que combinarlo como vemos en la imagen siguiente, donde se han combinado cuatro bloques AND. Combinacion de 4 bloques AND El Programa es el de la imagen siguiente y est\u00e1 disponible en ESP32-SM-Reto-1-A10 . Reto 1 de la actividad 10 A10.R2 . Idear un m\u00e9todo para probar de forma completa la funcionalidad del programa anterior, aunque se requiera modificarlo. Tambi\u00e9n se pide explicar la misi\u00f3n de la funci\u00f3n \"limite-confort\" creada en el reto 1 de la actividad 10.","title":"Retos de ampliaci\u00f3n"},{"location":"A11/","text":"Actividad-11. Emisor y receptor de infrarrojos \u00b6 Enunciado \u00b6 Enviaremos c\u00f3digos desde el control remoto por infrarrojos que ser\u00e1n recibidos por el LED de infrarrojos para actuar seg\u00fan el c\u00f3digo recibido. Teor\u00eda \u00b6 \u00bfque son los infrarrojos? \u00b6 Son una clase de radiaci\u00f3n electromagn\u00e9tica con una longitud de onda que resulta superior a la longitud de onda de la luz visible, siendo su frecuencia superior a las microondas. Dentro del espectro electromagn\u00e9tico, la radiaci\u00f3n infrarroja se encuentra comprendida entre el espectro de luz visible y las microondas. Tiene longitudes de onda mayores o m\u00e1s largas que el rojo. En la imagen siguiente, obtenida del blog de Mercedes Gonz\u00e1lez Mas vemos caracterizados los infrarrojos dentro del espectro. Espectro electromagnetico Como podemos observar en la imagen, los rayos infrarrojos son clasificados, de acuerdo a su longitud de onda, del siguiente modo: infrarrojo cercano, con longitud de onda entre 0.7 \u00b5m y 1.1 \u00b5m, es la parte del espectro infrarrojo que ese encuentra m\u00e1s pr\u00f3ximo a la luz visible. infrarrojo medio, con longitud de onda entre 1,1 \u00b5m y 15 \u00b5m. infrarrojo lejano o regi\u00f3n m\u00e1s cercana a las microondas, con longitud de onda entre 15 \u00b5m y 100 \u00b5m En la imagen siguiente, obtenida de wikipedia , sobre espectro electromagn\u00e9tico podemos ver m\u00e1s informaci\u00f3n del tema. Espectro electromagnetico Todos los cuerpos emiten una cierta cantidad de radiaci\u00f3n, y aunque esta resulta invisible para el ojo humano, existen dispositivos electr\u00f3nicos capaces de \"verla\" por estar dise\u00f1ados para ello. Receptor de infrarrojos \u00b6 Uno de los receptores m\u00e1s universal utilizado en placas tipo Arduino es el receptor de infrarrojos universal TL1838, VS1838B o simplemente 1835 de 38KHz, que esel que lleva montado la placa TdR STEAM y cuyo aspecto podemos ver en la imagen siguiente: Diodo IR 1838 En el datasheet TL1838 del dispositivo tenemos toda la informaci\u00f3n sobre el mismo destacando las siguientes caracter\u00edsticas: Voltaje de funcionamiento: 2.7V a 5.5V Frecuencia: 37.9KHz \u00c1ngulo de recepci\u00f3n: 90\u00b0 Rango de recepci\u00f3n: 18m El dispositivo genera una se\u00f1al de salida que sirve para controles remotos universales y utiliza la codificaci\u00f3n NEC. El receptor de infrarrojos permite codificar los protocolos de se\u00f1ales de pulsos infrarrojos utilizados por los mandos a distancia. Los protocolos detectados son los siguientes: RC5, RC6, NEC, SONY, PANASONIC, JVC, SAMSUNG, WHYNTER, AIWA, LG, SANYO, MITSUBISHI y DENON. Es decir, detectar\u00eda cualquier se\u00f1al emitida por cualquiera de esos mandos. Emisor de infrarrojos \u00b6 En nuestro caso como emisor de infrarrojos vamos a utilizar el control remoto de Keyestudio que vemos en la imagen siguiente: Control remoto de Keyestudio El mini control remoto tiene 17 teclas de funci\u00f3n y tiene las siguientes especificaciones: Bater\u00eda: pilas de bot\u00f3n CR2025 Distancia de transmisi\u00f3n: hasta 8 m \u00c1ngulo efectivo: 60\u00b0 El control remoto, o mando a distancia, por IR funciona emitiendo trenes de pulsos de luz infrarroja. Diferentes se\u00f1ales corresponden a botones diferentes La se\u00f1al infrarroja transmite el c\u00f3digo correspondiente al bot\u00f3n del mando a distancia pulsado al dispositivo en forma de una serie de impulsos de luz infrarroja. El receptor recibe la serie de impulsos de infrarrojos y los pasa a un procesador que decodifica y activar\u00e1n una determinada funci\u00f3n del dispositivo. En el reto y las actividades del mismo obtendremos estos c\u00f3digos. En ArduinoBlocks se han asignado los siguientes nombres a las teclas: Nombre teclas control remoto en ArduinoBlocks Bloques en ArduinoBlocks \u00b6 El sensor receptor de infrarrojos permite obtener la cadena de texto con el c\u00f3digo en formato hexadecimal correspondiente al tren de pulsos de IR generado al pulsar una determinada tecla. El bloque es el que vemos en la imagen siguiente: En proyectos que no usen la TdR STEAM En proyectos con TdR STEAM El valor devuelto por el bloque de recepci\u00f3n ser\u00e1 una cadena de texto con valor vac\u00edo en caso de no detectar ning\u00fan c\u00f3digo. Al devolver el bloque una cadena de texto debemos recordar que lo tenemos que almacenar en una variable de tipo texto. Si utilizamos mandos gen\u00e9ricos RC5 como el modelo de Keyestudio, podemos usar el bloque de la imagen siguiente para comparar los c\u00f3digos recibidos y as\u00ed identificar f\u00e1cilmente cada tecla. En proyectos que no usen la TdR STEAM En proyectos con TdR STEAM En la TdR STEAM \u00b6 El sensor receptor de IR en la TdR STEAM Programando la actividad \u00b6 Vamos a realizar un programa en el que si pulsamos la tecla Ok del control remoto se nos encienda el diodo LED rojo. La soluci\u00f3n la tenemos disponible en ESP32-SM-Actividad-11 que es el programa que vemos en la imagen siguiente: Soluci\u00f3n Actividad 11 Sabemos que el diodo IR est\u00e1 recibiendo un c\u00f3digo porque junto al mismo hay un diodo LED rojo que parpadea. Retos de ampliaci\u00f3n \u00b6 A11.R1 . Realizar un programa que encienda el LED RGB en los colores establecidos a continuaci\u00f3n y seg\u00fan la tecla flecha pulsada. Flecha arriba = Rojo Flecha izquierda = Verde Flecha derecha = Amarillo Flecha abajo = azul A11.R2 . Realizar un programa que nos muestre por consola el c\u00f3digo hexadecimal correspondiente a cada una de las teclas pulsadas junto a un texto descriptivo indicador de la tecla pulsada en cada caso, es decir, que mantenga una estructura del tipo: El CODIGO se corresponde con la tecla TECLA pulsada.","title":"Actividad-11. Emisor y receptor de infrarrojos"},{"location":"A11/#actividad-11-emisor-y-receptor-de-infrarrojos","text":"","title":"Actividad-11. Emisor y receptor de infrarrojos"},{"location":"A11/#enunciado","text":"Enviaremos c\u00f3digos desde el control remoto por infrarrojos que ser\u00e1n recibidos por el LED de infrarrojos para actuar seg\u00fan el c\u00f3digo recibido.","title":"Enunciado"},{"location":"A11/#teoria","text":"","title":"Teor\u00eda"},{"location":"A11/#que-son-los-infrarrojos","text":"Son una clase de radiaci\u00f3n electromagn\u00e9tica con una longitud de onda que resulta superior a la longitud de onda de la luz visible, siendo su frecuencia superior a las microondas. Dentro del espectro electromagn\u00e9tico, la radiaci\u00f3n infrarroja se encuentra comprendida entre el espectro de luz visible y las microondas. Tiene longitudes de onda mayores o m\u00e1s largas que el rojo. En la imagen siguiente, obtenida del blog de Mercedes Gonz\u00e1lez Mas vemos caracterizados los infrarrojos dentro del espectro. Espectro electromagnetico Como podemos observar en la imagen, los rayos infrarrojos son clasificados, de acuerdo a su longitud de onda, del siguiente modo: infrarrojo cercano, con longitud de onda entre 0.7 \u00b5m y 1.1 \u00b5m, es la parte del espectro infrarrojo que ese encuentra m\u00e1s pr\u00f3ximo a la luz visible. infrarrojo medio, con longitud de onda entre 1,1 \u00b5m y 15 \u00b5m. infrarrojo lejano o regi\u00f3n m\u00e1s cercana a las microondas, con longitud de onda entre 15 \u00b5m y 100 \u00b5m En la imagen siguiente, obtenida de wikipedia , sobre espectro electromagn\u00e9tico podemos ver m\u00e1s informaci\u00f3n del tema. Espectro electromagnetico Todos los cuerpos emiten una cierta cantidad de radiaci\u00f3n, y aunque esta resulta invisible para el ojo humano, existen dispositivos electr\u00f3nicos capaces de \"verla\" por estar dise\u00f1ados para ello.","title":"\u00bfque son los infrarrojos?"},{"location":"A11/#receptor-de-infrarrojos","text":"Uno de los receptores m\u00e1s universal utilizado en placas tipo Arduino es el receptor de infrarrojos universal TL1838, VS1838B o simplemente 1835 de 38KHz, que esel que lleva montado la placa TdR STEAM y cuyo aspecto podemos ver en la imagen siguiente: Diodo IR 1838 En el datasheet TL1838 del dispositivo tenemos toda la informaci\u00f3n sobre el mismo destacando las siguientes caracter\u00edsticas: Voltaje de funcionamiento: 2.7V a 5.5V Frecuencia: 37.9KHz \u00c1ngulo de recepci\u00f3n: 90\u00b0 Rango de recepci\u00f3n: 18m El dispositivo genera una se\u00f1al de salida que sirve para controles remotos universales y utiliza la codificaci\u00f3n NEC. El receptor de infrarrojos permite codificar los protocolos de se\u00f1ales de pulsos infrarrojos utilizados por los mandos a distancia. Los protocolos detectados son los siguientes: RC5, RC6, NEC, SONY, PANASONIC, JVC, SAMSUNG, WHYNTER, AIWA, LG, SANYO, MITSUBISHI y DENON. Es decir, detectar\u00eda cualquier se\u00f1al emitida por cualquiera de esos mandos.","title":"Receptor de infrarrojos"},{"location":"A11/#emisor-de-infrarrojos","text":"En nuestro caso como emisor de infrarrojos vamos a utilizar el control remoto de Keyestudio que vemos en la imagen siguiente: Control remoto de Keyestudio El mini control remoto tiene 17 teclas de funci\u00f3n y tiene las siguientes especificaciones: Bater\u00eda: pilas de bot\u00f3n CR2025 Distancia de transmisi\u00f3n: hasta 8 m \u00c1ngulo efectivo: 60\u00b0 El control remoto, o mando a distancia, por IR funciona emitiendo trenes de pulsos de luz infrarroja. Diferentes se\u00f1ales corresponden a botones diferentes La se\u00f1al infrarroja transmite el c\u00f3digo correspondiente al bot\u00f3n del mando a distancia pulsado al dispositivo en forma de una serie de impulsos de luz infrarroja. El receptor recibe la serie de impulsos de infrarrojos y los pasa a un procesador que decodifica y activar\u00e1n una determinada funci\u00f3n del dispositivo. En el reto y las actividades del mismo obtendremos estos c\u00f3digos. En ArduinoBlocks se han asignado los siguientes nombres a las teclas: Nombre teclas control remoto en ArduinoBlocks","title":"Emisor de infrarrojos"},{"location":"A11/#bloques-en-arduinoblocks","text":"El sensor receptor de infrarrojos permite obtener la cadena de texto con el c\u00f3digo en formato hexadecimal correspondiente al tren de pulsos de IR generado al pulsar una determinada tecla. El bloque es el que vemos en la imagen siguiente: En proyectos que no usen la TdR STEAM En proyectos con TdR STEAM El valor devuelto por el bloque de recepci\u00f3n ser\u00e1 una cadena de texto con valor vac\u00edo en caso de no detectar ning\u00fan c\u00f3digo. Al devolver el bloque una cadena de texto debemos recordar que lo tenemos que almacenar en una variable de tipo texto. Si utilizamos mandos gen\u00e9ricos RC5 como el modelo de Keyestudio, podemos usar el bloque de la imagen siguiente para comparar los c\u00f3digos recibidos y as\u00ed identificar f\u00e1cilmente cada tecla. En proyectos que no usen la TdR STEAM En proyectos con TdR STEAM","title":"Bloques en ArduinoBlocks"},{"location":"A11/#en-la-tdr-steam","text":"El sensor receptor de IR en la TdR STEAM","title":"En la TdR STEAM"},{"location":"A11/#programando-la-actividad","text":"Vamos a realizar un programa en el que si pulsamos la tecla Ok del control remoto se nos encienda el diodo LED rojo. La soluci\u00f3n la tenemos disponible en ESP32-SM-Actividad-11 que es el programa que vemos en la imagen siguiente: Soluci\u00f3n Actividad 11 Sabemos que el diodo IR est\u00e1 recibiendo un c\u00f3digo porque junto al mismo hay un diodo LED rojo que parpadea.","title":"Programando la actividad"},{"location":"A11/#retos-de-ampliacion","text":"A11.R1 . Realizar un programa que encienda el LED RGB en los colores establecidos a continuaci\u00f3n y seg\u00fan la tecla flecha pulsada. Flecha arriba = Rojo Flecha izquierda = Verde Flecha derecha = Amarillo Flecha abajo = azul A11.R2 . Realizar un programa que nos muestre por consola el c\u00f3digo hexadecimal correspondiente a cada una de las teclas pulsadas junto a un texto descriptivo indicador de la tecla pulsada en cada caso, es decir, que mantenga una estructura del tipo: El CODIGO se corresponde con la tecla TECLA pulsada.","title":"Retos de ampliaci\u00f3n"},{"location":"IoT_basico/","text":"Teor\u00eda b\u00e1sica de IoT \u00b6 1.- \u00bfQu\u00e9 es la Internet de las Cosas? \u00b6 La expresi\u00f3n \u201cInternet de las cosas\u201d o IoT (del ingl\u00e9s, Internet of Things), internet de todas las cosas o internet en las cosas, hace referencia al uso que hacen de Internet los dispositivos conectados (las cosas) para comunicarse sin intervenci\u00f3n humana directa. Tambi\u00e9n se usa el t\u00e9rmino IoT para referirse al conjunto de estos dispositivos conectados comunicando \u201centre m\u00e1quinas\u201d (M2M) sin requerir interacci\u00f3n humana. No existe una Internet especial o diferente para \u201clas cosas\u201d, en principio, se opera con las mismas redes que en otros usos de Internet. En la imagen siguiente se grafica la conexi\u00f3n de elementos con la nube a trav\u00e9s de la red. Conexi\u00f3n de elementos IoT con la nube El IoT sirve para monitorizaci\u00f3n y control electr\u00f3nico y toma de decisiones inteligente. Es decir, conectar dispositivos a Internet permite enviar y recibir informaci\u00f3n usando una infraestructura global y as\u00ed poder monitorizar y/o controlar autom\u00e1ticamente y a distancia multitud de contextos. Por ejemplo, en entornos urbanos (ciudades inteligentes) se puede conocer la actividad humana, del medio ambiente, del tr\u00e1fico\u2026 tanto para informar de su estado (como las plazas de aparcamiento disponibles, la densidad o velocidad de la circulaci\u00f3n, la contaminaci\u00f3n\u2026) como para tomar decisiones de forma manual o autom\u00e1tica para optimizar los recursos disponibles (iluminaci\u00f3n, riego de jardines, funcionamiento de los sem\u00e1foros\u2026) Para conectar a la red las placas Arduino, sus clones o basadas en el mismo usaremos los m\u00f3dulos ESP8266. El ESP8266 es un chip de bajo costo Wi-Fi que contiene su propio microcontrolador, un Tensilica L106 de 32-bit. Es un chip de bajo bajo coste y reducido tama\u00f1o. El chip ESP8266 forma parte de multitud de m\u00f3dulos comerciales a trav\u00e9s de diferentes soluciones con distintas funciones, pines, tama\u00f1os y precios. Modelos ESP El m\u00e1s simple es el ESP-01, que solo dispone de 2 puertos digitales y necesita un adaptador USB para poder ser programado y es el que vamos a usar aqu\u00ed. Hay otros muchos sistemas como por ejemplo la placa ESP32 STEAMakers de Keyestudio, ESP-12E de ESP8266, la placa de desarrollo NodeMCU, tambi\u00e9n basada en el ESP-12E, Adem\u00e1s, hay placas con WiFi que usan otros chip WiFi diferentes, como la Arduino MKR1000. ESP32 STEAMakers ESP-12E NodeMCU de Keyestudio Arduino MKR1000 2.- M\u00f3dulo ESP8266 ESP-01 \u00b6 Introducci\u00f3n \u00b6 El m\u00f3dulo WiFi ESP-01 es uno de las m\u00e1s populares y econ\u00f3micos, pese a no ser el m\u00e1s potente ni vers\u00e1til. Actualmente, otros modelos como la ESP-12 o el el ESP32 se est\u00e1n integrando en la mayor\u00eda de placas de desarrollo, cobrando un peso e importancia mucho mayor. Sin embargo, nosotros vamos a asociar nuestro peque\u00f1o ESP-01 a una placa UNO, con el \u00fanico fin de darle conectividad WiFi. El ESP-01 trae instalado una versi\u00f3n de firmware con la que podemos comunicarnos con el ESP8266 mediante comandos AT (veremos a continuaci\u00f3n algunos de ellos) a trav\u00e9s del puerto serie. Este tipo de comunicaci\u00f3n nos va a permitir crear un puente entre la placa TdR STEAM y el ESP8266, consiguiendo as\u00ed conectar a una red WiFi y dar un primer paso de gigantes en el mundo IoT. Veamos el aspecto del ESP-01 y algunas de sus caracter\u00edsticas: Imagen ESP-01 Descripci\u00f3n - ESP8266 es el microcontrolador del m\u00f3dulo ESP-01. - La memoria flash es la BG25Q80A - Los LEDs informan de si est\u00e1 encendido o no y de la transmisi\u00f3n de datos (Tx y Rx). - La antena WiFi para la conexi\u00f3n a una internet. - Los pines permiten conectar alimentaci\u00f3n, sensores, \u2026 Toda la informaci\u00f3n en el datasheet del fabricante Los pines est\u00e1n distribuidos de la siguiente forma: Pines ESP-01 Descripci\u00f3n 1 - GND 2 - Pin digital n\u00famero 2 3 - Pin digital n\u00famero 0 4 - RXD es el pin por donde se van a recibir los datos del puerto serie. Trabaja a 3,3 V. Tambi\u00e9n puede ser el pin digital GPIO3 5 - TXD es el pin por donde se van a transmitir los datos del puerto serie. Trabaja a 3,3 V. Tambi\u00e9n puede ser el pin digital GPIO1 6 - CH_PD es el pin para apagar y encender el ESP-01: si lo ponemos a 0 V (LOW) se apaga, y a 3,3 V (HIGH) se enciende. 7 - RESET pin a 0V resetea el ESP-01 - Vcc es el pin de alimentaci\u00f3n. Funciona a 3,3V y admite un m\u00e1ximo de 3,6 V. La corriente suministrada debe ser mayor que 200 mA. GPIO (del ingl\u00e9s, General Purpose Input Output) son entradas o salidas de prop\u00f3sito general, o sea pines digitales. El ESP-01 soporta comunicaci\u00f3n I2C, por lo que, pese a tener solo un par de GPIOs, podemos conectarle multitud de sensores y actuadores a trav\u00e9s del mencionado bus de datos I2C. Programaci\u00f3n \u00b6 El ESP-01 dispone de un microcontrolador y una memoria donde poder almacenar programas, luego es un dispositivo programable en si mismo. Cargar programas en el dispositivo es algo mas complejo de lo que hemos visto hasta ahora dado que tiene dos modos de operaci\u00f3n, el modo flash o de ejecuci\u00f3n y el modo UART o de grabaci\u00f3n y debemos ser nosotros quienes activemos un modo u otro, cosa que hasta ahora el entorno ArduinoBlocks ha sido el encargado de hacerlo. Los modos de operaci\u00f3n se configuran a trav\u00e9s de los puertos GPIO0 y GPIO2. Para programar el ESP-01 hay que usar los pines Rx y Tx para transmitir los datos a la memoria Flash, donde se almacenar\u00e1 el sketch o programa. En las placas de control los pines Rx y Tx est\u00e1n en los pines D0 y D1 respectivamente y tambi\u00e9n son los que se utilizan para cargar programas a una velocidad de 115200 baudios, as\u00ed que si estos pines los ocupamos con el ESP8266 no podremos cargar programas en nuestra placa. Ahora bien, es posible utilizar otros pines para usar WiFi y evitar este problema, pero el resto de pines digitales solamente trabajan a 9600 baudios y el ESP-01 por defecto viene a 115200, luego para utilizarlo en pines distintos a los D0 y D1 de la placa tendremos que reprogramarlo para que la velocidad sea de 9600 baudios. Aunque sea bastante t\u00e9cnico debemos exponer c\u00f3mo configurar los dos modos de funcionamiento de forma breve. Modo de funcionamiento UART . Para cargar un programa en el ESP-01 debemos o bien encenderlo o bien resetearlo pero teniendo los siguientes estados de pines:GPIO0 = 0 (nivel bajo o LOW = 0 V). GPIO2 = 1 (nivel alto o HIGH = 3,3 V = Vcc). Recordemos siempre que el ESP8266 trabaja con niveles l\u00f3gicos de 3,3 V. El pin GPIO2 est\u00e1 por defecto a HIGH, ya que tiene un pull-up interno, por lo que podemos dejarlo simplemente desconectado. Modo de funcionamiento Flash . Para ejecutar un programa en el ESP-01 una vez cargado debemos tener la siguiente configuraci\u00f3n de pines: GPIO0 = 1 GPIO2 = 1 Tanto el GPIO0 como el GPIO2 est\u00e1n por defecto a HIGH, ya que ambos tienen un pull-up interno, por lo que podemos dejarlos simplemente desconectados. En este momento reflexionamos sobre el uso de Rx y Tx ya que si los estamos utilizando para cargar el programa en la placa y GPIO0 y GPIO2 para indicar el modo de trabajo \u00bfc\u00f3mo conectamos los sensores y actuadores al ESP-01?. Veamos: Rx y Tx los utilizamos para cargar el programa. Una vez finalizada la carga los podemos utilizar como pines de entrada y salida digitales. Los modos de trabajo se indican cuando se resetea o reinicia la placa. Una vez que tengamos el modo de ejecuci\u00f3n podemos conectar cualquier componente a estos pines. Los programas los podemos subir a nuestro ESP-01 mediante el IDE de Arduino o por medio de un convertidor USB-serie igual o similar al de la imagen siguiente: conversor USB-serial Se trata de un escudo o shield para el m\u00f3dulo WiFi ESP-01 que est\u00e1 provisto de un chip conversor de USB a puerto serie, en concActividad el CH340G. El proceso de reprogramaci\u00f3n con esta placa es bastante sencillo pero requiere de comando AT que pasamos a introducir antes de continuar. 3.- Comando AT en el ESP8266 \u00b6 El ESP-01 viene por defecto con el firmware AT ai-thinker V0.9.2.4. Los m\u00f3dems ven\u00edan con un conjunto de comandos que permiten que nos podamos comunicar con ellos para configurarlos y que lo podamos hacer a trav\u00e9s del puerto serie de ordenador al que est\u00e1n conectados. A estos comandos se les llama AT (de attention). Despu\u00e9s de cada comando AT, el ESP8266 espera los caracteres especiales de nueva linea para ejecutar el comando. El car\u00e1cter no imprimible CR (del ingl\u00e9s, Carriage Return) significa Actividadrno de carro y LF ( del ingl\u00e9s, Line Feed) es salto de l\u00ednea. El origen de la nomenclatura est\u00e1 en las m\u00e1quinas de escribir. En el enlace tenemos un pdf de la empresa Espressif Systems con el juego de comandos AT para el ESP8266. En la tabla siguiente damos un resumen de los comandos con una informaci\u00f3n ampliada de los que vamos a usar para la configuraci\u00f3n inicial que necesitamos. Unos comandos AT 4.- Preparaci\u00f3n del m\u00f3dulo ESP-01 \u00b6 Primero conectamos el m\u00f3dulo ESP8266 a la shield USB-serie y este a su vez a un puerto USB de nuestro ordenador. Nos aseguramos de que el interruptor est\u00e1 en modo Flash Boot. Entramos en ArduinoBlocks con ArduinoBlocks-Connector en funcionamiento, realizamos un refresco de la lectura del puerto para que detecte a la shield del m\u00f3dulo WiFi si es necesario, abrimos la consola, escogeremos la opci\u00f3n de 115200 en baudrate y tambi\u00e9n la de NL + LF (NL + LF es igual que CR + LF) para comunicarnos con el m\u00f3dulo WiFi. Hacemos clic en Conectar y conectamos la consola, escribimos \u201cAT\u201d en ella y clic en enviar. La situaci\u00f3n es la de la imagen siguiente: Comando AT en consola AB Si todo es correcto debe respondernos \u201cOK\u201d. Si responde algo sin sentido o no contesta, significa que est\u00e1 configurado en alguna otra velocidad. En este segundo caso deberemos cambiar la opci\u00f3n de baudrate y repetir la operaci\u00f3n con diferentes velocidades hasta que nos responda \u201cOK\u201d. La situaci\u00f3n correcta en la consola de comandos es la siguiente: Respuesta al comando AT Una vez que nos responda \u201cOK\u201d, le enviamos el texto \u201cAT+UART_DEF=9600,8,1,0,0\u201d y nos debe responder otra vez \u201cOK\u201d. Comando AT para establecer velocidad a 9600 baudios Con esto hemos cambiado la velocidad a 9600 baudios mediante el comando AT+UART_DEF que nos permite cambiar la definici\u00f3n a 9600 baudios, con 8 bits de datos, 1 bit de parada, sin paridad y sin habilitar el control de flujo. Una vez que hemos configurado el m\u00f3dulo WiFi a la velocidad que nos interesa debemos crear un canal en un servidor MQTT donde enviar los datos y visualizarlos. Esto lo vamos a hacer a trav\u00e9s de la web de Thingspeak , pero antes de nada vamos a describir que es MQTT. Para saber mas acerca de la reprogramaci\u00f3n de la velocidad de comunicaci\u00f3n con ESP8266 visita el enlace: Reprogramar la velocidad de comunicaci\u00f3n del ESP8266 . 5.- Una introducci\u00f3n al IoT a trav\u00e9s de MQTT \u00b6 Si queremos trabajar en tareas de IoT debemos de utilizar alg\u00fan protocolo de comunicaci\u00f3n y hoy por hoy el principal es MQTT, pero antes de citar protocolos vamos a tratar algunos conceptos necesarios. Un protocolo de comunicaci\u00f3n no es otra cosa que una serie de normas definidas para que dos o m\u00e1s dispositivos puedan comunicarse entre si de forma comprensible para ambos. Requisitos del IoT Estamos bastante acostumbrados a realizar un tipo de comunicaci\u00f3n denominada M2M (machine-to-machine) utilizando internet, pero cuando trabajamos en IoT debemos establecer una serie de requisitos que hacen que la comunicaci\u00f3n M2M no sea la mas adecuada. Algunos de estos requisitos son: Cantidad: se puede llegar a tener un gran n\u00famero de dispositivos diferentes, desde sensores, actuadores, servidores, etc. Escalabilidad: los sistemas deben permitir a\u00f1adir o eliminar dispositivos sin que el sistema global resulte afectado. Variedad: normalmente necesitaremos que el sistema funcione con diferentes sistemas operativos, lenguajes de programaci\u00f3n y el mayor n\u00famero posible de dispositivos. Simultaneidad: gran cantidad de comunicaciones simultaneas, lo que requiere respuestas r\u00e1pidas para lo que es necesario que los mensajes transmitidos sean lo mas cortos posibles. Seguridad: internet no es un sitio muy seguro y estos dispositivos van a estar conectados a internet controlando dispositivos f\u00edsicos. Accesibilidad: tendremos que trabajar en condiciones muy variadas en lo que se refiere a ancho de banda, firewall, direccionamiento,\u2026 La soluci\u00f3n mas com\u00fan consiste en disponer un servidor denominado \u2018broker\u2019, o a veces \u2018Router\u2019, que ser\u00e1 el que reciba los mensajes de los dispositivos emisores y los distribuir\u00e1 a los receptores. Broker El broker va a tener una direcci\u00f3n IP fija y ser\u00e1 accesible para todos los dispositivos, puede mantener un registro de los dispositivos conectados, recibir y distribuir mensajes y establecer filtros de destinatarios. Esto permite algo fundamental, y es que cada dispositivo no dependa del resto de dispositivos. Veamos algunos conceptos que nos permitan entender las infraestructuras de los servicios IoT: Message Queue o cola de mensajes. En este tipo el broker genera una cola de mensajes \u00fanica para cada uno de los clientes que inician la suscripci\u00f3n. Message Service o servicio de mensajer\u00eda. En este tipo el broker distribuye inmediatamente los mensajes filtrados por alg\u00fan criterio a los clientes conectados. A diferencia de Message Queue, los mensajes entregados mientras el cliente est\u00e1 desconectado se pierden. Publish/Susbcribe (PubSub). Se trata de un sistema de mensajer\u00eda donde el 'Subscriber' informa al broker de que quiere recibir un tipo de mensajes y el 'Publisher' entonces puede publicarlos. Router Remoder Procedure Calls (RRPC). Se trata de la ejecuci\u00f3n remota de procedimientos donde 'Callee' comunica al broker que proporciona un procedimiento y el 'Caller', puede llamar a este procedimiento. Algunos de los protocolos para IoT son: MQTT (del ingl\u00e9s Message Queuing Telemetry Transport) es un protocolo PubSub de servicio de mensajer\u00eda que act\u00faa sobre TCP. Es ligero y f\u00e1cil de implementar resultando apropiado para dispositivos de baja potencia, tan habituales en IoT. TCP es un protocolo de control de transmisi\u00f3n (del ingl\u00e9s, Transmission Control Protocol) fundamental en Internet. AMQP (Advanced Message Queuing Protocol) es un protocolo PubSub de cola de mensajes que asegura la confiabilidad e interoperabilidad necesaria en aplicaciones corporativas. STOMP (Streaming Text Oriented Messaging Protocol). Es un protocolo sencillo que emplea HTTP y mensajes de texto. XMPP (Extensible Messaging and Presence Protocol). Es un protocolo abierto basado en XML dise\u00f1ado para aplicaciones de mensajer\u00eda instant\u00e1nea. WAMP (Web Application Messaging Protocol). Es un protocolo abierto que se ejecuta sobre WebSockets, y provee tanto aplicaciones de PubSub como RRPC. CoAP (Constrained Application Protocol) es un protocolo pensado para emplearse en dispositivos de IoT de baja capacidad. MQTT Dentro de una arquitectura de MQTT, es muy importante el concepto topic (tema en espa\u00f1ol) ya que la comunicaci\u00f3n se realiza a trav\u00e9s de topics debiendo estar los emisores y receptores subscritos a un topic com\u00fan para poder establecer la comunicaci\u00f3n. Este tipo de arquitectura permite que la comunicaci\u00f3n pueda ser de uno a uno o de uno a muchos. Los topics tienen estructura jer\u00e1rquica pudiendo establecer relaciones padre-hijo de manera que cuando nos suscribimos a un topic padre podemos recibir tambi\u00e9n la informaci\u00f3n de sus hijos. En un ejemplo lo podemos ver m\u00e1s claramente. Estructura jerarquica de un topic Un topic se representa mediante una cadena con las jerarquias separadas por /. Por ejemplo: Vivienda/Planta baja/Cocina/Arduino/Luz Vivienda/Planta alta/Dorm.1/Arduino/Temperatura. De esta forma podemos suscribirnos a un topic concActividad o a varios, por ejemplo: Un topic: Vivienda/Planta baja/Cocina/Arduino/Luz Varios topics: Vivienda/Planta baja/# Existen b\u00e1sicamente tres tipos de brokers, los privados, los p\u00fablicos y los locales. A continuaci\u00f3n citamos alguno de los m\u00e1s utilizados: a .- Private MQTT Broker: solamente los dispositivos que establezcamos pueden publicar o suscribirse a un topic. Se utiliza en producci\u00f3n y prototipado. Algunos de ellos son: Azure de Microsoft. AWS de Amazon. CloudMQTT disponible en: https://www.cloudmqtt.com/plans.html . ThingSpeak de Mathworks (MATLAB). b .- Public MQTT Broker: cualquier dispositivo puede publicar y suscribirse a topics. Algunos de ellos son: Eclipse Mosquitto HiveMQ: Enlace - Direcci\u00f3n del broker Flespi Dioty Fluux Thingspeak Si queremos instalar nuestro propio broker en una raspberry o PC, sin duda Mosquito es la opci\u00f3n m\u00e1s extendida. 6.- Creaci\u00f3n de un canal en un servidor MQTT \u00b6 En nuestro caso vamos a utilizar Thingspeak en su versi\u00f3n p\u00fablica. Lo primero que debemos hacer es crear una cuenta, para lo que clicamos en Sign Up. Seguidamente, introducimos un correo electr\u00f3nico v\u00e1lido y el resto de datos que nos pide. Lo vemos en la imagen siguiente: Pagina inicial de Thingspeaks Debemos aceptar que use la direcci\u00f3n de correo electr\u00f3nico para nuestra cuenta de MathWorks, como se ve en la imagen siguiente: Aceptaci\u00f3n a Mathwork Tras esto recibiremos un correo en la direcci\u00f3n que hemos dado para confirmar la creaci\u00f3n de la cuenta y confirmarla. Debemos ver algo similar a la imagen siguiente: Confirmacion aceptaci\u00f3n cuenta correo Una vez confirmada la direcci\u00f3n de correo electr\u00f3nico, volvemos a la p\u00e1gina donde est\u00e1bamos y hacemos click en continuar. Nos pedir\u00e1 un nombre de usuario y una contrase\u00f1a que usaremos a partir de ahora para iniciar sesi\u00f3n. Finalizada la creaci\u00f3n de la cuenta iniciamos sesi\u00f3n desde la p\u00e1gina principal haciendo clic en \u201cSign In\u201d. Veremos una ventana como la de la imagen siguiente: Ventana para identificaci\u00f3n en Thingspeaks Escribimos nuestra contrase\u00f1a y hacemos clic en el bot\u00f3n Sign in. Acceso a Thingspeaks Con esto entramos en el broker y est\u00e1 todo listo para iniciar el trabajo. Acceso correcto al broker Podemos aprender mas sobre el tema visitando los siguientes enlaces: Primeros pasos con Wifi: Servidor sin clave y contrase\u00f1a Wifi con servidor gratuito con clave y contrase\u00f1a y app m\u00f3vil C\u00f3mo publicar y almacenar datos por Wifi en Internet con Thingspeak 7.- Filtrado por MAC \u00b6 Si por cualquier motivo nuestra red WiFi tiene filtrado MAC debemos de dar de alta en la misma de nuestro dispositivo ESP-01. Esta es una tarea que va a depender de nuestro router y suministrador y que no resulta especialmente complicada. Lo primero que debemos hacer es averiguar la direcci\u00f3n MAC de nuestro dispositivo ESP8266. Esta tarea no la vamos a hacer desde ArduinoBlocks sino que vamos a recurrir al IDE de Arduino. Si necesitas ayuda para este tema seguro que la encuentras en estos tutoriales de Luis Llamas , o tambi\u00e9n puedes buscar informaci\u00f3n en tu navegador pues existen multitud de p\u00e1ginas referentes al tema de programaci\u00f3n desde el IDE de Arduino. Los elementos que vamos a utilizar para conectar nuestro m\u00f3dulo ESP-01 a la placa TdR STEAM los vemos en la imagen siguiente: Shield WiFi serial M\u00f3dulo ESP-01 Conector de comunicaciones en la TdR STEAM Cables tipo Dupont M-H Conexionado Nos encontramos con el problema de que el orden de pines en el conector de la TdR STEAM (RX-TX-GND-VCC) no coinicede con el de la Shield WiFi serial (RX-TX-VCC-GND) por lo que no lo vamos a poder \"pinchar\" directamente en el conector y debemos utilizar cables tipo Dupont. Debemos tener muy presente que la placa TdR STEAM ya realiza una conexi\u00f3n cruzada entre los pines Tx y Rx , es decir: Rx de la TdR STEAM va conectada a Tx de la placa UNO Tx de la TdR STEAM va conectada a Rx de la placa UNO En la imagen siguiente vemos gr\u00e1ficamente como debemos hacer el conexionado al que nos estamos refiriendo. Conexi\u00f3n NO CRUZADA TdR - Shield Para nuestro prop\u00f3sito de comunicar el ordenador con el ESP-01 a trav\u00e9s del IDE y averiguar la MAC de nuestro dispositivo creo que lo mas conveniente y claro es realizar el montaje que vemos en la imagen siguiente: Conexi\u00f3n cruzada UNO a Shield wifi En este caso si es totalmente imprescindible realizar la conexi\u00f3n cruzada mostrada en la imagen entre Tx y Rx. Comunicaci\u00f3n entre PC y ESP01 Con la conexi\u00f3n cruzada descrita y un sketch vac\u00edo en el IDE que subimos a la placa UNO, conectamos el UNO al ordenador y establecemos la configuraci\u00f3n de nuestra placa UNO y el puerto USB al que estamos conectados. Lo que en realidad hacemos es usar la placa UNO como un convertidor bidireccional USB a RS232 que nos permite comunicar el ordenador con la placa ESP8266 ESP01. Abrimos el monitor serie desde el IDE de Arduino y lo configuramos como vemos en la imagen siguiente: Configuraci\u00f3n del monitor serie Escribimos AT y pulsamos Enter o hacemos clic en Enviar y el m\u00f3dulo deber\u00e1 responder OK si todo es correcto. Si la velocidad por defecto del m\u00f3dulo no es de 115200 no responder\u00e1 y posiblemente se vean caracteres extra\u00f1os en el monitor serie. En este caso habr\u00e1 que probar distintas velocidades hasta conseguir que el m\u00f3dulo responda OK al comando AT. El resultado correcto lo vemos en la imagen siguiente: Comando AT OK Direcci\u00f3n MAC El \u00faltimo paso es teclear el comando AT para conseguir la direcci\u00f3n f\u00edsica o MAC del dispositivo conectado. Este comando es AT+CIFSR y es que el que vemos en la imagen siguiente: Comando AT para obtener la MAC El comando AT+CIFSR nos devuelve un resultado similar al que vemos en la imagen siguiente: MAC obtenida Ya podemos dar de alta la MAC del dispositivo en nuestro filtrado MAC y poder as\u00ed comunicarnos a trav\u00e9s de WiFi.","title":"Teor\u00eda b\u00e1sica de IoT"},{"location":"IoT_basico/#teoria-basica-de-iot","text":"","title":"Teor\u00eda b\u00e1sica de IoT"},{"location":"IoT_basico/#1-que-es-la-internet-de-las-cosas","text":"La expresi\u00f3n \u201cInternet de las cosas\u201d o IoT (del ingl\u00e9s, Internet of Things), internet de todas las cosas o internet en las cosas, hace referencia al uso que hacen de Internet los dispositivos conectados (las cosas) para comunicarse sin intervenci\u00f3n humana directa. Tambi\u00e9n se usa el t\u00e9rmino IoT para referirse al conjunto de estos dispositivos conectados comunicando \u201centre m\u00e1quinas\u201d (M2M) sin requerir interacci\u00f3n humana. No existe una Internet especial o diferente para \u201clas cosas\u201d, en principio, se opera con las mismas redes que en otros usos de Internet. En la imagen siguiente se grafica la conexi\u00f3n de elementos con la nube a trav\u00e9s de la red. Conexi\u00f3n de elementos IoT con la nube El IoT sirve para monitorizaci\u00f3n y control electr\u00f3nico y toma de decisiones inteligente. Es decir, conectar dispositivos a Internet permite enviar y recibir informaci\u00f3n usando una infraestructura global y as\u00ed poder monitorizar y/o controlar autom\u00e1ticamente y a distancia multitud de contextos. Por ejemplo, en entornos urbanos (ciudades inteligentes) se puede conocer la actividad humana, del medio ambiente, del tr\u00e1fico\u2026 tanto para informar de su estado (como las plazas de aparcamiento disponibles, la densidad o velocidad de la circulaci\u00f3n, la contaminaci\u00f3n\u2026) como para tomar decisiones de forma manual o autom\u00e1tica para optimizar los recursos disponibles (iluminaci\u00f3n, riego de jardines, funcionamiento de los sem\u00e1foros\u2026) Para conectar a la red las placas Arduino, sus clones o basadas en el mismo usaremos los m\u00f3dulos ESP8266. El ESP8266 es un chip de bajo costo Wi-Fi que contiene su propio microcontrolador, un Tensilica L106 de 32-bit. Es un chip de bajo bajo coste y reducido tama\u00f1o. El chip ESP8266 forma parte de multitud de m\u00f3dulos comerciales a trav\u00e9s de diferentes soluciones con distintas funciones, pines, tama\u00f1os y precios. Modelos ESP El m\u00e1s simple es el ESP-01, que solo dispone de 2 puertos digitales y necesita un adaptador USB para poder ser programado y es el que vamos a usar aqu\u00ed. Hay otros muchos sistemas como por ejemplo la placa ESP32 STEAMakers de Keyestudio, ESP-12E de ESP8266, la placa de desarrollo NodeMCU, tambi\u00e9n basada en el ESP-12E, Adem\u00e1s, hay placas con WiFi que usan otros chip WiFi diferentes, como la Arduino MKR1000. ESP32 STEAMakers ESP-12E NodeMCU de Keyestudio Arduino MKR1000","title":"1.- \u00bfQu\u00e9 es la Internet de las Cosas?"},{"location":"IoT_basico/#2-modulo-esp8266-esp-01","text":"","title":"2.- M\u00f3dulo ESP8266 ESP-01"},{"location":"IoT_basico/#introduccion","text":"El m\u00f3dulo WiFi ESP-01 es uno de las m\u00e1s populares y econ\u00f3micos, pese a no ser el m\u00e1s potente ni vers\u00e1til. Actualmente, otros modelos como la ESP-12 o el el ESP32 se est\u00e1n integrando en la mayor\u00eda de placas de desarrollo, cobrando un peso e importancia mucho mayor. Sin embargo, nosotros vamos a asociar nuestro peque\u00f1o ESP-01 a una placa UNO, con el \u00fanico fin de darle conectividad WiFi. El ESP-01 trae instalado una versi\u00f3n de firmware con la que podemos comunicarnos con el ESP8266 mediante comandos AT (veremos a continuaci\u00f3n algunos de ellos) a trav\u00e9s del puerto serie. Este tipo de comunicaci\u00f3n nos va a permitir crear un puente entre la placa TdR STEAM y el ESP8266, consiguiendo as\u00ed conectar a una red WiFi y dar un primer paso de gigantes en el mundo IoT. Veamos el aspecto del ESP-01 y algunas de sus caracter\u00edsticas: Imagen ESP-01 Descripci\u00f3n - ESP8266 es el microcontrolador del m\u00f3dulo ESP-01. - La memoria flash es la BG25Q80A - Los LEDs informan de si est\u00e1 encendido o no y de la transmisi\u00f3n de datos (Tx y Rx). - La antena WiFi para la conexi\u00f3n a una internet. - Los pines permiten conectar alimentaci\u00f3n, sensores, \u2026 Toda la informaci\u00f3n en el datasheet del fabricante Los pines est\u00e1n distribuidos de la siguiente forma: Pines ESP-01 Descripci\u00f3n 1 - GND 2 - Pin digital n\u00famero 2 3 - Pin digital n\u00famero 0 4 - RXD es el pin por donde se van a recibir los datos del puerto serie. Trabaja a 3,3 V. Tambi\u00e9n puede ser el pin digital GPIO3 5 - TXD es el pin por donde se van a transmitir los datos del puerto serie. Trabaja a 3,3 V. Tambi\u00e9n puede ser el pin digital GPIO1 6 - CH_PD es el pin para apagar y encender el ESP-01: si lo ponemos a 0 V (LOW) se apaga, y a 3,3 V (HIGH) se enciende. 7 - RESET pin a 0V resetea el ESP-01 - Vcc es el pin de alimentaci\u00f3n. Funciona a 3,3V y admite un m\u00e1ximo de 3,6 V. La corriente suministrada debe ser mayor que 200 mA. GPIO (del ingl\u00e9s, General Purpose Input Output) son entradas o salidas de prop\u00f3sito general, o sea pines digitales. El ESP-01 soporta comunicaci\u00f3n I2C, por lo que, pese a tener solo un par de GPIOs, podemos conectarle multitud de sensores y actuadores a trav\u00e9s del mencionado bus de datos I2C.","title":"Introducci\u00f3n"},{"location":"IoT_basico/#programacion","text":"El ESP-01 dispone de un microcontrolador y una memoria donde poder almacenar programas, luego es un dispositivo programable en si mismo. Cargar programas en el dispositivo es algo mas complejo de lo que hemos visto hasta ahora dado que tiene dos modos de operaci\u00f3n, el modo flash o de ejecuci\u00f3n y el modo UART o de grabaci\u00f3n y debemos ser nosotros quienes activemos un modo u otro, cosa que hasta ahora el entorno ArduinoBlocks ha sido el encargado de hacerlo. Los modos de operaci\u00f3n se configuran a trav\u00e9s de los puertos GPIO0 y GPIO2. Para programar el ESP-01 hay que usar los pines Rx y Tx para transmitir los datos a la memoria Flash, donde se almacenar\u00e1 el sketch o programa. En las placas de control los pines Rx y Tx est\u00e1n en los pines D0 y D1 respectivamente y tambi\u00e9n son los que se utilizan para cargar programas a una velocidad de 115200 baudios, as\u00ed que si estos pines los ocupamos con el ESP8266 no podremos cargar programas en nuestra placa. Ahora bien, es posible utilizar otros pines para usar WiFi y evitar este problema, pero el resto de pines digitales solamente trabajan a 9600 baudios y el ESP-01 por defecto viene a 115200, luego para utilizarlo en pines distintos a los D0 y D1 de la placa tendremos que reprogramarlo para que la velocidad sea de 9600 baudios. Aunque sea bastante t\u00e9cnico debemos exponer c\u00f3mo configurar los dos modos de funcionamiento de forma breve. Modo de funcionamiento UART . Para cargar un programa en el ESP-01 debemos o bien encenderlo o bien resetearlo pero teniendo los siguientes estados de pines:GPIO0 = 0 (nivel bajo o LOW = 0 V). GPIO2 = 1 (nivel alto o HIGH = 3,3 V = Vcc). Recordemos siempre que el ESP8266 trabaja con niveles l\u00f3gicos de 3,3 V. El pin GPIO2 est\u00e1 por defecto a HIGH, ya que tiene un pull-up interno, por lo que podemos dejarlo simplemente desconectado. Modo de funcionamiento Flash . Para ejecutar un programa en el ESP-01 una vez cargado debemos tener la siguiente configuraci\u00f3n de pines: GPIO0 = 1 GPIO2 = 1 Tanto el GPIO0 como el GPIO2 est\u00e1n por defecto a HIGH, ya que ambos tienen un pull-up interno, por lo que podemos dejarlos simplemente desconectados. En este momento reflexionamos sobre el uso de Rx y Tx ya que si los estamos utilizando para cargar el programa en la placa y GPIO0 y GPIO2 para indicar el modo de trabajo \u00bfc\u00f3mo conectamos los sensores y actuadores al ESP-01?. Veamos: Rx y Tx los utilizamos para cargar el programa. Una vez finalizada la carga los podemos utilizar como pines de entrada y salida digitales. Los modos de trabajo se indican cuando se resetea o reinicia la placa. Una vez que tengamos el modo de ejecuci\u00f3n podemos conectar cualquier componente a estos pines. Los programas los podemos subir a nuestro ESP-01 mediante el IDE de Arduino o por medio de un convertidor USB-serie igual o similar al de la imagen siguiente: conversor USB-serial Se trata de un escudo o shield para el m\u00f3dulo WiFi ESP-01 que est\u00e1 provisto de un chip conversor de USB a puerto serie, en concActividad el CH340G. El proceso de reprogramaci\u00f3n con esta placa es bastante sencillo pero requiere de comando AT que pasamos a introducir antes de continuar.","title":"Programaci\u00f3n"},{"location":"IoT_basico/#3-comando-at-en-el-esp8266","text":"El ESP-01 viene por defecto con el firmware AT ai-thinker V0.9.2.4. Los m\u00f3dems ven\u00edan con un conjunto de comandos que permiten que nos podamos comunicar con ellos para configurarlos y que lo podamos hacer a trav\u00e9s del puerto serie de ordenador al que est\u00e1n conectados. A estos comandos se les llama AT (de attention). Despu\u00e9s de cada comando AT, el ESP8266 espera los caracteres especiales de nueva linea para ejecutar el comando. El car\u00e1cter no imprimible CR (del ingl\u00e9s, Carriage Return) significa Actividadrno de carro y LF ( del ingl\u00e9s, Line Feed) es salto de l\u00ednea. El origen de la nomenclatura est\u00e1 en las m\u00e1quinas de escribir. En el enlace tenemos un pdf de la empresa Espressif Systems con el juego de comandos AT para el ESP8266. En la tabla siguiente damos un resumen de los comandos con una informaci\u00f3n ampliada de los que vamos a usar para la configuraci\u00f3n inicial que necesitamos. Unos comandos AT","title":"3.- Comando AT en el ESP8266"},{"location":"IoT_basico/#4-preparacion-del-modulo-esp-01","text":"Primero conectamos el m\u00f3dulo ESP8266 a la shield USB-serie y este a su vez a un puerto USB de nuestro ordenador. Nos aseguramos de que el interruptor est\u00e1 en modo Flash Boot. Entramos en ArduinoBlocks con ArduinoBlocks-Connector en funcionamiento, realizamos un refresco de la lectura del puerto para que detecte a la shield del m\u00f3dulo WiFi si es necesario, abrimos la consola, escogeremos la opci\u00f3n de 115200 en baudrate y tambi\u00e9n la de NL + LF (NL + LF es igual que CR + LF) para comunicarnos con el m\u00f3dulo WiFi. Hacemos clic en Conectar y conectamos la consola, escribimos \u201cAT\u201d en ella y clic en enviar. La situaci\u00f3n es la de la imagen siguiente: Comando AT en consola AB Si todo es correcto debe respondernos \u201cOK\u201d. Si responde algo sin sentido o no contesta, significa que est\u00e1 configurado en alguna otra velocidad. En este segundo caso deberemos cambiar la opci\u00f3n de baudrate y repetir la operaci\u00f3n con diferentes velocidades hasta que nos responda \u201cOK\u201d. La situaci\u00f3n correcta en la consola de comandos es la siguiente: Respuesta al comando AT Una vez que nos responda \u201cOK\u201d, le enviamos el texto \u201cAT+UART_DEF=9600,8,1,0,0\u201d y nos debe responder otra vez \u201cOK\u201d. Comando AT para establecer velocidad a 9600 baudios Con esto hemos cambiado la velocidad a 9600 baudios mediante el comando AT+UART_DEF que nos permite cambiar la definici\u00f3n a 9600 baudios, con 8 bits de datos, 1 bit de parada, sin paridad y sin habilitar el control de flujo. Una vez que hemos configurado el m\u00f3dulo WiFi a la velocidad que nos interesa debemos crear un canal en un servidor MQTT donde enviar los datos y visualizarlos. Esto lo vamos a hacer a trav\u00e9s de la web de Thingspeak , pero antes de nada vamos a describir que es MQTT. Para saber mas acerca de la reprogramaci\u00f3n de la velocidad de comunicaci\u00f3n con ESP8266 visita el enlace: Reprogramar la velocidad de comunicaci\u00f3n del ESP8266 .","title":"4.- Preparaci\u00f3n del m\u00f3dulo ESP-01"},{"location":"IoT_basico/#5-una-introduccion-al-iot-a-traves-de-mqtt","text":"Si queremos trabajar en tareas de IoT debemos de utilizar alg\u00fan protocolo de comunicaci\u00f3n y hoy por hoy el principal es MQTT, pero antes de citar protocolos vamos a tratar algunos conceptos necesarios. Un protocolo de comunicaci\u00f3n no es otra cosa que una serie de normas definidas para que dos o m\u00e1s dispositivos puedan comunicarse entre si de forma comprensible para ambos. Requisitos del IoT Estamos bastante acostumbrados a realizar un tipo de comunicaci\u00f3n denominada M2M (machine-to-machine) utilizando internet, pero cuando trabajamos en IoT debemos establecer una serie de requisitos que hacen que la comunicaci\u00f3n M2M no sea la mas adecuada. Algunos de estos requisitos son: Cantidad: se puede llegar a tener un gran n\u00famero de dispositivos diferentes, desde sensores, actuadores, servidores, etc. Escalabilidad: los sistemas deben permitir a\u00f1adir o eliminar dispositivos sin que el sistema global resulte afectado. Variedad: normalmente necesitaremos que el sistema funcione con diferentes sistemas operativos, lenguajes de programaci\u00f3n y el mayor n\u00famero posible de dispositivos. Simultaneidad: gran cantidad de comunicaciones simultaneas, lo que requiere respuestas r\u00e1pidas para lo que es necesario que los mensajes transmitidos sean lo mas cortos posibles. Seguridad: internet no es un sitio muy seguro y estos dispositivos van a estar conectados a internet controlando dispositivos f\u00edsicos. Accesibilidad: tendremos que trabajar en condiciones muy variadas en lo que se refiere a ancho de banda, firewall, direccionamiento,\u2026 La soluci\u00f3n mas com\u00fan consiste en disponer un servidor denominado \u2018broker\u2019, o a veces \u2018Router\u2019, que ser\u00e1 el que reciba los mensajes de los dispositivos emisores y los distribuir\u00e1 a los receptores. Broker El broker va a tener una direcci\u00f3n IP fija y ser\u00e1 accesible para todos los dispositivos, puede mantener un registro de los dispositivos conectados, recibir y distribuir mensajes y establecer filtros de destinatarios. Esto permite algo fundamental, y es que cada dispositivo no dependa del resto de dispositivos. Veamos algunos conceptos que nos permitan entender las infraestructuras de los servicios IoT: Message Queue o cola de mensajes. En este tipo el broker genera una cola de mensajes \u00fanica para cada uno de los clientes que inician la suscripci\u00f3n. Message Service o servicio de mensajer\u00eda. En este tipo el broker distribuye inmediatamente los mensajes filtrados por alg\u00fan criterio a los clientes conectados. A diferencia de Message Queue, los mensajes entregados mientras el cliente est\u00e1 desconectado se pierden. Publish/Susbcribe (PubSub). Se trata de un sistema de mensajer\u00eda donde el 'Subscriber' informa al broker de que quiere recibir un tipo de mensajes y el 'Publisher' entonces puede publicarlos. Router Remoder Procedure Calls (RRPC). Se trata de la ejecuci\u00f3n remota de procedimientos donde 'Callee' comunica al broker que proporciona un procedimiento y el 'Caller', puede llamar a este procedimiento. Algunos de los protocolos para IoT son: MQTT (del ingl\u00e9s Message Queuing Telemetry Transport) es un protocolo PubSub de servicio de mensajer\u00eda que act\u00faa sobre TCP. Es ligero y f\u00e1cil de implementar resultando apropiado para dispositivos de baja potencia, tan habituales en IoT. TCP es un protocolo de control de transmisi\u00f3n (del ingl\u00e9s, Transmission Control Protocol) fundamental en Internet. AMQP (Advanced Message Queuing Protocol) es un protocolo PubSub de cola de mensajes que asegura la confiabilidad e interoperabilidad necesaria en aplicaciones corporativas. STOMP (Streaming Text Oriented Messaging Protocol). Es un protocolo sencillo que emplea HTTP y mensajes de texto. XMPP (Extensible Messaging and Presence Protocol). Es un protocolo abierto basado en XML dise\u00f1ado para aplicaciones de mensajer\u00eda instant\u00e1nea. WAMP (Web Application Messaging Protocol). Es un protocolo abierto que se ejecuta sobre WebSockets, y provee tanto aplicaciones de PubSub como RRPC. CoAP (Constrained Application Protocol) es un protocolo pensado para emplearse en dispositivos de IoT de baja capacidad. MQTT Dentro de una arquitectura de MQTT, es muy importante el concepto topic (tema en espa\u00f1ol) ya que la comunicaci\u00f3n se realiza a trav\u00e9s de topics debiendo estar los emisores y receptores subscritos a un topic com\u00fan para poder establecer la comunicaci\u00f3n. Este tipo de arquitectura permite que la comunicaci\u00f3n pueda ser de uno a uno o de uno a muchos. Los topics tienen estructura jer\u00e1rquica pudiendo establecer relaciones padre-hijo de manera que cuando nos suscribimos a un topic padre podemos recibir tambi\u00e9n la informaci\u00f3n de sus hijos. En un ejemplo lo podemos ver m\u00e1s claramente. Estructura jerarquica de un topic Un topic se representa mediante una cadena con las jerarquias separadas por /. Por ejemplo: Vivienda/Planta baja/Cocina/Arduino/Luz Vivienda/Planta alta/Dorm.1/Arduino/Temperatura. De esta forma podemos suscribirnos a un topic concActividad o a varios, por ejemplo: Un topic: Vivienda/Planta baja/Cocina/Arduino/Luz Varios topics: Vivienda/Planta baja/# Existen b\u00e1sicamente tres tipos de brokers, los privados, los p\u00fablicos y los locales. A continuaci\u00f3n citamos alguno de los m\u00e1s utilizados: a .- Private MQTT Broker: solamente los dispositivos que establezcamos pueden publicar o suscribirse a un topic. Se utiliza en producci\u00f3n y prototipado. Algunos de ellos son: Azure de Microsoft. AWS de Amazon. CloudMQTT disponible en: https://www.cloudmqtt.com/plans.html . ThingSpeak de Mathworks (MATLAB). b .- Public MQTT Broker: cualquier dispositivo puede publicar y suscribirse a topics. Algunos de ellos son: Eclipse Mosquitto HiveMQ: Enlace - Direcci\u00f3n del broker Flespi Dioty Fluux Thingspeak Si queremos instalar nuestro propio broker en una raspberry o PC, sin duda Mosquito es la opci\u00f3n m\u00e1s extendida.","title":"5.- Una introducci\u00f3n al IoT a trav\u00e9s de MQTT"},{"location":"IoT_basico/#6-creacion-de-un-canal-en-un-servidor-mqtt","text":"En nuestro caso vamos a utilizar Thingspeak en su versi\u00f3n p\u00fablica. Lo primero que debemos hacer es crear una cuenta, para lo que clicamos en Sign Up. Seguidamente, introducimos un correo electr\u00f3nico v\u00e1lido y el resto de datos que nos pide. Lo vemos en la imagen siguiente: Pagina inicial de Thingspeaks Debemos aceptar que use la direcci\u00f3n de correo electr\u00f3nico para nuestra cuenta de MathWorks, como se ve en la imagen siguiente: Aceptaci\u00f3n a Mathwork Tras esto recibiremos un correo en la direcci\u00f3n que hemos dado para confirmar la creaci\u00f3n de la cuenta y confirmarla. Debemos ver algo similar a la imagen siguiente: Confirmacion aceptaci\u00f3n cuenta correo Una vez confirmada la direcci\u00f3n de correo electr\u00f3nico, volvemos a la p\u00e1gina donde est\u00e1bamos y hacemos click en continuar. Nos pedir\u00e1 un nombre de usuario y una contrase\u00f1a que usaremos a partir de ahora para iniciar sesi\u00f3n. Finalizada la creaci\u00f3n de la cuenta iniciamos sesi\u00f3n desde la p\u00e1gina principal haciendo clic en \u201cSign In\u201d. Veremos una ventana como la de la imagen siguiente: Ventana para identificaci\u00f3n en Thingspeaks Escribimos nuestra contrase\u00f1a y hacemos clic en el bot\u00f3n Sign in. Acceso a Thingspeaks Con esto entramos en el broker y est\u00e1 todo listo para iniciar el trabajo. Acceso correcto al broker Podemos aprender mas sobre el tema visitando los siguientes enlaces: Primeros pasos con Wifi: Servidor sin clave y contrase\u00f1a Wifi con servidor gratuito con clave y contrase\u00f1a y app m\u00f3vil C\u00f3mo publicar y almacenar datos por Wifi en Internet con Thingspeak","title":"6.- Creaci\u00f3n de un canal en un servidor MQTT"},{"location":"IoT_basico/#7-filtrado-por-mac","text":"Si por cualquier motivo nuestra red WiFi tiene filtrado MAC debemos de dar de alta en la misma de nuestro dispositivo ESP-01. Esta es una tarea que va a depender de nuestro router y suministrador y que no resulta especialmente complicada. Lo primero que debemos hacer es averiguar la direcci\u00f3n MAC de nuestro dispositivo ESP8266. Esta tarea no la vamos a hacer desde ArduinoBlocks sino que vamos a recurrir al IDE de Arduino. Si necesitas ayuda para este tema seguro que la encuentras en estos tutoriales de Luis Llamas , o tambi\u00e9n puedes buscar informaci\u00f3n en tu navegador pues existen multitud de p\u00e1ginas referentes al tema de programaci\u00f3n desde el IDE de Arduino. Los elementos que vamos a utilizar para conectar nuestro m\u00f3dulo ESP-01 a la placa TdR STEAM los vemos en la imagen siguiente: Shield WiFi serial M\u00f3dulo ESP-01 Conector de comunicaciones en la TdR STEAM Cables tipo Dupont M-H Conexionado Nos encontramos con el problema de que el orden de pines en el conector de la TdR STEAM (RX-TX-GND-VCC) no coinicede con el de la Shield WiFi serial (RX-TX-VCC-GND) por lo que no lo vamos a poder \"pinchar\" directamente en el conector y debemos utilizar cables tipo Dupont. Debemos tener muy presente que la placa TdR STEAM ya realiza una conexi\u00f3n cruzada entre los pines Tx y Rx , es decir: Rx de la TdR STEAM va conectada a Tx de la placa UNO Tx de la TdR STEAM va conectada a Rx de la placa UNO En la imagen siguiente vemos gr\u00e1ficamente como debemos hacer el conexionado al que nos estamos refiriendo. Conexi\u00f3n NO CRUZADA TdR - Shield Para nuestro prop\u00f3sito de comunicar el ordenador con el ESP-01 a trav\u00e9s del IDE y averiguar la MAC de nuestro dispositivo creo que lo mas conveniente y claro es realizar el montaje que vemos en la imagen siguiente: Conexi\u00f3n cruzada UNO a Shield wifi En este caso si es totalmente imprescindible realizar la conexi\u00f3n cruzada mostrada en la imagen entre Tx y Rx. Comunicaci\u00f3n entre PC y ESP01 Con la conexi\u00f3n cruzada descrita y un sketch vac\u00edo en el IDE que subimos a la placa UNO, conectamos el UNO al ordenador y establecemos la configuraci\u00f3n de nuestra placa UNO y el puerto USB al que estamos conectados. Lo que en realidad hacemos es usar la placa UNO como un convertidor bidireccional USB a RS232 que nos permite comunicar el ordenador con la placa ESP8266 ESP01. Abrimos el monitor serie desde el IDE de Arduino y lo configuramos como vemos en la imagen siguiente: Configuraci\u00f3n del monitor serie Escribimos AT y pulsamos Enter o hacemos clic en Enviar y el m\u00f3dulo deber\u00e1 responder OK si todo es correcto. Si la velocidad por defecto del m\u00f3dulo no es de 115200 no responder\u00e1 y posiblemente se vean caracteres extra\u00f1os en el monitor serie. En este caso habr\u00e1 que probar distintas velocidades hasta conseguir que el m\u00f3dulo responda OK al comando AT. El resultado correcto lo vemos en la imagen siguiente: Comando AT OK Direcci\u00f3n MAC El \u00faltimo paso es teclear el comando AT para conseguir la direcci\u00f3n f\u00edsica o MAC del dispositivo conectado. Este comando es AT+CIFSR y es que el que vemos en la imagen siguiente: Comando AT para obtener la MAC El comando AT+CIFSR nos devuelve un resultado similar al que vemos en la imagen siguiente: MAC obtenida Ya podemos dar de alta la MAC del dispositivo en nuestro filtrado MAC y poder as\u00ed comunicarnos a trav\u00e9s de WiFi.","title":"7.- Filtrado por MAC"},{"location":"LCD1602/","text":"Puerto de expansi\u00f3n I2C. La LCD de 2x16 \u00b6 Enunciado \u00b6 Utilizaremos las comunicaciones I2C para mostrar textos en la pantalla LCD I2C incluida en el kit. Teor\u00eda \u00b6 Las comunicaciones I2C \u00b6 Dado que la placa TdR STEAM dispone de un puerto de expansi\u00f3n I2C (del ingl\u00e9s Inter-Integrated Circuit = Circuito inter-integrado) vamos a explicar un poco en que consiste este sistema de conexionado. Bus conocido por las siglas I2C, IIC o I\u00b2C, es un bus serie de datos desarrollado en 1982 por Philips Semiconductors (hoy NXP Semiconductors, parte de Qualcomm). Se utiliza principalmente internamente para la comunicaci\u00f3n entre diferentes partes de un circuito, por ejemplo, entre un controlador y circuitos perif\u00e9ricos integrados. Posteriormente fue adoptado progresivamente por otros fabricantes hasta convertirse en un est\u00e1ndar del mercado con miles de circuitos integrados de diferentes fabricantes. I2C tambi\u00e9n se denomina TWI (Two Wired Interface) \u00fanicamente por motivos de licencia, denominaci\u00f3n introducida por Atmel. No obstante, la patente caduc\u00f3 en 2006, por lo que actualmente no hay restricci\u00f3n sobre el uso del t\u00e9rmino I2C. El bus I2C requiere \u00fanicamente dos cables o lineas de se\u00f1al para su funcionamiento, uno para la se\u00f1al de reloj (SCL, Serial Clock) y otro para el env\u00edo de datos (SDA, Serial Data). Ambas l\u00edneas precisan resistencias de pull-up hacia Vcc. Cualquier dispositivo conectado a estas l\u00edneas es de drenador o colector abierto (Open Collector), lo cual en combinaci\u00f3n con las resistencias pull-up, crea un circuito Wired-AND. En la imagen siguiente vemos el diagrama b\u00e1sico de conexionado del bus con algunos ejemplos de dispositivos. La se\u00f1al de reloj siempre es generada por el circuito que act\u00faa como Master. Diagrama de conexi\u00f3n del bus I2C Para ser reconocido en el bus, cada dispositivo dispone de una direcci\u00f3n f\u00edsica, que se emplea para acceder a cada uno de ellos de forma individual. Esta direcci\u00f3n puede ser fijada por hardware, en cuyo caso se pueden modificar los \u00faltimos 3 bits mediante \u201cjumpers\u201d o microinterruptores (ejemplo de la matriz de 8x8), o por software. En general, cada dispositivo conectado al bus debe tener una direcci\u00f3n \u00fanica. Si tenemos varios dispositivos similares tendremos que cambiar la direcci\u00f3n o, en caso de no ser posible, implementar un bus secundario. El bus I2C tiene una arquitectura de tipo master-slave, lo que indica que el master es el encargado de controlar al resto de dispositivos tipo slave con los que se comunica y que se comunican con el, teniendo siempre el marte prioridad absoluta. El dispositivo master es el que inicia la comunicaci\u00f3n con los slaves. Los slaves no pueden iniciar la comunicaci\u00f3n (el master tiene que preguntarles), ni hablar entre si directamente. El bus I2C debe ser por lo tanto s\u00edncrono, es decir debe existir una se\u00f1al de reloj que controle las comunicaciones. Es el master el que proporciona la se\u00f1al de reloj, que mantiene sincronizados a todos los dispositivos del bus. De esta forma, se elimina la necesidad de que cada dispositivo tenga su propio reloj, de tener que acordar una velocidad de transmisi\u00f3n y mecanismos para mantener la transmisi\u00f3n sincronizada como en UART o SPI. En la imagen vemos un cronograma ejemplo del funcionamiento del sistema. Cronograma trabajo bus I2C El protocolo de comunicaci\u00f3n I2C sigue la siguiente secuencia: Primero, el master genera la se\u00f1al de reloj del bus (SCL). Se inicia la comunicaci\u00f3n por orden del master al establecer la condici\u00f3n de START, que se produce cuando SDA pasa de uno a cero y se mantiene en cero durante un tiempo. El master direcciona a los slaves. El master indica si se va a leer o escribir. El slave direccionado responde con una se\u00f1al de conformidad ACK (acknowledge). Se transmite los datos byte a byte desde SDA al receptor. Por cada pulso desde SCL se transmite un bit de informaci\u00f3n. El destinatario de la informaci\u00f3n responde con una se\u00f1al de conformidad ACK. Se acaba la comunicaci\u00f3n cuando el master establece la condici\u00f3n de STOP, que se produce cuando SDA, por orden del master pasa de cero a uno y se mantiene en uno durante un tiempo. Son muchos los dispositivos I2C que se pueden direccionar por este bus I2C, siendo lo m\u00e1s com\u00fan en los dispositivos para I2C que utilicen direcciones de 7 bits, aunque existen dispositivos de 10 bits, pero es un caso raro. Una direcci\u00f3n de 7 bits implica que se pueden poner hasta 128 (27) dispositivos sobre un bus I2C. Hemos visto que las direcciones son de 8 bits y esto es porque el bit extra de los 7 de la direcci\u00f3n lo emplea el master para informar al slave si va a leer o escribir. Si el bit de lectura/escritura es cero, el dispositivo master est\u00e1 escribiendo en el slave. Si el bit es 1 el master est\u00e1 leyendo desde el slave. La direcci\u00f3n de 7 bit se coloca en los 7 bits m\u00e1s significativos del byte y el bit de lectura/escritura es el bit menos significativo. La LCD 1602 \u00b6 Una pantalla LCD (del ing\u00e9s, Liquid Cristal Display) de 2 l\u00edneas de 16 caracteres tiene el aspecto y la distribuci\u00f3n de pines que vemos en la imagen siguiente. LCD 2x16 Es evidente que deber\u00edamos utilizar bastantes patillas de nuestra placa tipo UNO (es el formato que tiene la ESP32 STEAMakers) para su control. En la imagen siguiente se muestra el conexionado m\u00ednimo necesario en una pantalla de este tipo: 4 bits para datos y dos se\u00f1ales de control En (Enable) y Rs (Register select). La conexi\u00f3n RW la ponemos a GND. Adem\u00e1s se debe a\u00f1adir una resistencia ajustable o un potenci\u00f3metro para regular el contraste de la pantalla. Conexionado m\u00ednimo LCD 2x16 Es preferible utilizar alguna de las que tienen el aspecto que vemos en la imagen siguiente: LCD 2x16 con m\u00f3dulo I2C En realidad el conjunto que vemos en la imagen anterior no es mas que una LCD 2x16 a la que se ha incorporado un m\u00f3dulo adaptador de LCD a I2C. Este modulo est\u00e1 especialmente dise\u00f1ado para poder soldarlo directamente a la LCD y convertirla as\u00ed en un dispositivo I2C que adem\u00e1s ya lleva incorporado el potenci\u00f3metro de ajuste de contraste en alguno de los casos. Este tipo de pantalla requiere cuatro cables para establecer las conexiones, dos cables SDA (datos) y SCL (reloj) para el bus de comunicaciones I2C y los dos cables de alimentaci\u00f3n VCC y GND. La direcci\u00f3n I2C por defecto de este tipo de m\u00f3dulos puede ser 0x3F o en otros casos 0x27, e incluso hay modelos en los que se puede cambiar. Para un correcto control es muy importante identificar correctamente la direcci\u00f3n I2C de nuestro modulo pues de otra forma nuestro programa no funcionar\u00e1 correctamente. Una LCD 1602 I2C es muy sencilla de controlar a partir de los bloques que nos proporciona ArduinoBlocks. En la imagen siguiente ponemos como ejemplo los bloques para imprimir un texto o variable en un par fila-columna determinado. Bloques para imprimir en un par fila-columna En la siguiente figura se muestra el sistema de distribuci\u00f3n de filas y columnas. Sistema de coordenadas en una LCD 1602 Escanear dispositivos I2C \u00b6 Si no conocemos la direcci\u00f3n especifica de nuestro m\u00f3dulo podemos utilizar un peque\u00f1o programa que llamaremos Escaner-I2C y que se encargar\u00e1 de identificar la direcci\u00f3n I2C y todos los dispositivos I2C conectados a nuestra placa. Debemos crear un proyecto, en esta ocasi\u00f3n, de tipo \"Arduino UNO\" para tener disponible el men\u00fa I2C que nos de acceso al bloque \"Escanear dispositivos I2C...\" tal y como vemos en la imagen siguiente: Menu I2C Un sencillo programa como el de la imagen siguiente nos permite ver los dispositivos I2C conectados y su direcci\u00f3n f\u00edsica asociada. El programa est\u00e1 disponible como Escaner-I2C . Programa Escaner-I2C Si conectamos la consola el resultado de tener la placa TdR STEAM con una LCD I2C conectada debe ser similar al de la imagen siguiente: Consola para el programa Escaner-I2C IMPORTANTE En el caso de la placa ESP32 STEAMakers no ocurre como en las tipo Arduino, que cuando conectamos la consola se efect\u00faa un reset autom\u00e1tico de la placa por lo que es muy posible que el programa de escaneo nos muestre una consola sin resultado alguno o en blanco. Simplemente, con la consola ya conectada, hacemos un reset f\u00edsico en la placa y el problema quedar\u00e1 solucionado. En la figura siguiente tenemos el resultado que se muestra con el programa anterior cargado, conectar la consola y hacer reset. En este caso vemos los cinco dispositivos conectados a trav\u00e9s de un hub y la placa TdR STEAM. Consola para el programa Escaner-I2C con 5 dispositivos Otra opci\u00f3n para hacer un esc\u00e1ner I2C que no necesita el reset es el programa que vemos en la figura siguiente y que lleva al bucle la orden de escaneo que se va a ejecutar cada 10 segundos, aunque este tiempo puede ser otro cualquiera. Programa Escaner-I2C en el bucle con 5 dispositivos En la figura siguiente vemos el resultado en la consola y como coincide con el anterior. Consola para el programa Escaner-I2C en el bucle con 5 dispositivos Cambiar la direcci\u00f3n f\u00edsica del dispositivo I2C \u00b6 Esta tarea nos va a resultar especialmente \u00fatil si disponemos de LCDs I2C con una direcci\u00f3n fijada de f\u00e1brica y queremos conectar varias de ellas en nuestro proyecto. LCD SIN micro interruptores La parte posterior de la LCD 1602 de Keyestudio tiene el aspecto de la imagen siguiente. Nos fijaremos especialmente en los tres grupos de agujeros enmarcados en rojo. Aunque en este caso no vienen nombrados los vamos a denominar A0, A1 y A2 de izquierda a derecha. Pads configuraci\u00f3n direcci\u00f3n f\u00edsica en la parte posterior LCD I2C La direcci\u00f3n por defecto de f\u00e1brica en este caso es la 0x27, pero se puede cambiar alterando la situaci\u00f3n de conexionado de estos agujeros entre si seg\u00fan la tabla siguiente: A2 A1 A0 Direcci\u00f3n 0 0 0 0x27 0 0 1 0x26 0 1 0 0x25 0 1 1 0x24 1 0 0 0x23 1 0 1 0x22 1 1 0 0x21 1 1 1 0x20 Para establecer los unos de la tabla anterior basta con cortocircuitar los dos pads correspondientes. En la imagen siguiente se ha establecido la direcci\u00f3n f\u00edsica como 0x26. Direcci\u00f3n 0x26 LCD CON micro interruptores La parte posterior de la LCD 1602 de Keyestudio con micro interruptores para cambiar su direcci\u00f3n f\u00edsica tiene el aspecto de la imagen siguiente. Nos fijaremos especialmente en el recuadro azul donde est\u00e1n los microinterruptores que permiten cambiar el estado del bit y encima de los mismo est\u00e1 la informaci\u00f3n de la direcci\u00f3n f\u00edsica que se asigna a cada combinaci\u00f3n. La tabla es exactamente la misma que en el caso anterior. Configuraci\u00f3n direcci\u00f3n f\u00edsica en la parte posterior LCD I2C con microinterruptores Definici\u00f3n de s\u00edmbolos en la LCD \u00b6 Dentro de los bloques del men\u00fa Visualizaci\u00f3n -> Pantalla LCD est\u00e1 el de \"definir s\u00edmbolo\", que permite definir uno de los 8 s\u00edmbolos personalizables que puede almacenar el micro de la pantalla LCD. El s\u00edmbolo se define por un mapa de bits (unos y ceros indicando cada p\u00edxel del s\u00edmbolo). Los s\u00edmbolos tienen una resoluci\u00f3n de 5x8 p\u00edxeles (blanco o negro). En ArduinoBlocks disponemos de una herramienta que nos ayuda a definir nuestros propios s\u00edmbolos y podemos acceder a ella desde herramientas o haciendo clic derecho sobre el bloque, despleg\u00e1ndose en cualquier caso un editor muy sencillo de usar y que vemos con un ejemplo en la imagen en la siguiente: Ejemplo de s\u00edmbolo creado con el editor Para tener el s\u00edmbolo disponible simplemente copiamos la cadena generada en el lugar correspondiente del bloque. En la TdR STEAM \u00b6 En la placa TdR STEAM tenemos el conector I2C con los mismo pines de conexi\u00f3n que la LCD y debemos respetar el orden de conexionado indicado en la siguiente tabla: TdR STEAM LCD 1602 Color cable GND GND Negro Vcc Vcc Rojo SDA SDA Amarillo SCL SCL Blanco La ubicaci\u00f3n del conector I2C en la TdR STEAM lo vemos en la imagen siguiente: Conector I2C en la TdR STEAM Recordemos que en el caso de la LCD con micro interruptores o LCD direccionable dispone de un peque\u00f1o hub I2C que permite conectar dos dispositivos I2C mas. El t\u00e9rmino direccionable no me parece una denominaci\u00f3n muy correcta dado que el otro tipo tambi\u00e9n es direccionable, aunque tengamos que soldar. Programando la actividad \u00b6 Como primer ejemplo de uso vamos a mostrar una determinada informaci\u00f3n en la pantalla LCD, en concreto vamos a mostrar una serie de seis textos en ambas filas que se ir\u00e1n alternando cada tres segundos en la pantalla. El programa de la imagen siguiente lo tenemos disponible en ESP32-SM-Actividad-inicial . Actividad inicial Retos de ampliaci\u00f3n \u00b6 LCD.R1 . Corregir el error ortogr\u00e1fico en la palabra \"Robotica\" de la actividad anterior. Para ello tenemos que definir nuestro propio s\u00edmbolo de \"\u00f3\" (o acentuada). Definimos el s\u00edmbolo requerido tal y como vemos en la imagen siguiente: S\u00edmbolo 'o' acentuada El programa resuelto es el de la figura siguiente: Soluci\u00f3n al reto 1 de la actividad LCD LCD.R2 . Realizar un control de iluminaci\u00f3n del LED RGB mediante PWM y mostrar por pantalla el valor de la iluminaci\u00f3n en cada instante. Se realizar\u00e1 el control desde el m\u00ednimo de iluminaci\u00f3n a m\u00e1ximo y cuando se alcance el m\u00e1ximo bajamos otra vez a m\u00ednimo. El programa resuelto es el de la figura siguiente: Soluci\u00f3n al reto 2 de la actividad LCD Se ha resuelto con un contador ascendente y otro descendente sobre el LED rojo. Se pueden probar diferentes opciones de LEDs o incluso combinaci\u00f3n de ellas. Tambi\u00e9n se anima al lector a comprobar que ocurre si quitamos la opci\u00f3n \"N\u00famero entero\" y ponemos directamente la variable del bucle y buscar la explicaci\u00f3n.","title":"Puerto de expansi\u00f3n I2C. La LCD de 2x16"},{"location":"LCD1602/#puerto-de-expansion-i2c-la-lcd-de-2x16","text":"","title":"Puerto de expansi\u00f3n I2C. La LCD de 2x16"},{"location":"LCD1602/#enunciado","text":"Utilizaremos las comunicaciones I2C para mostrar textos en la pantalla LCD I2C incluida en el kit.","title":"Enunciado"},{"location":"LCD1602/#teoria","text":"","title":"Teor\u00eda"},{"location":"LCD1602/#las-comunicaciones-i2c","text":"Dado que la placa TdR STEAM dispone de un puerto de expansi\u00f3n I2C (del ingl\u00e9s Inter-Integrated Circuit = Circuito inter-integrado) vamos a explicar un poco en que consiste este sistema de conexionado. Bus conocido por las siglas I2C, IIC o I\u00b2C, es un bus serie de datos desarrollado en 1982 por Philips Semiconductors (hoy NXP Semiconductors, parte de Qualcomm). Se utiliza principalmente internamente para la comunicaci\u00f3n entre diferentes partes de un circuito, por ejemplo, entre un controlador y circuitos perif\u00e9ricos integrados. Posteriormente fue adoptado progresivamente por otros fabricantes hasta convertirse en un est\u00e1ndar del mercado con miles de circuitos integrados de diferentes fabricantes. I2C tambi\u00e9n se denomina TWI (Two Wired Interface) \u00fanicamente por motivos de licencia, denominaci\u00f3n introducida por Atmel. No obstante, la patente caduc\u00f3 en 2006, por lo que actualmente no hay restricci\u00f3n sobre el uso del t\u00e9rmino I2C. El bus I2C requiere \u00fanicamente dos cables o lineas de se\u00f1al para su funcionamiento, uno para la se\u00f1al de reloj (SCL, Serial Clock) y otro para el env\u00edo de datos (SDA, Serial Data). Ambas l\u00edneas precisan resistencias de pull-up hacia Vcc. Cualquier dispositivo conectado a estas l\u00edneas es de drenador o colector abierto (Open Collector), lo cual en combinaci\u00f3n con las resistencias pull-up, crea un circuito Wired-AND. En la imagen siguiente vemos el diagrama b\u00e1sico de conexionado del bus con algunos ejemplos de dispositivos. La se\u00f1al de reloj siempre es generada por el circuito que act\u00faa como Master. Diagrama de conexi\u00f3n del bus I2C Para ser reconocido en el bus, cada dispositivo dispone de una direcci\u00f3n f\u00edsica, que se emplea para acceder a cada uno de ellos de forma individual. Esta direcci\u00f3n puede ser fijada por hardware, en cuyo caso se pueden modificar los \u00faltimos 3 bits mediante \u201cjumpers\u201d o microinterruptores (ejemplo de la matriz de 8x8), o por software. En general, cada dispositivo conectado al bus debe tener una direcci\u00f3n \u00fanica. Si tenemos varios dispositivos similares tendremos que cambiar la direcci\u00f3n o, en caso de no ser posible, implementar un bus secundario. El bus I2C tiene una arquitectura de tipo master-slave, lo que indica que el master es el encargado de controlar al resto de dispositivos tipo slave con los que se comunica y que se comunican con el, teniendo siempre el marte prioridad absoluta. El dispositivo master es el que inicia la comunicaci\u00f3n con los slaves. Los slaves no pueden iniciar la comunicaci\u00f3n (el master tiene que preguntarles), ni hablar entre si directamente. El bus I2C debe ser por lo tanto s\u00edncrono, es decir debe existir una se\u00f1al de reloj que controle las comunicaciones. Es el master el que proporciona la se\u00f1al de reloj, que mantiene sincronizados a todos los dispositivos del bus. De esta forma, se elimina la necesidad de que cada dispositivo tenga su propio reloj, de tener que acordar una velocidad de transmisi\u00f3n y mecanismos para mantener la transmisi\u00f3n sincronizada como en UART o SPI. En la imagen vemos un cronograma ejemplo del funcionamiento del sistema. Cronograma trabajo bus I2C El protocolo de comunicaci\u00f3n I2C sigue la siguiente secuencia: Primero, el master genera la se\u00f1al de reloj del bus (SCL). Se inicia la comunicaci\u00f3n por orden del master al establecer la condici\u00f3n de START, que se produce cuando SDA pasa de uno a cero y se mantiene en cero durante un tiempo. El master direcciona a los slaves. El master indica si se va a leer o escribir. El slave direccionado responde con una se\u00f1al de conformidad ACK (acknowledge). Se transmite los datos byte a byte desde SDA al receptor. Por cada pulso desde SCL se transmite un bit de informaci\u00f3n. El destinatario de la informaci\u00f3n responde con una se\u00f1al de conformidad ACK. Se acaba la comunicaci\u00f3n cuando el master establece la condici\u00f3n de STOP, que se produce cuando SDA, por orden del master pasa de cero a uno y se mantiene en uno durante un tiempo. Son muchos los dispositivos I2C que se pueden direccionar por este bus I2C, siendo lo m\u00e1s com\u00fan en los dispositivos para I2C que utilicen direcciones de 7 bits, aunque existen dispositivos de 10 bits, pero es un caso raro. Una direcci\u00f3n de 7 bits implica que se pueden poner hasta 128 (27) dispositivos sobre un bus I2C. Hemos visto que las direcciones son de 8 bits y esto es porque el bit extra de los 7 de la direcci\u00f3n lo emplea el master para informar al slave si va a leer o escribir. Si el bit de lectura/escritura es cero, el dispositivo master est\u00e1 escribiendo en el slave. Si el bit es 1 el master est\u00e1 leyendo desde el slave. La direcci\u00f3n de 7 bit se coloca en los 7 bits m\u00e1s significativos del byte y el bit de lectura/escritura es el bit menos significativo.","title":"Las comunicaciones I2C"},{"location":"LCD1602/#la-lcd-1602","text":"Una pantalla LCD (del ing\u00e9s, Liquid Cristal Display) de 2 l\u00edneas de 16 caracteres tiene el aspecto y la distribuci\u00f3n de pines que vemos en la imagen siguiente. LCD 2x16 Es evidente que deber\u00edamos utilizar bastantes patillas de nuestra placa tipo UNO (es el formato que tiene la ESP32 STEAMakers) para su control. En la imagen siguiente se muestra el conexionado m\u00ednimo necesario en una pantalla de este tipo: 4 bits para datos y dos se\u00f1ales de control En (Enable) y Rs (Register select). La conexi\u00f3n RW la ponemos a GND. Adem\u00e1s se debe a\u00f1adir una resistencia ajustable o un potenci\u00f3metro para regular el contraste de la pantalla. Conexionado m\u00ednimo LCD 2x16 Es preferible utilizar alguna de las que tienen el aspecto que vemos en la imagen siguiente: LCD 2x16 con m\u00f3dulo I2C En realidad el conjunto que vemos en la imagen anterior no es mas que una LCD 2x16 a la que se ha incorporado un m\u00f3dulo adaptador de LCD a I2C. Este modulo est\u00e1 especialmente dise\u00f1ado para poder soldarlo directamente a la LCD y convertirla as\u00ed en un dispositivo I2C que adem\u00e1s ya lleva incorporado el potenci\u00f3metro de ajuste de contraste en alguno de los casos. Este tipo de pantalla requiere cuatro cables para establecer las conexiones, dos cables SDA (datos) y SCL (reloj) para el bus de comunicaciones I2C y los dos cables de alimentaci\u00f3n VCC y GND. La direcci\u00f3n I2C por defecto de este tipo de m\u00f3dulos puede ser 0x3F o en otros casos 0x27, e incluso hay modelos en los que se puede cambiar. Para un correcto control es muy importante identificar correctamente la direcci\u00f3n I2C de nuestro modulo pues de otra forma nuestro programa no funcionar\u00e1 correctamente. Una LCD 1602 I2C es muy sencilla de controlar a partir de los bloques que nos proporciona ArduinoBlocks. En la imagen siguiente ponemos como ejemplo los bloques para imprimir un texto o variable en un par fila-columna determinado. Bloques para imprimir en un par fila-columna En la siguiente figura se muestra el sistema de distribuci\u00f3n de filas y columnas. Sistema de coordenadas en una LCD 1602","title":"La LCD 1602"},{"location":"LCD1602/#escanear-dispositivos-i2c","text":"Si no conocemos la direcci\u00f3n especifica de nuestro m\u00f3dulo podemos utilizar un peque\u00f1o programa que llamaremos Escaner-I2C y que se encargar\u00e1 de identificar la direcci\u00f3n I2C y todos los dispositivos I2C conectados a nuestra placa. Debemos crear un proyecto, en esta ocasi\u00f3n, de tipo \"Arduino UNO\" para tener disponible el men\u00fa I2C que nos de acceso al bloque \"Escanear dispositivos I2C...\" tal y como vemos en la imagen siguiente: Menu I2C Un sencillo programa como el de la imagen siguiente nos permite ver los dispositivos I2C conectados y su direcci\u00f3n f\u00edsica asociada. El programa est\u00e1 disponible como Escaner-I2C . Programa Escaner-I2C Si conectamos la consola el resultado de tener la placa TdR STEAM con una LCD I2C conectada debe ser similar al de la imagen siguiente: Consola para el programa Escaner-I2C IMPORTANTE En el caso de la placa ESP32 STEAMakers no ocurre como en las tipo Arduino, que cuando conectamos la consola se efect\u00faa un reset autom\u00e1tico de la placa por lo que es muy posible que el programa de escaneo nos muestre una consola sin resultado alguno o en blanco. Simplemente, con la consola ya conectada, hacemos un reset f\u00edsico en la placa y el problema quedar\u00e1 solucionado. En la figura siguiente tenemos el resultado que se muestra con el programa anterior cargado, conectar la consola y hacer reset. En este caso vemos los cinco dispositivos conectados a trav\u00e9s de un hub y la placa TdR STEAM. Consola para el programa Escaner-I2C con 5 dispositivos Otra opci\u00f3n para hacer un esc\u00e1ner I2C que no necesita el reset es el programa que vemos en la figura siguiente y que lleva al bucle la orden de escaneo que se va a ejecutar cada 10 segundos, aunque este tiempo puede ser otro cualquiera. Programa Escaner-I2C en el bucle con 5 dispositivos En la figura siguiente vemos el resultado en la consola y como coincide con el anterior. Consola para el programa Escaner-I2C en el bucle con 5 dispositivos","title":"Escanear dispositivos I2C"},{"location":"LCD1602/#cambiar-la-direccion-fisica-del-dispositivo-i2c","text":"Esta tarea nos va a resultar especialmente \u00fatil si disponemos de LCDs I2C con una direcci\u00f3n fijada de f\u00e1brica y queremos conectar varias de ellas en nuestro proyecto. LCD SIN micro interruptores La parte posterior de la LCD 1602 de Keyestudio tiene el aspecto de la imagen siguiente. Nos fijaremos especialmente en los tres grupos de agujeros enmarcados en rojo. Aunque en este caso no vienen nombrados los vamos a denominar A0, A1 y A2 de izquierda a derecha. Pads configuraci\u00f3n direcci\u00f3n f\u00edsica en la parte posterior LCD I2C La direcci\u00f3n por defecto de f\u00e1brica en este caso es la 0x27, pero se puede cambiar alterando la situaci\u00f3n de conexionado de estos agujeros entre si seg\u00fan la tabla siguiente: A2 A1 A0 Direcci\u00f3n 0 0 0 0x27 0 0 1 0x26 0 1 0 0x25 0 1 1 0x24 1 0 0 0x23 1 0 1 0x22 1 1 0 0x21 1 1 1 0x20 Para establecer los unos de la tabla anterior basta con cortocircuitar los dos pads correspondientes. En la imagen siguiente se ha establecido la direcci\u00f3n f\u00edsica como 0x26. Direcci\u00f3n 0x26 LCD CON micro interruptores La parte posterior de la LCD 1602 de Keyestudio con micro interruptores para cambiar su direcci\u00f3n f\u00edsica tiene el aspecto de la imagen siguiente. Nos fijaremos especialmente en el recuadro azul donde est\u00e1n los microinterruptores que permiten cambiar el estado del bit y encima de los mismo est\u00e1 la informaci\u00f3n de la direcci\u00f3n f\u00edsica que se asigna a cada combinaci\u00f3n. La tabla es exactamente la misma que en el caso anterior. Configuraci\u00f3n direcci\u00f3n f\u00edsica en la parte posterior LCD I2C con microinterruptores","title":"Cambiar la direcci\u00f3n f\u00edsica del dispositivo I2C"},{"location":"LCD1602/#definicion-de-simbolos-en-la-lcd","text":"Dentro de los bloques del men\u00fa Visualizaci\u00f3n -> Pantalla LCD est\u00e1 el de \"definir s\u00edmbolo\", que permite definir uno de los 8 s\u00edmbolos personalizables que puede almacenar el micro de la pantalla LCD. El s\u00edmbolo se define por un mapa de bits (unos y ceros indicando cada p\u00edxel del s\u00edmbolo). Los s\u00edmbolos tienen una resoluci\u00f3n de 5x8 p\u00edxeles (blanco o negro). En ArduinoBlocks disponemos de una herramienta que nos ayuda a definir nuestros propios s\u00edmbolos y podemos acceder a ella desde herramientas o haciendo clic derecho sobre el bloque, despleg\u00e1ndose en cualquier caso un editor muy sencillo de usar y que vemos con un ejemplo en la imagen en la siguiente: Ejemplo de s\u00edmbolo creado con el editor Para tener el s\u00edmbolo disponible simplemente copiamos la cadena generada en el lugar correspondiente del bloque.","title":"Definici\u00f3n de s\u00edmbolos en la LCD"},{"location":"LCD1602/#en-la-tdr-steam","text":"En la placa TdR STEAM tenemos el conector I2C con los mismo pines de conexi\u00f3n que la LCD y debemos respetar el orden de conexionado indicado en la siguiente tabla: TdR STEAM LCD 1602 Color cable GND GND Negro Vcc Vcc Rojo SDA SDA Amarillo SCL SCL Blanco La ubicaci\u00f3n del conector I2C en la TdR STEAM lo vemos en la imagen siguiente: Conector I2C en la TdR STEAM Recordemos que en el caso de la LCD con micro interruptores o LCD direccionable dispone de un peque\u00f1o hub I2C que permite conectar dos dispositivos I2C mas. El t\u00e9rmino direccionable no me parece una denominaci\u00f3n muy correcta dado que el otro tipo tambi\u00e9n es direccionable, aunque tengamos que soldar.","title":"En la TdR STEAM"},{"location":"LCD1602/#programando-la-actividad","text":"Como primer ejemplo de uso vamos a mostrar una determinada informaci\u00f3n en la pantalla LCD, en concreto vamos a mostrar una serie de seis textos en ambas filas que se ir\u00e1n alternando cada tres segundos en la pantalla. El programa de la imagen siguiente lo tenemos disponible en ESP32-SM-Actividad-inicial . Actividad inicial","title":"Programando la actividad"},{"location":"LCD1602/#retos-de-ampliacion","text":"LCD.R1 . Corregir el error ortogr\u00e1fico en la palabra \"Robotica\" de la actividad anterior. Para ello tenemos que definir nuestro propio s\u00edmbolo de \"\u00f3\" (o acentuada). Definimos el s\u00edmbolo requerido tal y como vemos en la imagen siguiente: S\u00edmbolo 'o' acentuada El programa resuelto es el de la figura siguiente: Soluci\u00f3n al reto 1 de la actividad LCD LCD.R2 . Realizar un control de iluminaci\u00f3n del LED RGB mediante PWM y mostrar por pantalla el valor de la iluminaci\u00f3n en cada instante. Se realizar\u00e1 el control desde el m\u00ednimo de iluminaci\u00f3n a m\u00e1ximo y cuando se alcance el m\u00e1ximo bajamos otra vez a m\u00ednimo. El programa resuelto es el de la figura siguiente: Soluci\u00f3n al reto 2 de la actividad LCD Se ha resuelto con un contador ascendente y otro descendente sobre el LED rojo. Se pueden probar diferentes opciones de LEDs o incluso combinaci\u00f3n de ellas. Tambi\u00e9n se anima al lector a comprobar que ocurre si quitamos la opci\u00f3n \"N\u00famero entero\" y ponemos directamente la variable del bucle y buscar la explicaci\u00f3n.","title":"Retos de ampliaci\u00f3n"},{"location":"color/","text":"Sensor de color \u00b6 Enunciado \u00b6 A partir de una tarjeta en la que se han dispuesto tres zonas de colores rojo, verde y azul haremos que cuando acerquemos el sensor a alguna de ellas la tira de LEDs RGB se ilumine en ese color permaneciendo apagado si no detecta ninguno de los tres colores. Teor\u00eda \u00b6 El sensor de color RGB TCS34725 puede reconocer el color de la superficie de un objeto a trav\u00e9s de la detecci\u00f3n \u00f3ptica. El sensor se ilumina con luz brillante y emite los valores RGB correspondientes. Adem\u00e1s, para evitar la interferencia del entorno y aumentar la precisi\u00f3n, dispone de una placa protectora de luz infrarroja en la parte inferior del sensor, de modo que el elemento de espectro infrarrojo de la luz incidente se minimiza para hacer que la gesti\u00f3n del color sea m\u00e1s precisa. En la parte inferior del sensor, se pueden ver 4 LEDs que garantizan que el sensor se pueda usar normalmente en condiciones de poca luz ambiental. En la figura siguiente vemos el aspecto del mismo por ambos lados. Aspecto Estas son sus especificaciones t\u00e9cnicas: Voltaje de funcionamiento: 3.3-5V Corriente de funcionamiento: 65uA Distancia medida: 3-10mm Frecuencia de reloj: 0-400KHZ Interfaz: I2C y paso de pin de 2,54 mm Rango de temperatura: -30 \u00b0C ~ + 70 El sensor se comunica con la placa ESP32 Plus STEAMakers a trav\u00e9s del bus de comunicaciones I2C. No necesitaremos asignarle direcci\u00f3n f\u00edsica porque ya vienen predefinido dentro del propio bloque. Dentro del apartado 'Sensores' tenemos los bloques para trabajar con este sensor. En la figura siguiente podemos ver los bloques para programar el sensor de color. Bloques Programando la actividad \u00b6 Hacer un programa que cumpla las condiciones del enunciado y que adem\u00e1s encienda el LED RGB de la TdR STEAM y muestre el nombre del color en la LCD. El programa de la imagen siguiente esta disponible como detectar-color . Encender la tira del color detectado","title":"Sensor de color"},{"location":"color/#sensor-de-color","text":"","title":"Sensor de color"},{"location":"color/#enunciado","text":"A partir de una tarjeta en la que se han dispuesto tres zonas de colores rojo, verde y azul haremos que cuando acerquemos el sensor a alguna de ellas la tira de LEDs RGB se ilumine en ese color permaneciendo apagado si no detecta ninguno de los tres colores.","title":"Enunciado"},{"location":"color/#teoria","text":"El sensor de color RGB TCS34725 puede reconocer el color de la superficie de un objeto a trav\u00e9s de la detecci\u00f3n \u00f3ptica. El sensor se ilumina con luz brillante y emite los valores RGB correspondientes. Adem\u00e1s, para evitar la interferencia del entorno y aumentar la precisi\u00f3n, dispone de una placa protectora de luz infrarroja en la parte inferior del sensor, de modo que el elemento de espectro infrarrojo de la luz incidente se minimiza para hacer que la gesti\u00f3n del color sea m\u00e1s precisa. En la parte inferior del sensor, se pueden ver 4 LEDs que garantizan que el sensor se pueda usar normalmente en condiciones de poca luz ambiental. En la figura siguiente vemos el aspecto del mismo por ambos lados. Aspecto Estas son sus especificaciones t\u00e9cnicas: Voltaje de funcionamiento: 3.3-5V Corriente de funcionamiento: 65uA Distancia medida: 3-10mm Frecuencia de reloj: 0-400KHZ Interfaz: I2C y paso de pin de 2,54 mm Rango de temperatura: -30 \u00b0C ~ + 70 El sensor se comunica con la placa ESP32 Plus STEAMakers a trav\u00e9s del bus de comunicaciones I2C. No necesitaremos asignarle direcci\u00f3n f\u00edsica porque ya vienen predefinido dentro del propio bloque. Dentro del apartado 'Sensores' tenemos los bloques para trabajar con este sensor. En la figura siguiente podemos ver los bloques para programar el sensor de color. Bloques","title":"Teor\u00eda"},{"location":"color/#programando-la-actividad","text":"Hacer un programa que cumpla las condiciones del enunciado y que adem\u00e1s encienda el LED RGB de la TdR STEAM y muestre el nombre del color en la LCD. El programa de la imagen siguiente esta disponible como detectar-color . Encender la tira del color detectado","title":"Programando la actividad"},{"location":"evita_obs/","text":"Sensor infrarrojo para evitar obst\u00e1culos \u00b6 Enunciado \u00b6 Realizaremos un detector b\u00e1sico de obst\u00e1culos conectando el sensor a cualquiera de los conectores digitales libres, que son D3 y D5. Teor\u00eda \u00b6 Se trata de un sensor digital que entrega una lectura de nivel TTL. El sensor est\u00e1 equipado con funci\u00f3n de ajuste de distancia con una gran adaptabilidad a la luz ambiental y es de alta precisi\u00f3n. Tiene un diodo de transmisi\u00f3n y un fototransistor de recepci\u00f3n de infrarrojos. Cuando el rayo infrarrojo lanzado por el LED transmisor encuentra un obst\u00e1culo el rayo se refleja y el fototransistor lo recibe, siendo esto procesado por un circuito comparador que detectar\u00e1 el obst\u00e1culo y el LED indicador de la placa se iluminar\u00e1. Cuando se usa para detectar l\u00edneas b\u00e1sicamente el rayo emitido se refleja si el color es blanco y no hay reflexi\u00f3n si el color es negro pudiendo as\u00ed detectar estos colores de l\u00ednea. Se puede ajustar la distancia de detecci\u00f3n con las dos resistencias variables de que est\u00e1 equipado en un rango efectivo entre 2 y 40 cm. Sus principales especificaciones son: Alimentaci\u00f3n: 3,3 V o 5 V Consumo: \u226520mA Temperatura de trabajo: -10 \u2103 a \uff0b50 \u2103 Distancia de detecci\u00f3n: 2-40 cm Interfaz IO: 4 pines (-/+/S/EN) Se\u00f1al de salida: voltaje TTL B\u00e1sicamente se puede utilizar para evitar obst\u00e1culos y para robots seguidores de l\u00ednea bien en color blanco o bien en color negro. Su aspecto lo vemos en la figura siguiente: Aspecto del sensor Programando la actividad \u00b6 Vamos a realizar un detector muy b\u00e1sico de obst\u00e1culos que nos muestre en la LCD el texto \u00bfObstaculo? Y el mensaje SI o NO en funci\u00f3n de que exista o no dicho obst\u00e1culo dentro del rango de detecci\u00f3n del sensor. El programa de la imagen siguiente esta disponible como ESP32-SM-obstaculos-inicial . Actividad inicial con el detector de obst\u00e1culos","title":"Sensor infrarrojo para evitar obst\u00e1culos"},{"location":"evita_obs/#sensor-infrarrojo-para-evitar-obstaculos","text":"","title":"Sensor infrarrojo para evitar obst\u00e1culos"},{"location":"evita_obs/#enunciado","text":"Realizaremos un detector b\u00e1sico de obst\u00e1culos conectando el sensor a cualquiera de los conectores digitales libres, que son D3 y D5.","title":"Enunciado"},{"location":"evita_obs/#teoria","text":"Se trata de un sensor digital que entrega una lectura de nivel TTL. El sensor est\u00e1 equipado con funci\u00f3n de ajuste de distancia con una gran adaptabilidad a la luz ambiental y es de alta precisi\u00f3n. Tiene un diodo de transmisi\u00f3n y un fototransistor de recepci\u00f3n de infrarrojos. Cuando el rayo infrarrojo lanzado por el LED transmisor encuentra un obst\u00e1culo el rayo se refleja y el fototransistor lo recibe, siendo esto procesado por un circuito comparador que detectar\u00e1 el obst\u00e1culo y el LED indicador de la placa se iluminar\u00e1. Cuando se usa para detectar l\u00edneas b\u00e1sicamente el rayo emitido se refleja si el color es blanco y no hay reflexi\u00f3n si el color es negro pudiendo as\u00ed detectar estos colores de l\u00ednea. Se puede ajustar la distancia de detecci\u00f3n con las dos resistencias variables de que est\u00e1 equipado en un rango efectivo entre 2 y 40 cm. Sus principales especificaciones son: Alimentaci\u00f3n: 3,3 V o 5 V Consumo: \u226520mA Temperatura de trabajo: -10 \u2103 a \uff0b50 \u2103 Distancia de detecci\u00f3n: 2-40 cm Interfaz IO: 4 pines (-/+/S/EN) Se\u00f1al de salida: voltaje TTL B\u00e1sicamente se puede utilizar para evitar obst\u00e1culos y para robots seguidores de l\u00ednea bien en color blanco o bien en color negro. Su aspecto lo vemos en la figura siguiente: Aspecto del sensor","title":"Teor\u00eda"},{"location":"evita_obs/#programando-la-actividad","text":"Vamos a realizar un detector muy b\u00e1sico de obst\u00e1culos que nos muestre en la LCD el texto \u00bfObstaculo? Y el mensaje SI o NO en funci\u00f3n de que exista o no dicho obst\u00e1culo dentro del rango de detecci\u00f3n del sensor. El programa de la imagen siguiente esta disponible como ESP32-SM-obstaculos-inicial . Actividad inicial con el detector de obst\u00e1culos","title":"Programando la actividad"},{"location":"gestos/","text":"Sensor de gestos \u00b6 Enunciado \u00b6 A partir de una tarjeta en la que se han dispuesto tres zonas de colores rojo, verde y azul haremos que cuando acerquemos el sensor a alguna de ellas la tira de LEDs RGB se ilumine en ese color permaneciendo apagado si no detecta ninguno de los tres colores. Teor\u00eda \u00b6 El m\u00f3dulo sensor de reconocimiento de gestos se basa en el chip PAJ7620 que integra el reconocimiento de gestos a partir de una c\u00e1mara diminuta y se comunica utilizando la interfaz I2C. Este sensor de gestos puede reconocer los nueve gestos embebidos en sus registros y que son: Moverse hacia arriba Moverse hacia abajo Moverse hacia la izquierda Moverse hacia la derecha Moverse hacia adelante Moverse hacia atr\u00e1s Moverse en sentido horario Moverse en sentido antihorario Moverse en forma de onda. El rango normal de detecci\u00f3n est\u00e1 comprendido entre 5 y 15 cm con una velocidad del gesto de entre 60 y 600 \u00ba/s (grados por segundo) Estas son sus especificaciones t\u00e9cnicas: Tensi\u00f3n de trabajo: DC 5 V Corriente de trabajo: 50mA Potencia m\u00e1xima: 0.5 W Distancia de detecci\u00f3n: 10 cm Velocidad de gestos: 60 \u00b0/s a 600 \u00b0/s Inmunidad a la luz ambiental: <100k Lux Velocidad de comunicaci\u00f3n I2C: 400 kbit/s Temperatura de trabajo: -25 a + 65 \u00b0C En la figura siguiente vemos su aspecto. Aspecto La figura anterior muestra la posici\u00f3n correcta del sensor para reconocer los gestos implementados en los bloques En la figura siguiente podemos ver los bloques para programar el sensor de gestos. Bloques La forma de trabajar con el sensor es primero leer el gesto y luego determinar que gesto estamos haciendo. El bloque de la figura siguiente nos permite elegir entre los nueve gestos posibles. Bloque tipos de gestos Programando la actividad \u00b6 En esta ocasi\u00f3n vamos a realizar dos pr\u00e1cticas, una b\u00e1sica y otra mas avanzada para as\u00ed trabajar con el sensor. Actividad b\u00e1sica Mostrar por consola el movimiento realizado en forma de n\u00famero entero por la consola. El programa de la imagen siguiente esta disponible como gesto-consola . Mostrar gesto por consola Actividad avanzada Vamos a enceder y apagar los diodos LEDs rojo y azul de la TdR STEAM respondiendo a los siguientes gestos: Encender LED rojo: Arriba Apagar LED rojo: Abajo Encender LED azul: Izquierda Apagar LED azul: Derecha El programa de la imagen siguiente esta disponible como gesto-LEDs . Encender y apagar LEDs por gestos Retos de ampliaci\u00f3n \u00b6 Gestos.R1 . Realiza un programa que en funci\u00f3n de cada uno de los nueves movimientos posibles encienda el led RGB de la TdR STEAM con un color diferente. Gestos.R2 . Amplia el programa para que se encienda del mismo color (o diferente) los LEDs de la tira.","title":"Sensor de gestos"},{"location":"gestos/#sensor-de-gestos","text":"","title":"Sensor de gestos"},{"location":"gestos/#enunciado","text":"A partir de una tarjeta en la que se han dispuesto tres zonas de colores rojo, verde y azul haremos que cuando acerquemos el sensor a alguna de ellas la tira de LEDs RGB se ilumine en ese color permaneciendo apagado si no detecta ninguno de los tres colores.","title":"Enunciado"},{"location":"gestos/#teoria","text":"El m\u00f3dulo sensor de reconocimiento de gestos se basa en el chip PAJ7620 que integra el reconocimiento de gestos a partir de una c\u00e1mara diminuta y se comunica utilizando la interfaz I2C. Este sensor de gestos puede reconocer los nueve gestos embebidos en sus registros y que son: Moverse hacia arriba Moverse hacia abajo Moverse hacia la izquierda Moverse hacia la derecha Moverse hacia adelante Moverse hacia atr\u00e1s Moverse en sentido horario Moverse en sentido antihorario Moverse en forma de onda. El rango normal de detecci\u00f3n est\u00e1 comprendido entre 5 y 15 cm con una velocidad del gesto de entre 60 y 600 \u00ba/s (grados por segundo) Estas son sus especificaciones t\u00e9cnicas: Tensi\u00f3n de trabajo: DC 5 V Corriente de trabajo: 50mA Potencia m\u00e1xima: 0.5 W Distancia de detecci\u00f3n: 10 cm Velocidad de gestos: 60 \u00b0/s a 600 \u00b0/s Inmunidad a la luz ambiental: <100k Lux Velocidad de comunicaci\u00f3n I2C: 400 kbit/s Temperatura de trabajo: -25 a + 65 \u00b0C En la figura siguiente vemos su aspecto. Aspecto La figura anterior muestra la posici\u00f3n correcta del sensor para reconocer los gestos implementados en los bloques En la figura siguiente podemos ver los bloques para programar el sensor de gestos. Bloques La forma de trabajar con el sensor es primero leer el gesto y luego determinar que gesto estamos haciendo. El bloque de la figura siguiente nos permite elegir entre los nueve gestos posibles. Bloque tipos de gestos","title":"Teor\u00eda"},{"location":"gestos/#programando-la-actividad","text":"En esta ocasi\u00f3n vamos a realizar dos pr\u00e1cticas, una b\u00e1sica y otra mas avanzada para as\u00ed trabajar con el sensor. Actividad b\u00e1sica Mostrar por consola el movimiento realizado en forma de n\u00famero entero por la consola. El programa de la imagen siguiente esta disponible como gesto-consola . Mostrar gesto por consola Actividad avanzada Vamos a enceder y apagar los diodos LEDs rojo y azul de la TdR STEAM respondiendo a los siguientes gestos: Encender LED rojo: Arriba Apagar LED rojo: Abajo Encender LED azul: Izquierda Apagar LED azul: Derecha El programa de la imagen siguiente esta disponible como gesto-LEDs . Encender y apagar LEDs por gestos","title":"Programando la actividad"},{"location":"gestos/#retos-de-ampliacion","text":"Gestos.R1 . Realiza un programa que en funci\u00f3n de cada uno de los nueves movimientos posibles encienda el led RGB de la TdR STEAM con un color diferente. Gestos.R2 . Amplia el programa para que se encienda del mismo color (o diferente) los LEDs de la tira.","title":"Retos de ampliaci\u00f3n"},{"location":"hsteamakers/","text":"ESP32 Plus STEAMakers \u00b6 La placa ESP32 Plus STEAMakers nos ofrece una gran cantidad de prestaciones al estar basada en un microcontrolador de 32 bits con conectividad WiFi y Bluetooth integradas en la propia placa y tambi\u00e9n un z\u00f3calo para tarjetas \u00b5SD para el almacenamiento de datos. Tambi\u00e9n dispone de conexiones para todas las entradas y salidas con posibilidad de tener la alimentaci\u00f3n adjunta y puertos de expansi\u00f3n I2C para poder conectar diferentes dispositivos directamente en la placa. En la figura siguiente vemos su aspecto. Aspecto de la placa ESP32 Plus STEAMakers La placa est\u00e1 basada en el microcontrolador ESP32-WROOM-32 y sus principales especificaciones t\u00e9cnicas son: Microcontrolador Tensilica Xtensa 32-bit LX6 a 160MHz. Conectividad WiFi 802.11 b/g/n/e/i. Conectividad Bluetooth 4.2 y modo BLE. Z\u00f3calo para tarjetas \u00b5SD. 14 entradas y salidas digitales con alimentaci\u00f3n. Conector serie hembra con alimentaci\u00f3n. Conector I2C para conectar hasta 5 dispositivos a la vez sobre la misma placa. Conector hembra I2C para conexi\u00f3n de una pantalla OLED. Bot\u00f3n de Reset. Conector de 5V Conector de 3.3V Interruptor 3.3-5V para cambiar entre estas dos tensiones en algunos pines de alimentaci\u00f3n. Entradas y salidas anal\u00f3gicas. Sensor Hall y de temperatura integrado. 2 convertidores Digital-Anal\u00f3gico (DAC) de 8 bits. 16 convertidores Anal\u00f3gico-Digital (ADC) de 12 bits. 16 canales PWM. 2 UART. 2 canales I2C. 4 canales SPI. 448Kb ROM. 520 KB SRAM. 8KB+8KB SRAM en RTC. 1kbit eFUSE. 512 bytes Memoria Flash (EEPROM). 10 sensores t\u00e1ctiles. 4 temporizadores internos de 64 bits. No est\u00e1n disponibles todas las caracter\u00edsticas del controlador ESP-WROOM-32, ya que algunos pines tienen funciones dobles y se utilizan en la placa de forma espec\u00edfica (como, por ejemplo, para controlar la tarjeta SD). Pero la mayor\u00eda de funciones se pueden utilizar, adem\u00e1s de disponer la placa ESP32 Plus STEAMakers de una mejor conexi\u00f3n de elementos debido a los pines para conectores tipo Dupont de entrada y salida, de I2C y de alimentaci\u00f3n. Adem\u00e1s, algunos pines de alimentaci\u00f3n pueden cambiar su valor (3,3V o 5V) mediante un interruptor en funci\u00f3n de nuestras necesidades. En la figura siguiente vemos un momento del video descriptivo de la placa ESP32 STEAMakers que se aloja en el canal Youtube de ArduinoBlocks . Comparativa de la ESP32 STEAMakers A continuaci\u00f3n vemos una imagen en la que se compara el potencial de la placa ESP32 Plus STEAMakers En la figura siguiente vemos los elementos que componen la placa ESP32 Plus STEAMakers: Elementos en la placa ESP32 Plus STEAMakers Relaci\u00f3n conexiones tipo UNO \u00b6 Las conexiones de la placa Imagina TDR STEAM con la placa ESP32 Plus STEAMakers son las mismas que si utilizamos cualquier placa compatible con Arduino UNO. En la tabla siguiente se establece la relaci\u00f3n entre los elementos de la placa Imagina TdR STEAM y las conexiones de una placa ESP32 Plus STEAMakers. Pin UNO Uso en TdR STEAM Descripci\u00f3n D0 Rx Pin de recepci\u00f3n Bluetooth y WiFi D1 Tx Pin de transmisi\u00f3n Bluetooth y WiFi D2 Pulsador SW1 Entrada digital D3 Conector para entrada/salida digital externa Entrada/salida digital D4 Sensor de Temperatura y Humedad DHT11 Entrada digital D5 Conector para entrada/salida digital externa Entrada/salida digital D6 Color rojo del LED RGB Salida digital D7 Pulsador SW2 Entrada digital D8 Zumbador o buzzer Salida digital D9 Color verde del LED RGB Salida digital D10 Color azul del LED RGB Salida digital D11 Sensor IR Entrada digital D12 LED rojo Salida digital D13 LED azul Salida digital A0 Potenci\u00f3metro Entrada anal\u00f3gica A1 Sensor de luz (LDR) Entrada anal\u00f3gica A2 Sensor de temperatura (LM35) Entrada anal\u00f3gica A3 Conector para entrada anal\u00f3gica externa Entrada anal\u00f3gica A4 SDA (Serial DAta.) Datos I2C A5 SCL (Serial CLock) Se\u00f1al de reloj I2C Compatibilidad y descripci\u00f3n de pines ESP32 STEAMakers \u00b6 Importante : Todos los pines IOxx son entradas y salidas digitales, algunas con m\u00e1s funciones. Utilizando la comunicaci\u00f3n WiFi no funciona el ADC2. En la tabla siguiente tenemos relacionados todos los pines entre los tipos de placas UNO, Imagina TdR STEAM y ESP32 STEAMakers. UNO TdR STEAM ESP32 Pin Funci\u00f3n Pin Funci\u00f3n Ampliaci\u00f3n D0 Rx IO03 Rx UART 0 RX D1 Tx IO01 Tx UART 0 TX D2 Pulsador SW1 IO26 ADC2 CH9 DAC2 D3 Libre IO25 ADC2 CH8 DAC1 D4 DHT11 IO17 UART 2 TX D5 Libre IO16 UART 2 RX D6 Color rojo del LED RGB IO27 ADC2 CH7 ADC2-7 / TOUCH7 D7 Pulsador SW2 IO14 ADC2 CH6 ADC2-6 / TOUCH6 D8 Zumbador o buzzer IO12 ADC2 CH5 ADC2-5 / TOUCH5 D9 Color verde del LED RGB IO13 ADC2 CH4 ADC2-4 / TOUCH4 D10 Color azul del LED RGB IO05 VSPI CSO D11 Sensor IR IO23 VSPI MOSI D12 LED rojo IO19 VSPI MISO D13 LED azul IO18 VSPI CLK GND GND AREF Reset SDA I2C IO21 SCL I2C IO22 A0 Potenci\u00f3metro IO02 ADC2 CH2 A1 Sensor de luz (LDR) IO04 ADC2 CH0 A2 Sensor de temperatura (LM35) IO36 ADC1 CH0 A3 Libre IO34 ADC1 CH6 A4 I2C IO38 A5 I2C IO39 ADC1 CH3 VIN VIN GND GND GND GND 5V 5V 3.3V 3.3V RST Reset 5V 5V IO00 \u00a1 No conectar ! - IO32 D0 - uSD - IO15 CLK - uSD - IO33 CMD - uSD - IO35 IOUT Medidor de corriente - IO37 VOUT Medidor de tensi\u00f3n","title":"Hardware ESP32 STEAMakers"},{"location":"hsteamakers/#esp32-plus-steamakers","text":"La placa ESP32 Plus STEAMakers nos ofrece una gran cantidad de prestaciones al estar basada en un microcontrolador de 32 bits con conectividad WiFi y Bluetooth integradas en la propia placa y tambi\u00e9n un z\u00f3calo para tarjetas \u00b5SD para el almacenamiento de datos. Tambi\u00e9n dispone de conexiones para todas las entradas y salidas con posibilidad de tener la alimentaci\u00f3n adjunta y puertos de expansi\u00f3n I2C para poder conectar diferentes dispositivos directamente en la placa. En la figura siguiente vemos su aspecto. Aspecto de la placa ESP32 Plus STEAMakers La placa est\u00e1 basada en el microcontrolador ESP32-WROOM-32 y sus principales especificaciones t\u00e9cnicas son: Microcontrolador Tensilica Xtensa 32-bit LX6 a 160MHz. Conectividad WiFi 802.11 b/g/n/e/i. Conectividad Bluetooth 4.2 y modo BLE. Z\u00f3calo para tarjetas \u00b5SD. 14 entradas y salidas digitales con alimentaci\u00f3n. Conector serie hembra con alimentaci\u00f3n. Conector I2C para conectar hasta 5 dispositivos a la vez sobre la misma placa. Conector hembra I2C para conexi\u00f3n de una pantalla OLED. Bot\u00f3n de Reset. Conector de 5V Conector de 3.3V Interruptor 3.3-5V para cambiar entre estas dos tensiones en algunos pines de alimentaci\u00f3n. Entradas y salidas anal\u00f3gicas. Sensor Hall y de temperatura integrado. 2 convertidores Digital-Anal\u00f3gico (DAC) de 8 bits. 16 convertidores Anal\u00f3gico-Digital (ADC) de 12 bits. 16 canales PWM. 2 UART. 2 canales I2C. 4 canales SPI. 448Kb ROM. 520 KB SRAM. 8KB+8KB SRAM en RTC. 1kbit eFUSE. 512 bytes Memoria Flash (EEPROM). 10 sensores t\u00e1ctiles. 4 temporizadores internos de 64 bits. No est\u00e1n disponibles todas las caracter\u00edsticas del controlador ESP-WROOM-32, ya que algunos pines tienen funciones dobles y se utilizan en la placa de forma espec\u00edfica (como, por ejemplo, para controlar la tarjeta SD). Pero la mayor\u00eda de funciones se pueden utilizar, adem\u00e1s de disponer la placa ESP32 Plus STEAMakers de una mejor conexi\u00f3n de elementos debido a los pines para conectores tipo Dupont de entrada y salida, de I2C y de alimentaci\u00f3n. Adem\u00e1s, algunos pines de alimentaci\u00f3n pueden cambiar su valor (3,3V o 5V) mediante un interruptor en funci\u00f3n de nuestras necesidades. En la figura siguiente vemos un momento del video descriptivo de la placa ESP32 STEAMakers que se aloja en el canal Youtube de ArduinoBlocks . Comparativa de la ESP32 STEAMakers A continuaci\u00f3n vemos una imagen en la que se compara el potencial de la placa ESP32 Plus STEAMakers En la figura siguiente vemos los elementos que componen la placa ESP32 Plus STEAMakers: Elementos en la placa ESP32 Plus STEAMakers","title":"ESP32 Plus STEAMakers"},{"location":"hsteamakers/#relacion-conexiones-tipo-uno","text":"Las conexiones de la placa Imagina TDR STEAM con la placa ESP32 Plus STEAMakers son las mismas que si utilizamos cualquier placa compatible con Arduino UNO. En la tabla siguiente se establece la relaci\u00f3n entre los elementos de la placa Imagina TdR STEAM y las conexiones de una placa ESP32 Plus STEAMakers. Pin UNO Uso en TdR STEAM Descripci\u00f3n D0 Rx Pin de recepci\u00f3n Bluetooth y WiFi D1 Tx Pin de transmisi\u00f3n Bluetooth y WiFi D2 Pulsador SW1 Entrada digital D3 Conector para entrada/salida digital externa Entrada/salida digital D4 Sensor de Temperatura y Humedad DHT11 Entrada digital D5 Conector para entrada/salida digital externa Entrada/salida digital D6 Color rojo del LED RGB Salida digital D7 Pulsador SW2 Entrada digital D8 Zumbador o buzzer Salida digital D9 Color verde del LED RGB Salida digital D10 Color azul del LED RGB Salida digital D11 Sensor IR Entrada digital D12 LED rojo Salida digital D13 LED azul Salida digital A0 Potenci\u00f3metro Entrada anal\u00f3gica A1 Sensor de luz (LDR) Entrada anal\u00f3gica A2 Sensor de temperatura (LM35) Entrada anal\u00f3gica A3 Conector para entrada anal\u00f3gica externa Entrada anal\u00f3gica A4 SDA (Serial DAta.) Datos I2C A5 SCL (Serial CLock) Se\u00f1al de reloj I2C","title":"Relaci\u00f3n conexiones tipo UNO"},{"location":"hsteamakers/#compatibilidad-y-descripcion-de-pines-esp32-steamakers","text":"Importante : Todos los pines IOxx son entradas y salidas digitales, algunas con m\u00e1s funciones. Utilizando la comunicaci\u00f3n WiFi no funciona el ADC2. En la tabla siguiente tenemos relacionados todos los pines entre los tipos de placas UNO, Imagina TdR STEAM y ESP32 STEAMakers. UNO TdR STEAM ESP32 Pin Funci\u00f3n Pin Funci\u00f3n Ampliaci\u00f3n D0 Rx IO03 Rx UART 0 RX D1 Tx IO01 Tx UART 0 TX D2 Pulsador SW1 IO26 ADC2 CH9 DAC2 D3 Libre IO25 ADC2 CH8 DAC1 D4 DHT11 IO17 UART 2 TX D5 Libre IO16 UART 2 RX D6 Color rojo del LED RGB IO27 ADC2 CH7 ADC2-7 / TOUCH7 D7 Pulsador SW2 IO14 ADC2 CH6 ADC2-6 / TOUCH6 D8 Zumbador o buzzer IO12 ADC2 CH5 ADC2-5 / TOUCH5 D9 Color verde del LED RGB IO13 ADC2 CH4 ADC2-4 / TOUCH4 D10 Color azul del LED RGB IO05 VSPI CSO D11 Sensor IR IO23 VSPI MOSI D12 LED rojo IO19 VSPI MISO D13 LED azul IO18 VSPI CLK GND GND AREF Reset SDA I2C IO21 SCL I2C IO22 A0 Potenci\u00f3metro IO02 ADC2 CH2 A1 Sensor de luz (LDR) IO04 ADC2 CH0 A2 Sensor de temperatura (LM35) IO36 ADC1 CH0 A3 Libre IO34 ADC1 CH6 A4 I2C IO38 A5 I2C IO39 ADC1 CH3 VIN VIN GND GND GND GND 5V 5V 3.3V 3.3V RST Reset 5V 5V IO00 \u00a1 No conectar ! - IO32 D0 - uSD - IO15 CLK - uSD - IO33 CMD - uSD - IO35 IOUT Medidor de corriente - IO37 VOUT Medidor de tensi\u00f3n","title":"Compatibilidad y descripci\u00f3n de pines ESP32 STEAMakers"},{"location":"htdr/","text":"Hardware TdR STEAM \u00b6 La tabla siguiente es una descripci\u00f3n del hardware TdR-STEAM. Imagen N Sensor, actuador o dispositivo externo Pin de conexi\u00f3n 1 Interface I2C o IIC SDA-A4 y SCL-A5 2 Pulsadores SW1 y SW2 D2 y D7 3 Diodos LED Azul (LED3) y Rojo (LED4) D13 y D12 4 Led RGB o neopixel D6, D9 y D10 5 Dos conectores para Entradas/Salidas digitales D3 y D5 6 Conector de comunicaciones Bluetooth y WiFi (Swich On/Off) Rx y Tx 7 Sensor de Temperatura y Humedad DHT11 D4 8 Potenci\u00f3metro giratorio de 270\u00ba A0 9 Zumbador Piezoel\u00e9ctrico o buzzer D8 10 Diodo receptor de infrarrojos (IR) D11 11 Sensor de luminosidad (LDR) A1 12 Bot\u00f3n de Reset -- 13 Conector para entrada anal\u00f3gica A3 14 Sensor de temperatura (LM35) A2","title":"Hardware TdR STEAM"},{"location":"htdr/#hardware-tdr-steam","text":"La tabla siguiente es una descripci\u00f3n del hardware TdR-STEAM. Imagen N Sensor, actuador o dispositivo externo Pin de conexi\u00f3n 1 Interface I2C o IIC SDA-A4 y SCL-A5 2 Pulsadores SW1 y SW2 D2 y D7 3 Diodos LED Azul (LED3) y Rojo (LED4) D13 y D12 4 Led RGB o neopixel D6, D9 y D10 5 Dos conectores para Entradas/Salidas digitales D3 y D5 6 Conector de comunicaciones Bluetooth y WiFi (Swich On/Off) Rx y Tx 7 Sensor de Temperatura y Humedad DHT11 D4 8 Potenci\u00f3metro giratorio de 270\u00ba A0 9 Zumbador Piezoel\u00e9ctrico o buzzer D8 10 Diodo receptor de infrarrojos (IR) D11 11 Sensor de luminosidad (LDR) A1 12 Bot\u00f3n de Reset -- 13 Conector para entrada anal\u00f3gica A3 14 Sensor de temperatura (LM35) A2","title":"Hardware TdR STEAM"},{"location":"importante/","text":"Informaci\u00f3n muy importante \u00b6 Potenci\u00f3metro \u00b6 Como tambi\u00e9n se indicar\u00e1 cuando hablemos espec\u00edficamente de potenci\u00f3metro, es muy importante que el mismo est\u00e9 totalmente girado a la izquierda como est\u00e1 marcado en la imagen siguiente con el punto de color. El potenciometro de la TdR STEAM El motivo es que el potenci\u00f3metro comparte la conexi\u00f3n A0 (GPIO02) con el sistema de grabaci\u00f3n del programa y si el mismo no est\u00e1 en su posici\u00f3n de cero resistencia se producir\u00e1 un error en el env\u00edo del programa a la placa porque se entender\u00e1 que los pines de transmisi\u00f3n est\u00e1n ocupados con otra tarea. Connector \u00b6 Tambi\u00e9n es muy importante que el Connector est\u00e9 abierto siempre. Se sugiere acostumbrarse a seguir la siguiente secuencia de conexiones: Conectar la placa ESP32 Plus STEAMakers al puerto USB del ordenador. Poner en ejecuci\u00f3n ArduinoBlocks Connector. Loguearse en ArduinoBlocks y aparecer\u00e1 el puerto asignado, como vemos en la figura siguiente. Puerto asignado Sensores integrados. Energ\u00eda \u00b6 La placa ESP32 Plus STEAMakers se basa en el microcontrolador ESP32-WROOM-32 que dispone de dos sensores internos. Se trata de un sensor de efecto hall y un sensor de temperatura. Con el sensor de efecto hall detectamos campos magn\u00e9ticos en la proximidad de la placa y con el de temperatura podemos medir y controlar la temperatura a la que se encuentra el procesador de la placa. La placa ESP32 Plus STEAMakers lleva implementado un medidor de tensi\u00f3n e intensidad con el que podemos saber la tensi\u00f3n de alimentaci\u00f3n en todo momento. Si la tensi\u00f3n de alimentaci\u00f3n baja de aproximadamente 4,8V la placa no funcionar\u00e1 correctamente (sobre todo la transmisi\u00f3n WiFi). Es recomendable realizar una verificaci\u00f3n de la tensi\u00f3n que est\u00e1 entregando el puerto USB del ordenador. Si la tensi\u00f3n no es pr\u00f3xima a 5V deberemos cambiar el cable USB, alimentar el puerto USB de forma externa o alimentar la placa con una fuente de alimentaci\u00f3n. Es decir, dispone de un sistema para poder medir el consumo de energ\u00eda. Los bloques para trabajar con estos sensores est\u00e1n en 'Sensores`, entrada 'Integrados', y son los que vemos en la figura siguiente: Sensores integrados WiFi \u00b6 Tambi\u00e9n hay que tener en cuenta que cuando utilizamos la comunicaci\u00f3n mediante WiFi deja de funcionar el ADC2, por lo que en la placa Imagina TDR STEAM no funcionar\u00e1n ni el potenci\u00f3metro (A0) ni la LDR (A1). Actividades \u00b6 A1. Leer valor de tensi\u00f3n de alimentaci\u00f3n \u00b6 Un programa para verificar la tensi\u00f3n de alimentaci\u00f3n de la placa ESP32 Plus STEAMakers lo vemos en la figura siguiente: Medir la tensi\u00f3n de alimentaci\u00f3n Que nos arroja un resultado en la consola como el que vemos en la figura siguiente: Consola del programa medir la tensi\u00f3n de alimentaci\u00f3n A.2. Graficar todos los par\u00e1metros del 'Medidor de energ\u00eda' \u00b6 El programa SP-medidor-energia de la figura siguiente realiza la captura en variables de los cuatro par\u00e1metros disponibles y los env\u00eda al Serial Plotter. Para modificar el valor de los mismos se han creado las funciones encender y apagar que encienden y apagan los diodos LEDs de la TdR STEAM y de la tira de 8 lEDs. Programa Serial Plotter En la figura siguiente vemos el resultado de forma gr\u00e1fica. Serial Plotter A.3. Sensores internos \u00b6 Un programa como el de la figura siguiente nos va a mostrar por consola los valores le\u00eddos por los sensores internos. Sensores internos El resultado en consola lo vemos en la figura siguiente: Consola sensores internos Retos \u00b6 R1 . Realizar la actividad A2 mostrando los datos por consola. R2 . Realizar la actividad A2 mostrando los datos en la LCD. R3 . Hacer una captura de datos en formato CSV de alguno de los par\u00e1metros del 'Medidor de energ\u00eda'.","title":"Informaci\u00f3n importante"},{"location":"importante/#informacion-muy-importante","text":"","title":"Informaci\u00f3n muy importante"},{"location":"importante/#potenciometro","text":"Como tambi\u00e9n se indicar\u00e1 cuando hablemos espec\u00edficamente de potenci\u00f3metro, es muy importante que el mismo est\u00e9 totalmente girado a la izquierda como est\u00e1 marcado en la imagen siguiente con el punto de color. El potenciometro de la TdR STEAM El motivo es que el potenci\u00f3metro comparte la conexi\u00f3n A0 (GPIO02) con el sistema de grabaci\u00f3n del programa y si el mismo no est\u00e1 en su posici\u00f3n de cero resistencia se producir\u00e1 un error en el env\u00edo del programa a la placa porque se entender\u00e1 que los pines de transmisi\u00f3n est\u00e1n ocupados con otra tarea.","title":"Potenci\u00f3metro"},{"location":"importante/#connector","text":"Tambi\u00e9n es muy importante que el Connector est\u00e9 abierto siempre. Se sugiere acostumbrarse a seguir la siguiente secuencia de conexiones: Conectar la placa ESP32 Plus STEAMakers al puerto USB del ordenador. Poner en ejecuci\u00f3n ArduinoBlocks Connector. Loguearse en ArduinoBlocks y aparecer\u00e1 el puerto asignado, como vemos en la figura siguiente. Puerto asignado","title":"Connector"},{"location":"importante/#sensores-integrados-energia","text":"La placa ESP32 Plus STEAMakers se basa en el microcontrolador ESP32-WROOM-32 que dispone de dos sensores internos. Se trata de un sensor de efecto hall y un sensor de temperatura. Con el sensor de efecto hall detectamos campos magn\u00e9ticos en la proximidad de la placa y con el de temperatura podemos medir y controlar la temperatura a la que se encuentra el procesador de la placa. La placa ESP32 Plus STEAMakers lleva implementado un medidor de tensi\u00f3n e intensidad con el que podemos saber la tensi\u00f3n de alimentaci\u00f3n en todo momento. Si la tensi\u00f3n de alimentaci\u00f3n baja de aproximadamente 4,8V la placa no funcionar\u00e1 correctamente (sobre todo la transmisi\u00f3n WiFi). Es recomendable realizar una verificaci\u00f3n de la tensi\u00f3n que est\u00e1 entregando el puerto USB del ordenador. Si la tensi\u00f3n no es pr\u00f3xima a 5V deberemos cambiar el cable USB, alimentar el puerto USB de forma externa o alimentar la placa con una fuente de alimentaci\u00f3n. Es decir, dispone de un sistema para poder medir el consumo de energ\u00eda. Los bloques para trabajar con estos sensores est\u00e1n en 'Sensores`, entrada 'Integrados', y son los que vemos en la figura siguiente: Sensores integrados","title":"Sensores integrados. Energ\u00eda"},{"location":"importante/#wifi","text":"Tambi\u00e9n hay que tener en cuenta que cuando utilizamos la comunicaci\u00f3n mediante WiFi deja de funcionar el ADC2, por lo que en la placa Imagina TDR STEAM no funcionar\u00e1n ni el potenci\u00f3metro (A0) ni la LDR (A1).","title":"WiFi"},{"location":"importante/#actividades","text":"","title":"Actividades"},{"location":"importante/#a1-leer-valor-de-tension-de-alimentacion","text":"Un programa para verificar la tensi\u00f3n de alimentaci\u00f3n de la placa ESP32 Plus STEAMakers lo vemos en la figura siguiente: Medir la tensi\u00f3n de alimentaci\u00f3n Que nos arroja un resultado en la consola como el que vemos en la figura siguiente: Consola del programa medir la tensi\u00f3n de alimentaci\u00f3n","title":"A1. Leer valor de tensi\u00f3n de alimentaci\u00f3n"},{"location":"importante/#a2-graficar-todos-los-parametros-del-medidor-de-energia","text":"El programa SP-medidor-energia de la figura siguiente realiza la captura en variables de los cuatro par\u00e1metros disponibles y los env\u00eda al Serial Plotter. Para modificar el valor de los mismos se han creado las funciones encender y apagar que encienden y apagan los diodos LEDs de la TdR STEAM y de la tira de 8 lEDs. Programa Serial Plotter En la figura siguiente vemos el resultado de forma gr\u00e1fica. Serial Plotter","title":"A.2. Graficar todos los par\u00e1metros del 'Medidor de energ\u00eda'"},{"location":"importante/#a3-sensores-internos","text":"Un programa como el de la figura siguiente nos va a mostrar por consola los valores le\u00eddos por los sensores internos. Sensores internos El resultado en consola lo vemos en la figura siguiente: Consola sensores internos","title":"A.3. Sensores internos"},{"location":"importante/#retos","text":"R1 . Realizar la actividad A2 mostrando los datos por consola. R2 . Realizar la actividad A2 mostrando los datos en la LCD. R3 . Hacer una captura de datos en formato CSV de alguno de los par\u00e1metros del 'Medidor de energ\u00eda'.","title":"Retos"},{"location":"matriz8x8/","text":"Matriz de 8x8 LEDs \u00b6 Antes de nada vamos a indicar que en este conjunto de actividades denominado \"Otros dispositivos I2C\" vamos a conectar mas elementos I2C a nuestra placa de control y para la expansi\u00f3n del conector I2C que integra la placa TdR STEAM utilizamos la shield de conversi\u00f3n I2C que vemos en la imagen siguiente. Hub I2C El conexionado entre la placa TdR STEAM y la shield la tenemos que hacer con un un cable formado por cuatro conductores que en un extremo lleva un conector JST Macho de 4 pines (TdR) y en el otro un conector plano hembra tambi\u00e9n de 4 pines de tipo dupont. El conector JST solamente puede colocarse en una posici\u00f3n y por lo tanto no hay posibilidad de error. Para colocar el conector plano nos fijamos en el nombre de uno de sus extremos en la shield y lo hacemos coincidir con el cable que corresponda en el conector JST, lo colocamos en su sitio y tenemos resuelta la conexi\u00f3n. Enunciado \u00b6 En esta actividad el objetivo es conocer la LEDMatrix 8x8 o tambi\u00e9n llamada matriz de LEDs. Es una pantalla en la que podemos programar diferentes s\u00edmbolos o elementos, como: caras, iconos, letras... Hay opciones predise\u00f1adas desde ArduinoBlocks y tambi\u00e9n, existe la opci\u00f3n de crearlos personalizados. Teor\u00eda \u00b6 Una distribuci\u00f3n de 8x8 LEDs en forma de matriz permite crear una pantalla peque\u00f1a que tiene 64 LEDs con el aspecto de la Figura siguiente y se conecta al puerto de comunicaci\u00f3n I2C. [Aspecto de la matriz de 8x8 Este tipo de matrices son 'multiplexadas', por lo que para controlar 64 LED necesitas 16 pines y eso son muchos pines aunque hay chips de controladores como el MAX7219 que pueden controlar una matriz, pero a\u00fan as\u00ed hay mucho cableado que configurar y ocupan muchos pines. Para solucionar esto se utiliza un chip de control que tiene un reloj incorporado para multiplexar la pantalla. Adem\u00e1s del m\u00f3dulo utiliza una fuente de corriente constante que permite obtener un color uniforme y brillante de todos los diodos. El conjunto forma una matriz de 8x8 que se controla a trav\u00e9s de una interfaz I2C. Sus principales caracter\u00edsticas son: Matriz de LEDs de 8 filas y 8 columnas Direccionada por un chip HT16K33 Conexi\u00f3n tipo I2C Tensi\u00f3n de alimentaci\u00f3n: 5V Frecuencia de trabajo: 400KHz Potencia de entrada: 2.5W Corriente de entrada: 500mA Tambi\u00e9n existen matrices que son direccionables , como la que vemos en la imagen siguiente: Aspecto de la matriz de 8x8 direccionable El dispositivo dispone de su propio men\u00fa de bloques y de un dise\u00f1ador de mapas de bits similar al visto para los s\u00edmbolos de la LCD que podemos apreciar en la figura siguiente: Bloques para la matriz 8x8 y dise\u00f1ador Programando la actividad \u00b6 Vamos a hacer un programa que cuando pulsemos el bot\u00f3n SW1 de la TdR STEAM la matriz muestre una carita sonriente, cuando pulsamos el SW2 una carita triste y si no pulsamos ninguno que nos muestre un coraz\u00f3n latiendo. El programa de la imagen siguiente esta disponible como Caritas . Caritas y coraz\u00f3n latiendo","title":"Matriz de LEDs"},{"location":"matriz8x8/#matriz-de-8x8-leds","text":"Antes de nada vamos a indicar que en este conjunto de actividades denominado \"Otros dispositivos I2C\" vamos a conectar mas elementos I2C a nuestra placa de control y para la expansi\u00f3n del conector I2C que integra la placa TdR STEAM utilizamos la shield de conversi\u00f3n I2C que vemos en la imagen siguiente. Hub I2C El conexionado entre la placa TdR STEAM y la shield la tenemos que hacer con un un cable formado por cuatro conductores que en un extremo lleva un conector JST Macho de 4 pines (TdR) y en el otro un conector plano hembra tambi\u00e9n de 4 pines de tipo dupont. El conector JST solamente puede colocarse en una posici\u00f3n y por lo tanto no hay posibilidad de error. Para colocar el conector plano nos fijamos en el nombre de uno de sus extremos en la shield y lo hacemos coincidir con el cable que corresponda en el conector JST, lo colocamos en su sitio y tenemos resuelta la conexi\u00f3n.","title":"Matriz de 8x8 LEDs"},{"location":"matriz8x8/#enunciado","text":"En esta actividad el objetivo es conocer la LEDMatrix 8x8 o tambi\u00e9n llamada matriz de LEDs. Es una pantalla en la que podemos programar diferentes s\u00edmbolos o elementos, como: caras, iconos, letras... Hay opciones predise\u00f1adas desde ArduinoBlocks y tambi\u00e9n, existe la opci\u00f3n de crearlos personalizados.","title":"Enunciado"},{"location":"matriz8x8/#teoria","text":"Una distribuci\u00f3n de 8x8 LEDs en forma de matriz permite crear una pantalla peque\u00f1a que tiene 64 LEDs con el aspecto de la Figura siguiente y se conecta al puerto de comunicaci\u00f3n I2C. [Aspecto de la matriz de 8x8 Este tipo de matrices son 'multiplexadas', por lo que para controlar 64 LED necesitas 16 pines y eso son muchos pines aunque hay chips de controladores como el MAX7219 que pueden controlar una matriz, pero a\u00fan as\u00ed hay mucho cableado que configurar y ocupan muchos pines. Para solucionar esto se utiliza un chip de control que tiene un reloj incorporado para multiplexar la pantalla. Adem\u00e1s del m\u00f3dulo utiliza una fuente de corriente constante que permite obtener un color uniforme y brillante de todos los diodos. El conjunto forma una matriz de 8x8 que se controla a trav\u00e9s de una interfaz I2C. Sus principales caracter\u00edsticas son: Matriz de LEDs de 8 filas y 8 columnas Direccionada por un chip HT16K33 Conexi\u00f3n tipo I2C Tensi\u00f3n de alimentaci\u00f3n: 5V Frecuencia de trabajo: 400KHz Potencia de entrada: 2.5W Corriente de entrada: 500mA Tambi\u00e9n existen matrices que son direccionables , como la que vemos en la imagen siguiente: Aspecto de la matriz de 8x8 direccionable El dispositivo dispone de su propio men\u00fa de bloques y de un dise\u00f1ador de mapas de bits similar al visto para los s\u00edmbolos de la LCD que podemos apreciar en la figura siguiente: Bloques para la matriz 8x8 y dise\u00f1ador","title":"Teor\u00eda"},{"location":"matriz8x8/#programando-la-actividad","text":"Vamos a hacer un programa que cuando pulsemos el bot\u00f3n SW1 de la TdR STEAM la matriz muestre una carita sonriente, cuando pulsamos el SW2 una carita triste y si no pulsamos ninguno que nos muestre un coraz\u00f3n latiendo. El programa de la imagen siguiente esta disponible como Caritas . Caritas y coraz\u00f3n latiendo","title":"Programando la actividad"},{"location":"necesidades/","text":"Lo que vamos a necesitar \u00b6 Relacionamos el equipamiento m\u00ednimo que se requiere para comenzar a trabajar y se recomiendan algunas cosas mas. Software \u00b6 Para llevar a cabo la programaci\u00f3n de los retos es necesario estar registrado en ArduinoBlocks y se recomienda hacerlo con un nombre real para posteriormente facilitar la localizaci\u00f3n si es necesaria y se tiene que hacer con un correo real pues se necesita confirmaci\u00f3n para crear la cuenta. La tarea es sencilla y est\u00e1 perfectamente descrita en el Free Book (online & updated) que podemos encontrar en los recursos de la plataforma www.arduinoblocks.com . Creamos un \"nuevo usuario\" utilizando para ello una cuenta de correo v\u00e1lida donde vamos a recibir un correo de confirmaci\u00f3n para activarla. Ya estamos en condiciones de crear nuestros propios proyectos en la plataforma como veremos mas adelante. Crear un nuevo proyecto Descarga e instala en tu ordenador y para tu sistema operativo la \u00faltima versi\u00f3n de ArduinoBlocks - Connector . Este programa vamos a necesitarlo para poder comunicar nuestra placa con la plataforma a trav\u00e9s del puerto USB de nuestro ordenador. El programa debe estar en ejecuci\u00f3n, minimizado para que no nos moleste, siempre que queramos grabar un programa y tiene el aspecto que vemos en la figura siguiente: ArduinoBlocks Connector Hardware imprescindible \u00b6 Una placa Imagina TdR STEAM versi\u00f3n 2.0 como la de la imagen siguiente: Shield TdR-STEAM V2.0 Una placa ESP32 Plus STEAMakers. ESP32 Plus STEAMakers Hardware recomendado \u00b6 A continuaci\u00f3n exponemos el material adicional que vamos a emplear en esta colecci\u00f3n de retos que no es otro que el incluido en el Kit Imagina TdR STEAM comercializado por la empresa INNOVA DIDACTIC . Mando de control remoto por infrarojos para utilizar en conjunto con el sensor de infrarojos integrado en la placa TdR-STEAM. Mando a distancia por IR Pantalla LCD 1602 IIC (I2C) de 2 l\u00ednea de 16 caracteres. Nos va a permitir mostrar mensajes de texto e ir\u00e1 conectada al conector I2C de la placa TdR-STEAM. LCD 1602 I2C Sensor de sonido anal\u00f3gico (con potenciometro). Se utiliza b\u00e1sicamente para detectar el nivel sonoro ambiental. El potenciometro permite ajustar el nivel de ganancia. Sensor de sonido anal\u00f3gico Caja contenedor imprimible 3D \u00b6 Partes \u00b6 La caja est\u00e1 compuesta de una base, una tapa, tres tornillos y un destornillador. La base con indicaci\u00f3n de donde va a ir cada elemento la vemos en la imagen siguiente: Base o caja El aspecto de la tapa lo tenemos en la imagen siguiente, donde podemos observar el orificio estriado que servir\u00e1 para colocar el destornillador cuando finalicemos el montaje. Tapa Finalmente en la imagen siguiente podemos ver el aspecto de los tres tornillos que sujetan la tapa a la caja y el del destornillador. Tornillos y destornillador Archivos stl listos para descargar e imprimir \u00b6 Los archivos de dise\u00f1o original son los siguientes: Archivo STL de la caja: caja.stl Archivo STL de la tapa: tapa.stl Archivo STL del tornillo: tornillo.stl Archivo STL del destornillador: destornillador.stl Todos los archivos en un zip: caja-TdR-STEAM.zip Algunos de los archivos anteriores se han modificado para mejorar el dise\u00f1o en algunos aspectos y sobre todo para dejar libre un hueco en la base que haga accesible la tarjeta uSD. Los archivos modificados son los siguientes: Archivo FreeCAD con las modificaciones: modificaciones.FCStd Archivo STL de la caja modificada: caja.stl Archivo STL de la tapa: tapa.stl Archivo STL del tornillo: tornillo.stl Archivo STL del destornillador: destornillador.stl Todos los archivos en un zip: caja-TdR-STEAM.zip Pasos de montaje \u00b6 Las im\u00e1genes siguiente se corresponden con el montaje y los elementos originales utilizando una placa tipo UNO pero son perfectamente v\u00e1lidas puesto que son los mismos elementos y la placa TDRSTEAM tiene formato UNO. Paso 1 . Colocamos la TdR STEAM sobre la placa UNO pasando el cable de cuatro hilos entre ambas y colocando el conector JST de 4 pines en la TdR STEAM (este conector solamente entra en una posici\u00f3n) para obtener algo similar a la imagen siguiente: Montaje de la TdR STEAM sobre UNO conectando el I2C Paso 2 . Conectamos la LCD mediante el conector plano de 4 pines asegurando que el cable negro va al pin marcado como GND. Hay que tener precauci\u00f3n con la orientaci\u00f3n de este conector pues es reversible. El resultado debe ser similar al siguiente: Montaje de la LCD Paso 3 . En la imagen siguiente se ven los elementos anteriores colocados en su lugar. Montaje de Shield+UNO y LCD en la base Paso 4 . Conectamos un cable de tres hilos al micr\u00f3fono teniendo en cuenta que el cable negro va al terminal marcado con una G y el otro extremo del cable lo colocamos en el conector JST de 3 pines marcado con A3. Pasamos los cables por debajo de la LCD y el resultado ser\u00e1 algo similar a lo siguiente: Montaje de micr\u00f3fono Paso 5 . Colocamos el teclado en su lugar. Colocaci\u00f3n del mando a distancia Paso 6 . Finalmente colocamos la tapa y atornillamos cada tornillo en su tuerca, los apretamos con ayuda del destornillador y colocamos este en su alojamiento. Tendremos finalizada la colocaci\u00f3n de elementos en la caja, tal y como vemos a continuaci\u00f3n: Montaje finalizado","title":"Lo que vamos a necesitar"},{"location":"necesidades/#lo-que-vamos-a-necesitar","text":"Relacionamos el equipamiento m\u00ednimo que se requiere para comenzar a trabajar y se recomiendan algunas cosas mas.","title":"Lo que vamos a necesitar"},{"location":"necesidades/#software","text":"Para llevar a cabo la programaci\u00f3n de los retos es necesario estar registrado en ArduinoBlocks y se recomienda hacerlo con un nombre real para posteriormente facilitar la localizaci\u00f3n si es necesaria y se tiene que hacer con un correo real pues se necesita confirmaci\u00f3n para crear la cuenta. La tarea es sencilla y est\u00e1 perfectamente descrita en el Free Book (online & updated) que podemos encontrar en los recursos de la plataforma www.arduinoblocks.com . Creamos un \"nuevo usuario\" utilizando para ello una cuenta de correo v\u00e1lida donde vamos a recibir un correo de confirmaci\u00f3n para activarla. Ya estamos en condiciones de crear nuestros propios proyectos en la plataforma como veremos mas adelante. Crear un nuevo proyecto Descarga e instala en tu ordenador y para tu sistema operativo la \u00faltima versi\u00f3n de ArduinoBlocks - Connector . Este programa vamos a necesitarlo para poder comunicar nuestra placa con la plataforma a trav\u00e9s del puerto USB de nuestro ordenador. El programa debe estar en ejecuci\u00f3n, minimizado para que no nos moleste, siempre que queramos grabar un programa y tiene el aspecto que vemos en la figura siguiente: ArduinoBlocks Connector","title":"Software"},{"location":"necesidades/#hardware-imprescindible","text":"Una placa Imagina TdR STEAM versi\u00f3n 2.0 como la de la imagen siguiente: Shield TdR-STEAM V2.0 Una placa ESP32 Plus STEAMakers. ESP32 Plus STEAMakers","title":"Hardware imprescindible"},{"location":"necesidades/#hardware-recomendado","text":"A continuaci\u00f3n exponemos el material adicional que vamos a emplear en esta colecci\u00f3n de retos que no es otro que el incluido en el Kit Imagina TdR STEAM comercializado por la empresa INNOVA DIDACTIC . Mando de control remoto por infrarojos para utilizar en conjunto con el sensor de infrarojos integrado en la placa TdR-STEAM. Mando a distancia por IR Pantalla LCD 1602 IIC (I2C) de 2 l\u00ednea de 16 caracteres. Nos va a permitir mostrar mensajes de texto e ir\u00e1 conectada al conector I2C de la placa TdR-STEAM. LCD 1602 I2C Sensor de sonido anal\u00f3gico (con potenciometro). Se utiliza b\u00e1sicamente para detectar el nivel sonoro ambiental. El potenciometro permite ajustar el nivel de ganancia. Sensor de sonido anal\u00f3gico","title":"Hardware recomendado"},{"location":"necesidades/#caja-contenedor-imprimible-3d","text":"","title":"Caja contenedor imprimible 3D"},{"location":"necesidades/#partes","text":"La caja est\u00e1 compuesta de una base, una tapa, tres tornillos y un destornillador. La base con indicaci\u00f3n de donde va a ir cada elemento la vemos en la imagen siguiente: Base o caja El aspecto de la tapa lo tenemos en la imagen siguiente, donde podemos observar el orificio estriado que servir\u00e1 para colocar el destornillador cuando finalicemos el montaje. Tapa Finalmente en la imagen siguiente podemos ver el aspecto de los tres tornillos que sujetan la tapa a la caja y el del destornillador. Tornillos y destornillador","title":"Partes"},{"location":"necesidades/#archivos-stl-listos-para-descargar-e-imprimir","text":"Los archivos de dise\u00f1o original son los siguientes: Archivo STL de la caja: caja.stl Archivo STL de la tapa: tapa.stl Archivo STL del tornillo: tornillo.stl Archivo STL del destornillador: destornillador.stl Todos los archivos en un zip: caja-TdR-STEAM.zip Algunos de los archivos anteriores se han modificado para mejorar el dise\u00f1o en algunos aspectos y sobre todo para dejar libre un hueco en la base que haga accesible la tarjeta uSD. Los archivos modificados son los siguientes: Archivo FreeCAD con las modificaciones: modificaciones.FCStd Archivo STL de la caja modificada: caja.stl Archivo STL de la tapa: tapa.stl Archivo STL del tornillo: tornillo.stl Archivo STL del destornillador: destornillador.stl Todos los archivos en un zip: caja-TdR-STEAM.zip","title":"Archivos stl listos para descargar e imprimir"},{"location":"necesidades/#pasos-de-montaje","text":"Las im\u00e1genes siguiente se corresponden con el montaje y los elementos originales utilizando una placa tipo UNO pero son perfectamente v\u00e1lidas puesto que son los mismos elementos y la placa TDRSTEAM tiene formato UNO. Paso 1 . Colocamos la TdR STEAM sobre la placa UNO pasando el cable de cuatro hilos entre ambas y colocando el conector JST de 4 pines en la TdR STEAM (este conector solamente entra en una posici\u00f3n) para obtener algo similar a la imagen siguiente: Montaje de la TdR STEAM sobre UNO conectando el I2C Paso 2 . Conectamos la LCD mediante el conector plano de 4 pines asegurando que el cable negro va al pin marcado como GND. Hay que tener precauci\u00f3n con la orientaci\u00f3n de este conector pues es reversible. El resultado debe ser similar al siguiente: Montaje de la LCD Paso 3 . En la imagen siguiente se ven los elementos anteriores colocados en su lugar. Montaje de Shield+UNO y LCD en la base Paso 4 . Conectamos un cable de tres hilos al micr\u00f3fono teniendo en cuenta que el cable negro va al terminal marcado con una G y el otro extremo del cable lo colocamos en el conector JST de 3 pines marcado con A3. Pasamos los cables por debajo de la LCD y el resultado ser\u00e1 algo similar a lo siguiente: Montaje de micr\u00f3fono Paso 5 . Colocamos el teclado en su lugar. Colocaci\u00f3n del mando a distancia Paso 6 . Finalmente colocamos la tapa y atornillamos cada tornillo en su tuerca, los apretamos con ayuda del destornillador y colocamos este en su alojamiento. Tendremos finalizada la colocaci\u00f3n de elementos en la caja, tal y como vemos a continuaci\u00f3n: Montaje finalizado","title":"Pasos de montaje"},{"location":"neopixel/","text":"LEDs RGB direccionables \u00b6 Comunmente se les conoce como Neopixel, que es una marca registrada por Adafruit Industries . Cada LED que componen la tira o matriz tiene los siguientes cuatro pines: Alimentaci\u00f3n VDD: 5V Tierra: GND DI (Date Input): pin para recibir informaci\u00f3n DO (Date Output): pin para enviar inforamci\u00f3n Cada uno de los LEDs es direccionable de manera individual gracias al circuito electr\u00f3nico que incluyen que, con una memoria de un byte por color, que es un circuito l\u00f3gico. Los tipos mas comunes son el SK6812, WS2811 o, el mas habitual de todos, el WS2812 cuyo datasheet tenemos en el enlace. Enunciado \u00b6 Realizaremos varios ejemplos de uso utilizando la tira de 8 LEDs que incluye el kit, aunque se realiza un estudio te\u00f3rico amplio que ser\u00e1 \u00fatil para cualquier tira o matriz de de LEDs RGB direccionables. Teor\u00eda \u00b6 El WS2812B incluye un oscilador interno de precisi\u00f3n y un circuito de control de corriente constante programable de 12 V, lo que garantiza de manera efectiva que la intensidad del color sea consistente. El protocolo de transferencia de datos utiliza un \u00fanico modo de comunicaci\u00f3n de multiplexado NZR. En la figura siguiente vemos el aspecto de un diodo LED RGB individual en formato inserci\u00f3n y SMD. Aspecto de un diodo LED RGB Aspectos previos \u00b6 Para transmitir informaci\u00f3n digital esta se debe sincronizar mediante una convenci\u00f3n especial, la codificaci\u00f3n. Dos dispositivos llevan una comunicaci\u00f3n por cable convirtiendo la informaci\u00f3n a transmitir en un flujo de bits (0 y 1) o \"Dates\" que se suele nombrar con la letra D y que va acompa\u00f1ada de una se\u00f1al de reloj para sincronizar las transmisiones. La forma convencional de transmisi\u00f3n digital se componen de una l\u00ednea de datos mas una l\u00ednea de reloj. Ahora bien, cualquier ligera desviaci\u00f3n en la longitud de estas l\u00edneas har\u00e1 que el receptor no cumpla con el tiempo de establecimiento del muestreo de datos, originando errores en los datos. La forma de asegurar que esas l\u00edneas son id\u00e9nticas es que sean la misma l\u00ednea, lo que hace que aparezcan c\u00f3digos que fusionan los datos y el reloj, entre los que est\u00e1n los c\u00f3digo RZ, NRZ y NRZI que vamos a ver someramente a continuaci\u00f3n. Codificaci\u00f3n RZ . El acr\u00f3nimo de de \"Return Zero\" o retorno cero y su caracter\u00edstica es que se transmiten bits de datos dentro de cada periodo de la se\u00f1al. En la figura siguiente los datos se representan en rojo y vemos que ocupan una parte del periodo T, siendo cero el resto del tiempo. Este sistema se denomina RZ unipolar o retorno a cero unipolar y como se observa en la figura un nivel bajo indica 0 y un nivel positivo indica 1. C\u00f3digo RZ unipolar El c\u00f3digo de retorno a cero se divide en un c\u00f3digo de retorno a cero unipolar y un c\u00f3digo de retorno a cero bipolar en el que el nivel alto indica 1 y el nivel negativo o, tal y como vemos en la figura siguiente: C\u00f3digo RZ bipolar Codificaci\u00f3n NRZ . El acr\u00f3nimo es de \"Not Return Zero\" o c\u00f3digo sin retorno a cero y se diferencia del RZ en que no necesita retornar a cero. En la figura siguiente vemos gr\u00e1ficamente el c\u00f3digo. C\u00f3digo NRZ En el datasheet estos c\u00f3digo se denominan T0H y T0L. El funcionamiento de una agrupaci\u00f3n en cascada como la de la figura siguiente se puede resumir diciendo que: el circuito integrado de cada LED puede almacenar 3 bytes (24 bits), un byte para cada color. Solo el primer LED est\u00e1 conectado al Pin de control, en este caso, un pin digital de nuestra placa, que enviar\u00e1 la cadena de todos los colores seg\u00fan el n\u00famero de pixeles que est\u00e9n conectados y a su vez el primer LED recibir\u00e1 la informaci\u00f3n de todos los colores uno tras otro. La informaci\u00f3n se transmite de un LED a otro porque cuando un LED recibe 3 bytes nuevos de informaci\u00f3n entrega al siguiente LED los 3 bytes que conten\u00eda anteriormente, de esta manera cuando la placa con el programa termina de mandar todos los colores por el pin de datos el primer LED habr\u00eda recibido y enviado todos los colores para quedarse finalmente con el color que le corresponde y as\u00ed el resto de LEDs. De esta forma una tira de LEDs RGB direccionables es un dispositivo digital de salida, es decir su funcionamiento consiste en recibir la informaci\u00f3n del color a mostrar y mostrarlo. Conexi\u00f3n en cascada Aspectos t\u00e9cnicos \u00b6 Los LEDs RGB direccionables se suelen suministrar en tiras de diferentes longitudes y con distinto n\u00famero de LEDs y a veces se dispone la tira en forma de matriz. En la figura siguiente vemos el aspecto de algunos tipos. Tira y matriz de LEDs RGB Tienen 3 cables asociados a un conector y dos cables extra para a\u00f1adir alimentaci\u00f3n externa cuando es necesario porque la placa de control no entrega suficiente corriente para alimentar al conjunto. Cuando se trabaja con una tira de pocos LEDs no es necesario a\u00f1adir esta alimentaci\u00f3n externa, ya que placas como Arduino UNO o la ESP32 STEAMakers pueden suministrar la corriente que necesitan. Para los ejemplos mas b\u00e1sicos vamos a utilizar una tira de 8 LEDs como la que vemos en la figura siguiente: Tira de ocho LEDs RGB Cualquier tira de LEDs RGB (sea cual sea su disposici\u00f3n en l\u00ednea, como matriz, etc) debe utilizarse siempre en la direcci\u00f3n que marca el terminal hembra como entrada y el conector macho como salida. Las podemos ir conectando entre s\u00ed pero siempre respetando este sentido de la tira. Junto a cada led RGB est\u00e1 indicada la direcci\u00f3n de la tira mediante un tri\u00e1ngulo y tambi\u00e9n a qu\u00e9 pin debe ir conectado cada cable. Vemos +5V que corresponde a Vcc, GND, y en medio que pone Din o D0 que corresponde al pin digital de entrada de datos que debemos conectar al pin de salida de la placa de control. Tambi\u00e9n las podemos cortar por cualquiera de las l\u00edneas existentes entre cada uno de los LEDs y que est\u00e1 marcado con la l\u00ednea de corte. El corte debe hacerse dejando la mitad del pad de cobre a un lado y otro de la l\u00ednea y as\u00ed poder unir despu\u00e9s entre ellas con conectores especializados o sold\u00e1ndolas. Direcci\u00f3n y l\u00ednea de corte Bloques en ArduinoBlocks \u00b6 En la figura siguiente vemos el men\u00fa bloques disponible en 'Visualizaci\u00f3n' en su entrada 'NeoPixel'. Bloques LEDs RGB direccionables Iniciar : Este bloque se debe definir dentro del bloque \u201cinicializar\u201d o \u201csetup\u201d para indicar la configuraci\u00f3n los LEDs conectados. Tenemos que indicar los siguientes par\u00e1metros: Frecuencia : 800Khz / 400Khz, es la velocidad del \u201cbistream\u201d con los datos que se env\u00edan a trav\u00e9s del pin DIN con los datos para cada neop\u00edxel. Una tasa de 400khz ya permitir\u00eda controlar m\u00e1s de 1000 leds con un refresco de 30fps. N\u00famero de p\u00edxeles : indica el n\u00famero de p\u00edxeles conectados en serie, si conectamos una tira de 100 LEDs lo indicaremos en este valor. Pin : es el pin a trav\u00e9s el cual la placa de control enviar\u00e1 y controlar\u00e1 los datos de los LEDs. Establecer brillo : Valor entre 0 y 255 que establece con que potencia emiten luz los LEDs. Limpiar : Apaga todos los LEDs conectados en serie. Establecer p\u00edxel : Permite fijar un p\u00edxel (LED) en concreto de toda la serie a un color, indicando el n\u00famero del mismo (el primero es el 0) y los valores R,G y B (0...255) o seleccionando el color. Establecer matriz : Funciona de forma similar al anterior, pero en caso de usar una matriz de LEDs podemos indicar el p\u00edxel a modificar mediante sus coordenadas X,Y y los valores R,G,B (0...255). Establecer datos : Permite rellenar una matriz de LEDs a partir de un \u201cbitmap\u201d de datos. Con el bot\u00f3n derecho nos dirigimos a la opci\u00f3n \u201cAyuda\u201d para abrir el editor para obtener los datos del \u201cbitmap\u201d. En la figura siguiente se observa como crear una imagen en una matriz de 8x8. Y en la siguiente vemos una imagen de estas notas cargada para una matriz de 64x32. Mostrar : Actualizar los datos enviados a los LEDs. Cualquier operaci\u00f3n no se reflejar\u00e1 hasta que se ejecute el bloque \u201cmostrar\u201d. Esto se realiza por una cuesti\u00f3n de optimizaci\u00f3n, as\u00ed podemos realizar varias operaciones internamente y mostrarla a la vez en una sola operaci\u00f3n. Programando la actividad \u00b6 En esta ocasi\u00f3n vamos a ver una serie de ejemplos resueltos para desarrollar la actividad desde lo m\u00e1s b\u00e1sico en los que iremos dando explicaciones concretas que se requieran para ese ejemplo. Actividades b\u00e1sicas \u00b6 A1. Encender un LED RGB Este es el programa mas simple que podemos hacer con una tira. En el enlace tenemos el programa A1. Encender un LED RGB siguiente: Programa A1. Encender un LED RGB Recu\u00e9rdese siempre que los LEDs se numeran empezando por 0, es decir \u00edndice 0. El bloque 'Mostrar' es imprescindible pues el bloque 'Establecer pixel #' lo \u00fanico que hace es indicar el color en caso de que el LED se ilumine pero realmente quien lo enciende es 'Mostrar'. A2. Encender todos los LEDs de una tira En el enlace tenemos el programa A2. Encender todos los LEDs de una tira siguiente: Programa A2. Encender todos los LEDs de una tira El programa utiliza un contador de 0 a 7 para recorrer los 8 LEDs de la tira y establecer su color. Una vez finalizada la operaci\u00f3n de asignar color se encienden los LEDs. Tambi\u00e9n vemos que la variable 'i' no la tenemos que crear porque se crea autom\u00e1ticamente al utilizar el bloque 'Contar'. A3. Encender los LEDs de una tira de uno en uno Vamos a hacer que los LEDs se enciendan de uno en uno con un peque\u00f1o retardo y que cuando est\u00e9n todos encendidos, se apaguen y vuelva a empezar el ciclo. En el enlace tenemos el programa A3. Encender los LEDs de una tira de uno en uno siguiente: Programa A3. Encender los LEDs de una tira de uno en uno Establecer el color en negro es apagar el LED. A4. Encender y apagar los LEDs de una tira de uno en uno Vamos a hacer que los LEDs se enciendan de uno en uno con un peque\u00f1o retardo y que cuando est\u00e9n todos encendidos, se apaguen en el orden inverso al de encendido tambi\u00e9n con un peque\u00f1o retardo. Una vez apagados permanecer\u00e1n as\u00ed durante tres segundos antes de iniciar el ciclo de nuevo. En el enlace tenemos el programa A4. Encender y apagar los LEDs de una tira de uno en uno siguiente: Programa A4. Encender y apagar los LEDs de una tira de uno en uno El apagado de los LEDs lo hacemos con un contador decreciente o decontador. A5. Desplazar el LED encendido Vamos a hacer que los LEDs se enciendan de uno en uno pero desplazando el LED encendido, es decir apagando el anterior y esperando un segundo entre cambio de LED. En el enlace tenemos el programa A5. Desplazar el LED encendido siguiente: Programa A5. Desplazar el LED encendido A6. Desplazar el LED encendido en dos sentidos Vamos a hacer que los LEDs se enciendan de uno en uno pero desplazando el LED encendido, es decir apagando el anterior y cuando lleguemos al final recorremos la tira pero a la inversa. En el enlace tenemos el programa A6. Desplazar el LED encendido en dos sentidos siguiente: Programa A6. Desplazar el LED encendido en dos sentidos A7. Encender todos los LEDs con color aleatorio En este caso vamos a crear tres variables nombradas R, G y B. El bloque de generaci\u00f3n de n\u00fameros aleatorios lo encontramos en 'Matem\u00e1ticas' y haremos que cada variable pueda tomar valores entre 0 y 255 que son los posibles valores para cada color. Para que todos tengan el mismo color tenemos que definir el valor de las variables y luego encender los LEDs. En el enlace tenemos el programa A7. Encender todos los LEDs con color aleatorio siguiente: A7. Encender todos los LEDs con color aleatorio A8. Encender cada LED con un color aleatorio diferente Es el mismo caso que la actividad anterior pero llevando la generaci\u00f3n de valores aleatorio al interior del bucle, lo que har\u00e1 que cada LED se encienda de un color diferente. En el enlace tenemos el programa A8. Encender cada LED con un color aleatorio diferente siguiente: A8. Encender cada LED con un color aleatorio diferente A9. Encender en un color un LED aleatorio Se trata de establecer un color para el pixel y que de forma aleatoria cambien el diodo que se enciende. En el enlace tenemos el programa A9. Encender en un color un LED aleatorio siguiente: A9. Encender en un color un LED aleatorio A10. Encender en un color aleatorio un LED aleatorio Repetir la actividad A9 pero haciendo que el color sea tambi\u00e9n aleatorio. En el enlace tenemos el programa A10. Encender en un color aleatorio un LED aleatorio siguiente: A10. Encender en un color aleatorio un LED aleatorio Actividades de control con sensores de TdR STEAM \u00b6 Despu\u00e9s de ver como generar diferentes efectos con la tira de LEDs RGB direccionables, ahora vamos a ver como hacer que diferentes sensores de los que contiene la placa TdR STEAM pueden hacer cambiar los efectos en la tira. A11. Avanzar el LED encendido al accionar un pulsador Se trata de hacer que el LED encendido cambie al siguiente cada vez que accionamos el pulsador SW1 (o SW2) en la placa TdR STEAM. Tambi\u00e9n vamos a hacer que cuando los LEDs avancen lo hagan en grupo. Para ello lo que hacemos es que se iluminen al mismo tiempo los LEDs que corresponden a la variable, pero tambi\u00e9n los de la variable+1, variable+2,... En el enlace tenemos el programa A11. Avanzar el LED encendido al accionar un pulsador siguiente: A11. Avanzar el LED encendido al accionar un pulsador A12. Ajustar el brillo de los LEDs con el potenci\u00f3metro Vamos a hacer que los LEDs cambien su luminosidad o brillo en funci\u00f3n de una variable anal\u00f3gica basada en el potenci\u00f3metro. En el enlace tenemos el programa A12. Ajustar el brillo de los LEDs con el potenci\u00f3metro siguiente: A12. Ajustar el brillo de los LEDs con el potenci\u00f3metro De forma similar podemos hacer que los cambios se realicen en funci\u00f3n de otras variables anal\u00f3gicas. A13. Cambiar de color seg\u00fan el nivel de luz Vamos a hacer que los LEDs cambien de color en funci\u00f3n de la luz detectada por la LDR. Con el sensor destapado veremos luz verde que ir\u00e1 tendiendo al amarillo seg\u00fan baje el nivel de iluminaci\u00f3n que recibe la fotoc\u00e9lula. En el enlace tenemos el programa A13. Cambiar de color seg\u00fan el nivel de luz siguiente: A13. Cambiar de color seg\u00fan el nivel de luz Podemos jugar con la variable luz y otros valores y obtener colores diferentes. Por ejemplo, en la figura siguiente vemos un programa en el que se cambia el nivel de rojo mientras suena un pitido diferente seg\u00fan ese nivel. Cambiar de color y sonido seg\u00fan el nivel de luz Se ha puesto la duraci\u00f3n de la nota a un tiempo muy bajo para que el sensor LDR responda (lea valores) sin necesidad de esperar un tiempo largo a que termine la nota. A14. Cambiar de color con control remoto Vamos a realizar mezclas de los colores b\u00e1sicos con la ayuda del mando a distancia. Haremos la siguiente asignaci\u00f3n: Establecemos el brillo m\u00e1ximo (255) de los LEDs pulsando 1 para el rojo, 2 para el verde y 3 para el azul. Establecemos el brillo m\u00ednimo o apagado (0) de los LEDs pulsando 4 para el rojo, 5 para el verde y 6 para el azul. En el enlace tenemos el programa A14. Cambiar de color con control remoto siguiente: A14. Cambiar de color con control remoto A15. Sensor de sonido Utilizaremos en este caso un sensor de sonido externo con el que vamos a captar el nivel de sonido ambiente en cada instante y sincronizarlo con la tira de LEDs a modo de v\u00fametro. En la placa TdR STEAM el sensor de sonido lo conectamos al pin A3. Para ver los valores num\u00e9ricos utilizaremos la LCD I2C. Si hacemos un programa como el de la figura siguiente podemos observar que es muy complicado ver en la pantalla en tiempo real los valores que lee el sensor porque tenemos que utilizar el bloque 'Esperar' para que podamos leerlo y eso complica leer los valores del sensor. Valores sensor de sonido Si llevamos la misma idea de programa a cambiar la iluminaci\u00f3n de los LEDs si podremos ver los cambios en tiempo real porque no es necesario realizar esa pausa. En el enlace tenemos el programa A15. Sensor de sonido siguiente: A15. Sensor de sonido Lo que hacemos es mapear los posibles niveles de sonido al n\u00famero de LEDs de la tira para despu\u00e9s iluminar mas o menos los LEDs en un determinado color seg\u00fan el nivel de sonido. Observamos en el programa que tras establecer el color apagamos los LEDs encendidos. Lo hacemos de esta forma porque si utilizamos el bloque 'Limpiar' se produce un efecto de apagado y vuelta a encender que no deseamos.","title":"LEDs RGB direccionables"},{"location":"neopixel/#leds-rgb-direccionables","text":"Comunmente se les conoce como Neopixel, que es una marca registrada por Adafruit Industries . Cada LED que componen la tira o matriz tiene los siguientes cuatro pines: Alimentaci\u00f3n VDD: 5V Tierra: GND DI (Date Input): pin para recibir informaci\u00f3n DO (Date Output): pin para enviar inforamci\u00f3n Cada uno de los LEDs es direccionable de manera individual gracias al circuito electr\u00f3nico que incluyen que, con una memoria de un byte por color, que es un circuito l\u00f3gico. Los tipos mas comunes son el SK6812, WS2811 o, el mas habitual de todos, el WS2812 cuyo datasheet tenemos en el enlace.","title":"LEDs RGB direccionables"},{"location":"neopixel/#enunciado","text":"Realizaremos varios ejemplos de uso utilizando la tira de 8 LEDs que incluye el kit, aunque se realiza un estudio te\u00f3rico amplio que ser\u00e1 \u00fatil para cualquier tira o matriz de de LEDs RGB direccionables.","title":"Enunciado"},{"location":"neopixel/#teoria","text":"El WS2812B incluye un oscilador interno de precisi\u00f3n y un circuito de control de corriente constante programable de 12 V, lo que garantiza de manera efectiva que la intensidad del color sea consistente. El protocolo de transferencia de datos utiliza un \u00fanico modo de comunicaci\u00f3n de multiplexado NZR. En la figura siguiente vemos el aspecto de un diodo LED RGB individual en formato inserci\u00f3n y SMD. Aspecto de un diodo LED RGB","title":"Teor\u00eda"},{"location":"neopixel/#aspectos-previos","text":"Para transmitir informaci\u00f3n digital esta se debe sincronizar mediante una convenci\u00f3n especial, la codificaci\u00f3n. Dos dispositivos llevan una comunicaci\u00f3n por cable convirtiendo la informaci\u00f3n a transmitir en un flujo de bits (0 y 1) o \"Dates\" que se suele nombrar con la letra D y que va acompa\u00f1ada de una se\u00f1al de reloj para sincronizar las transmisiones. La forma convencional de transmisi\u00f3n digital se componen de una l\u00ednea de datos mas una l\u00ednea de reloj. Ahora bien, cualquier ligera desviaci\u00f3n en la longitud de estas l\u00edneas har\u00e1 que el receptor no cumpla con el tiempo de establecimiento del muestreo de datos, originando errores en los datos. La forma de asegurar que esas l\u00edneas son id\u00e9nticas es que sean la misma l\u00ednea, lo que hace que aparezcan c\u00f3digos que fusionan los datos y el reloj, entre los que est\u00e1n los c\u00f3digo RZ, NRZ y NRZI que vamos a ver someramente a continuaci\u00f3n. Codificaci\u00f3n RZ . El acr\u00f3nimo de de \"Return Zero\" o retorno cero y su caracter\u00edstica es que se transmiten bits de datos dentro de cada periodo de la se\u00f1al. En la figura siguiente los datos se representan en rojo y vemos que ocupan una parte del periodo T, siendo cero el resto del tiempo. Este sistema se denomina RZ unipolar o retorno a cero unipolar y como se observa en la figura un nivel bajo indica 0 y un nivel positivo indica 1. C\u00f3digo RZ unipolar El c\u00f3digo de retorno a cero se divide en un c\u00f3digo de retorno a cero unipolar y un c\u00f3digo de retorno a cero bipolar en el que el nivel alto indica 1 y el nivel negativo o, tal y como vemos en la figura siguiente: C\u00f3digo RZ bipolar Codificaci\u00f3n NRZ . El acr\u00f3nimo es de \"Not Return Zero\" o c\u00f3digo sin retorno a cero y se diferencia del RZ en que no necesita retornar a cero. En la figura siguiente vemos gr\u00e1ficamente el c\u00f3digo. C\u00f3digo NRZ En el datasheet estos c\u00f3digo se denominan T0H y T0L. El funcionamiento de una agrupaci\u00f3n en cascada como la de la figura siguiente se puede resumir diciendo que: el circuito integrado de cada LED puede almacenar 3 bytes (24 bits), un byte para cada color. Solo el primer LED est\u00e1 conectado al Pin de control, en este caso, un pin digital de nuestra placa, que enviar\u00e1 la cadena de todos los colores seg\u00fan el n\u00famero de pixeles que est\u00e9n conectados y a su vez el primer LED recibir\u00e1 la informaci\u00f3n de todos los colores uno tras otro. La informaci\u00f3n se transmite de un LED a otro porque cuando un LED recibe 3 bytes nuevos de informaci\u00f3n entrega al siguiente LED los 3 bytes que conten\u00eda anteriormente, de esta manera cuando la placa con el programa termina de mandar todos los colores por el pin de datos el primer LED habr\u00eda recibido y enviado todos los colores para quedarse finalmente con el color que le corresponde y as\u00ed el resto de LEDs. De esta forma una tira de LEDs RGB direccionables es un dispositivo digital de salida, es decir su funcionamiento consiste en recibir la informaci\u00f3n del color a mostrar y mostrarlo. Conexi\u00f3n en cascada","title":"Aspectos previos"},{"location":"neopixel/#aspectos-tecnicos","text":"Los LEDs RGB direccionables se suelen suministrar en tiras de diferentes longitudes y con distinto n\u00famero de LEDs y a veces se dispone la tira en forma de matriz. En la figura siguiente vemos el aspecto de algunos tipos. Tira y matriz de LEDs RGB Tienen 3 cables asociados a un conector y dos cables extra para a\u00f1adir alimentaci\u00f3n externa cuando es necesario porque la placa de control no entrega suficiente corriente para alimentar al conjunto. Cuando se trabaja con una tira de pocos LEDs no es necesario a\u00f1adir esta alimentaci\u00f3n externa, ya que placas como Arduino UNO o la ESP32 STEAMakers pueden suministrar la corriente que necesitan. Para los ejemplos mas b\u00e1sicos vamos a utilizar una tira de 8 LEDs como la que vemos en la figura siguiente: Tira de ocho LEDs RGB Cualquier tira de LEDs RGB (sea cual sea su disposici\u00f3n en l\u00ednea, como matriz, etc) debe utilizarse siempre en la direcci\u00f3n que marca el terminal hembra como entrada y el conector macho como salida. Las podemos ir conectando entre s\u00ed pero siempre respetando este sentido de la tira. Junto a cada led RGB est\u00e1 indicada la direcci\u00f3n de la tira mediante un tri\u00e1ngulo y tambi\u00e9n a qu\u00e9 pin debe ir conectado cada cable. Vemos +5V que corresponde a Vcc, GND, y en medio que pone Din o D0 que corresponde al pin digital de entrada de datos que debemos conectar al pin de salida de la placa de control. Tambi\u00e9n las podemos cortar por cualquiera de las l\u00edneas existentes entre cada uno de los LEDs y que est\u00e1 marcado con la l\u00ednea de corte. El corte debe hacerse dejando la mitad del pad de cobre a un lado y otro de la l\u00ednea y as\u00ed poder unir despu\u00e9s entre ellas con conectores especializados o sold\u00e1ndolas. Direcci\u00f3n y l\u00ednea de corte","title":"Aspectos t\u00e9cnicos"},{"location":"neopixel/#bloques-en-arduinoblocks","text":"En la figura siguiente vemos el men\u00fa bloques disponible en 'Visualizaci\u00f3n' en su entrada 'NeoPixel'. Bloques LEDs RGB direccionables Iniciar : Este bloque se debe definir dentro del bloque \u201cinicializar\u201d o \u201csetup\u201d para indicar la configuraci\u00f3n los LEDs conectados. Tenemos que indicar los siguientes par\u00e1metros: Frecuencia : 800Khz / 400Khz, es la velocidad del \u201cbistream\u201d con los datos que se env\u00edan a trav\u00e9s del pin DIN con los datos para cada neop\u00edxel. Una tasa de 400khz ya permitir\u00eda controlar m\u00e1s de 1000 leds con un refresco de 30fps. N\u00famero de p\u00edxeles : indica el n\u00famero de p\u00edxeles conectados en serie, si conectamos una tira de 100 LEDs lo indicaremos en este valor. Pin : es el pin a trav\u00e9s el cual la placa de control enviar\u00e1 y controlar\u00e1 los datos de los LEDs. Establecer brillo : Valor entre 0 y 255 que establece con que potencia emiten luz los LEDs. Limpiar : Apaga todos los LEDs conectados en serie. Establecer p\u00edxel : Permite fijar un p\u00edxel (LED) en concreto de toda la serie a un color, indicando el n\u00famero del mismo (el primero es el 0) y los valores R,G y B (0...255) o seleccionando el color. Establecer matriz : Funciona de forma similar al anterior, pero en caso de usar una matriz de LEDs podemos indicar el p\u00edxel a modificar mediante sus coordenadas X,Y y los valores R,G,B (0...255). Establecer datos : Permite rellenar una matriz de LEDs a partir de un \u201cbitmap\u201d de datos. Con el bot\u00f3n derecho nos dirigimos a la opci\u00f3n \u201cAyuda\u201d para abrir el editor para obtener los datos del \u201cbitmap\u201d. En la figura siguiente se observa como crear una imagen en una matriz de 8x8. Y en la siguiente vemos una imagen de estas notas cargada para una matriz de 64x32. Mostrar : Actualizar los datos enviados a los LEDs. Cualquier operaci\u00f3n no se reflejar\u00e1 hasta que se ejecute el bloque \u201cmostrar\u201d. Esto se realiza por una cuesti\u00f3n de optimizaci\u00f3n, as\u00ed podemos realizar varias operaciones internamente y mostrarla a la vez en una sola operaci\u00f3n.","title":"Bloques en ArduinoBlocks"},{"location":"neopixel/#programando-la-actividad","text":"En esta ocasi\u00f3n vamos a ver una serie de ejemplos resueltos para desarrollar la actividad desde lo m\u00e1s b\u00e1sico en los que iremos dando explicaciones concretas que se requieran para ese ejemplo.","title":"Programando la actividad"},{"location":"neopixel/#actividades-basicas","text":"A1. Encender un LED RGB Este es el programa mas simple que podemos hacer con una tira. En el enlace tenemos el programa A1. Encender un LED RGB siguiente: Programa A1. Encender un LED RGB Recu\u00e9rdese siempre que los LEDs se numeran empezando por 0, es decir \u00edndice 0. El bloque 'Mostrar' es imprescindible pues el bloque 'Establecer pixel #' lo \u00fanico que hace es indicar el color en caso de que el LED se ilumine pero realmente quien lo enciende es 'Mostrar'. A2. Encender todos los LEDs de una tira En el enlace tenemos el programa A2. Encender todos los LEDs de una tira siguiente: Programa A2. Encender todos los LEDs de una tira El programa utiliza un contador de 0 a 7 para recorrer los 8 LEDs de la tira y establecer su color. Una vez finalizada la operaci\u00f3n de asignar color se encienden los LEDs. Tambi\u00e9n vemos que la variable 'i' no la tenemos que crear porque se crea autom\u00e1ticamente al utilizar el bloque 'Contar'. A3. Encender los LEDs de una tira de uno en uno Vamos a hacer que los LEDs se enciendan de uno en uno con un peque\u00f1o retardo y que cuando est\u00e9n todos encendidos, se apaguen y vuelva a empezar el ciclo. En el enlace tenemos el programa A3. Encender los LEDs de una tira de uno en uno siguiente: Programa A3. Encender los LEDs de una tira de uno en uno Establecer el color en negro es apagar el LED. A4. Encender y apagar los LEDs de una tira de uno en uno Vamos a hacer que los LEDs se enciendan de uno en uno con un peque\u00f1o retardo y que cuando est\u00e9n todos encendidos, se apaguen en el orden inverso al de encendido tambi\u00e9n con un peque\u00f1o retardo. Una vez apagados permanecer\u00e1n as\u00ed durante tres segundos antes de iniciar el ciclo de nuevo. En el enlace tenemos el programa A4. Encender y apagar los LEDs de una tira de uno en uno siguiente: Programa A4. Encender y apagar los LEDs de una tira de uno en uno El apagado de los LEDs lo hacemos con un contador decreciente o decontador. A5. Desplazar el LED encendido Vamos a hacer que los LEDs se enciendan de uno en uno pero desplazando el LED encendido, es decir apagando el anterior y esperando un segundo entre cambio de LED. En el enlace tenemos el programa A5. Desplazar el LED encendido siguiente: Programa A5. Desplazar el LED encendido A6. Desplazar el LED encendido en dos sentidos Vamos a hacer que los LEDs se enciendan de uno en uno pero desplazando el LED encendido, es decir apagando el anterior y cuando lleguemos al final recorremos la tira pero a la inversa. En el enlace tenemos el programa A6. Desplazar el LED encendido en dos sentidos siguiente: Programa A6. Desplazar el LED encendido en dos sentidos A7. Encender todos los LEDs con color aleatorio En este caso vamos a crear tres variables nombradas R, G y B. El bloque de generaci\u00f3n de n\u00fameros aleatorios lo encontramos en 'Matem\u00e1ticas' y haremos que cada variable pueda tomar valores entre 0 y 255 que son los posibles valores para cada color. Para que todos tengan el mismo color tenemos que definir el valor de las variables y luego encender los LEDs. En el enlace tenemos el programa A7. Encender todos los LEDs con color aleatorio siguiente: A7. Encender todos los LEDs con color aleatorio A8. Encender cada LED con un color aleatorio diferente Es el mismo caso que la actividad anterior pero llevando la generaci\u00f3n de valores aleatorio al interior del bucle, lo que har\u00e1 que cada LED se encienda de un color diferente. En el enlace tenemos el programa A8. Encender cada LED con un color aleatorio diferente siguiente: A8. Encender cada LED con un color aleatorio diferente A9. Encender en un color un LED aleatorio Se trata de establecer un color para el pixel y que de forma aleatoria cambien el diodo que se enciende. En el enlace tenemos el programa A9. Encender en un color un LED aleatorio siguiente: A9. Encender en un color un LED aleatorio A10. Encender en un color aleatorio un LED aleatorio Repetir la actividad A9 pero haciendo que el color sea tambi\u00e9n aleatorio. En el enlace tenemos el programa A10. Encender en un color aleatorio un LED aleatorio siguiente: A10. Encender en un color aleatorio un LED aleatorio","title":"Actividades b\u00e1sicas"},{"location":"neopixel/#actividades-de-control-con-sensores-de-tdr-steam","text":"Despu\u00e9s de ver como generar diferentes efectos con la tira de LEDs RGB direccionables, ahora vamos a ver como hacer que diferentes sensores de los que contiene la placa TdR STEAM pueden hacer cambiar los efectos en la tira. A11. Avanzar el LED encendido al accionar un pulsador Se trata de hacer que el LED encendido cambie al siguiente cada vez que accionamos el pulsador SW1 (o SW2) en la placa TdR STEAM. Tambi\u00e9n vamos a hacer que cuando los LEDs avancen lo hagan en grupo. Para ello lo que hacemos es que se iluminen al mismo tiempo los LEDs que corresponden a la variable, pero tambi\u00e9n los de la variable+1, variable+2,... En el enlace tenemos el programa A11. Avanzar el LED encendido al accionar un pulsador siguiente: A11. Avanzar el LED encendido al accionar un pulsador A12. Ajustar el brillo de los LEDs con el potenci\u00f3metro Vamos a hacer que los LEDs cambien su luminosidad o brillo en funci\u00f3n de una variable anal\u00f3gica basada en el potenci\u00f3metro. En el enlace tenemos el programa A12. Ajustar el brillo de los LEDs con el potenci\u00f3metro siguiente: A12. Ajustar el brillo de los LEDs con el potenci\u00f3metro De forma similar podemos hacer que los cambios se realicen en funci\u00f3n de otras variables anal\u00f3gicas. A13. Cambiar de color seg\u00fan el nivel de luz Vamos a hacer que los LEDs cambien de color en funci\u00f3n de la luz detectada por la LDR. Con el sensor destapado veremos luz verde que ir\u00e1 tendiendo al amarillo seg\u00fan baje el nivel de iluminaci\u00f3n que recibe la fotoc\u00e9lula. En el enlace tenemos el programa A13. Cambiar de color seg\u00fan el nivel de luz siguiente: A13. Cambiar de color seg\u00fan el nivel de luz Podemos jugar con la variable luz y otros valores y obtener colores diferentes. Por ejemplo, en la figura siguiente vemos un programa en el que se cambia el nivel de rojo mientras suena un pitido diferente seg\u00fan ese nivel. Cambiar de color y sonido seg\u00fan el nivel de luz Se ha puesto la duraci\u00f3n de la nota a un tiempo muy bajo para que el sensor LDR responda (lea valores) sin necesidad de esperar un tiempo largo a que termine la nota. A14. Cambiar de color con control remoto Vamos a realizar mezclas de los colores b\u00e1sicos con la ayuda del mando a distancia. Haremos la siguiente asignaci\u00f3n: Establecemos el brillo m\u00e1ximo (255) de los LEDs pulsando 1 para el rojo, 2 para el verde y 3 para el azul. Establecemos el brillo m\u00ednimo o apagado (0) de los LEDs pulsando 4 para el rojo, 5 para el verde y 6 para el azul. En el enlace tenemos el programa A14. Cambiar de color con control remoto siguiente: A14. Cambiar de color con control remoto A15. Sensor de sonido Utilizaremos en este caso un sensor de sonido externo con el que vamos a captar el nivel de sonido ambiente en cada instante y sincronizarlo con la tira de LEDs a modo de v\u00fametro. En la placa TdR STEAM el sensor de sonido lo conectamos al pin A3. Para ver los valores num\u00e9ricos utilizaremos la LCD I2C. Si hacemos un programa como el de la figura siguiente podemos observar que es muy complicado ver en la pantalla en tiempo real los valores que lee el sensor porque tenemos que utilizar el bloque 'Esperar' para que podamos leerlo y eso complica leer los valores del sensor. Valores sensor de sonido Si llevamos la misma idea de programa a cambiar la iluminaci\u00f3n de los LEDs si podremos ver los cambios en tiempo real porque no es necesario realizar esa pausa. En el enlace tenemos el programa A15. Sensor de sonido siguiente: A15. Sensor de sonido Lo que hacemos es mapear los posibles niveles de sonido al n\u00famero de LEDs de la tira para despu\u00e9s iluminar mas o menos los LEDs en un determinado color seg\u00fan el nivel de sonido. Observamos en el programa que tras establecer el color apagamos los LEDs encendidos. Lo hacemos de esta forma porque si utilizamos el bloque 'Limpiar' se produce un efecto de apagado y vuelta a encender que no deseamos.","title":"Actividades de control con sensores de TdR STEAM"},{"location":"operadores/","text":"Operadores en programaci\u00f3n C++ \u00b6 \u00bfQue es un operador? \u00b6 En general se puede decir que un operador es un elemento de programa que se aplica a uno o varios operandos en una expresi\u00f3n o instrucci\u00f3n. Existen muchos tipos de operadores y nosotros vamos a mostrar aqu\u00ed solamente algunos de los mas utilizados. Los mostraremos por tipos como sistema para clasificarlos. Operadores de asignaci\u00f3n \u00b6 Sirven para asignar un valor especifico a una variable mediante asignaci\u00f3n simple o por dos operadores. En la tabla siguiente vemos algunos de estos operadores: Operador Nombre Sintaxis = Asignaci\u00f3n a = b += Suma y asignaci\u00f3n a += b; a = a + b -= Resta y asignaci\u00f3n a -= b; a = a - b *= Multiplicaci\u00f3n y asignaci\u00f3n a *= b; a = a * b /= Divisi\u00f3n y asignaci\u00f3n a /= b; a = a / b ++ Posincremento o preincremento a++ ; ++a -- Posdecremento o predecremento a-- ; --a Operadores Aritm\u00e9ticos \u00b6 Nos permiten hacer operaciones o c\u00e1lculos simples. Los vemos en la tabla siguiente: Operador Nombre Sintaxis + Suma a + b - Resta a - b * Multiplicaci\u00f3n a * b / Divisi\u00f3n a / b % M\u00f3dulo o resto de divisi\u00f3n a % b ++ Incremento en 1 a++; a = a+1 -- Decremento en 1 a--; a = a-1 Operadores Relacionales o de comparaci\u00f3n \u00b6 Sirven para comparar dos variables o expresiones o bien probar la veracidad de una condici\u00f3n. La respuesta es tipo booleano (falso = 0 y verdadero = 1). Los vemos en la tabla siguiente: Operador Nombre Sintaxis < Menor que a < b > Mayor que a > b <= Menor o igual que a <= b <= Mayor o igual que a >= b == Igual a == b != Distinto a != b Operadores l\u00f3gicos \u00b6 Siempre generan un resultado de tipo booleano y se corresponden con la idea de funcionamiento de las tablas de verdad de la puertas l\u00f3gicas elementales. En la tabla siguiente se dan las tablas de verdad y los operadores. a b AND OR NOT a NOT b Operador Nombre Sintaxis 0 0 0 0 1 1 0 1 0 1 1 0 && Y l\u00f3gico-AND a&&b 1 0 0 1 0 1 1 1 1 1 0 0 ! Negaci\u00f3n l\u00f3gica-NOT !a Existen otros muchos operadores que se pueden consultar en la web.","title":"Operadores en programaci\u00f3n C++"},{"location":"operadores/#operadores-en-programacion-c","text":"","title":"Operadores en programaci\u00f3n C++"},{"location":"operadores/#que-es-un-operador","text":"En general se puede decir que un operador es un elemento de programa que se aplica a uno o varios operandos en una expresi\u00f3n o instrucci\u00f3n. Existen muchos tipos de operadores y nosotros vamos a mostrar aqu\u00ed solamente algunos de los mas utilizados. Los mostraremos por tipos como sistema para clasificarlos.","title":"\u00bfQue es un operador?"},{"location":"operadores/#operadores-de-asignacion","text":"Sirven para asignar un valor especifico a una variable mediante asignaci\u00f3n simple o por dos operadores. En la tabla siguiente vemos algunos de estos operadores: Operador Nombre Sintaxis = Asignaci\u00f3n a = b += Suma y asignaci\u00f3n a += b; a = a + b -= Resta y asignaci\u00f3n a -= b; a = a - b *= Multiplicaci\u00f3n y asignaci\u00f3n a *= b; a = a * b /= Divisi\u00f3n y asignaci\u00f3n a /= b; a = a / b ++ Posincremento o preincremento a++ ; ++a -- Posdecremento o predecremento a-- ; --a","title":"Operadores de asignaci\u00f3n"},{"location":"operadores/#operadores-aritmeticos","text":"Nos permiten hacer operaciones o c\u00e1lculos simples. Los vemos en la tabla siguiente: Operador Nombre Sintaxis + Suma a + b - Resta a - b * Multiplicaci\u00f3n a * b / Divisi\u00f3n a / b % M\u00f3dulo o resto de divisi\u00f3n a % b ++ Incremento en 1 a++; a = a+1 -- Decremento en 1 a--; a = a-1","title":"Operadores Aritm\u00e9ticos"},{"location":"operadores/#operadores-relacionales-o-de-comparacion","text":"Sirven para comparar dos variables o expresiones o bien probar la veracidad de una condici\u00f3n. La respuesta es tipo booleano (falso = 0 y verdadero = 1). Los vemos en la tabla siguiente: Operador Nombre Sintaxis < Menor que a < b > Mayor que a > b <= Menor o igual que a <= b <= Mayor o igual que a >= b == Igual a == b != Distinto a != b","title":"Operadores Relacionales o de comparaci\u00f3n"},{"location":"operadores/#operadores-logicos","text":"Siempre generan un resultado de tipo booleano y se corresponden con la idea de funcionamiento de las tablas de verdad de la puertas l\u00f3gicas elementales. En la tabla siguiente se dan las tablas de verdad y los operadores. a b AND OR NOT a NOT b Operador Nombre Sintaxis 0 0 0 0 1 1 0 1 0 1 1 0 && Y l\u00f3gico-AND a&&b 1 0 0 1 0 1 1 1 1 1 0 0 ! Negaci\u00f3n l\u00f3gica-NOT !a Existen otros muchos operadores que se pueden consultar en la web.","title":"Operadores l\u00f3gicos"},{"location":"rfid/","text":"Sensor RFID \u00b6 Enunciado \u00b6 Detectar tarjetas y llaveros RFID mediante el sensor RC522 I2C. En la figura siguiente vemos los componentes habituales, el propio sensor y los dos transpondedores que lo acompa\u00f1an, el llavero y la tarjeta. Componentes del kit RFID Tambi\u00e9n existen pegatinas, etiquetas y otros elementos compatibles de peque\u00f1o tama\u00f1o para trabajar con ropa o peque\u00f1os art\u00edculos. Teor\u00eda \u00b6 RFID son las iniciales de Radio Frequency IDentification (identificaci\u00f3n por radiofrecuencia) y es un sistema de identificaci\u00f3n de productos que puede parecer similar al c\u00f3digo de barras tradicional, pero que tiene grandes ventajas con respecto a este. A diferencia del c\u00f3digo de barras que utiliza la imagen para identificar una etiqueta, el sistema RFID utiliza las ondas de radio para comunicarse con un circuito electr\u00f3nico. Puede estar montado sobre gran cantidad de soportes, como por ejemplo un tag o etiqueta RFID, una tarjeta o un transpondedor. Un circuito RFID tiene una gran capacidad de almacenamiento de datos, por lo que permite guardar mucha m\u00e1s informaci\u00f3n que las etiquetas de c\u00f3digo de barras tradicional. Su tecnolog\u00eda hace que sean muy dif\u00edciles de duplicar lo que aumenta su seguridad y permiten realizar la lectura de forma pr\u00e1cticamente instant\u00e1nea, a distancia y sin necesidad de l\u00ednea de visi\u00f3n. El sensor RFID de nuestro caso est\u00e1 basado en el m\u00f3dulo MF522-AN de Philips. Es f\u00e1cil de utilizar, de bajo costo y, adecuado para el desarrollo de equipos y el desarrollo de aplicaciones avanzadas para usuarios de lectores. Este m\u00f3dulo se puede conectar de forma sencilla a trav\u00e9s de sus cuatro terminales, ya que utiliza un sistema de comunicaci\u00f3n I2C para conectarse a un microcontrolador. En la figura siguiente vemos con mas detalle el aspecto del m\u00f3dulo sensor. Aspecto En la figura siguiente podemos ver los tres bloques necesarios para trabajar con RFID. Bloques El bloque superior inicializa la tarjeta e indica a que pines est\u00e1 conectada, el del centro es el encargado de decir si se ha detectado una tarjeta y el tercer bloque nos sirve para leer el c\u00f3digo que tiene configurado nuestra tarjeta o llavero. Programando la actividad \u00b6 Lector ID o c\u00f3digo identificador En caso de detectar una tarjeta o llavero RFID cerca del lector, leeremos su ID y lo enviamos por la consola serie para visualizarlo. El programa de la imagen siguiente esta disponible como lector . Programa lector ID RFID El programa genera el siguiente resultado para cuatro llaveros diferentes: Resultado programa lector ID RFID Abre puertas RFID Vamos a mover el servo 180\u00ba simulando la apertura de una puerta abatible. Para ello utilizaremos como v\u00e1lido uno de los llaveros de la actividad anterior y si el ID coincide con el programado el servo semover\u00e1 a la posici\u00f3n 180\u00ba y tras 5 segundos volver\u00e1 al cero simulando que la puerta se ha cerrado. El programa de la imagen siguiente esta disponible como puerta . Apertura de puerta con RFID Control de acceso de m\u00faltiples usuarios Esta actividad la vamos a resolver utilizando listas de texto, el bloque contar longitud de la lista y bucles contadores as\u00ed como una funci\u00f3n que comprobar\u00e1 el c\u00f3digo y si es v\u00e1lido retornar\u00e1 un valor 1. El programa de la imagen siguiente esta disponible como multiples . Control de acceso de m\u00faltiples usuarios Retos de ampliaci\u00f3n \u00b6 RFID.R1 . Realiza un programa que muestra en una LCD el c\u00f3digo identificador de llaveros y tarjetas que se acerquen al lector. RFID.R2 . Analizar y probar el funcionamiento del programa de gesti\u00f3n de m\u00faltiples usuarios con diferentes niveles de permisos. Podemos almacenar los c\u00f3digos autorizados en diferentes listas y de esta forma establecer jerarqu\u00edas de accesos, clasificaciones de materiales, ofertas, etc. El programa de la imagen siguiente esta disponible como 2niveles . Control de acceso de m\u00faltiples usuarios con diferentes niveles","title":"Sensor RFID"},{"location":"rfid/#sensor-rfid","text":"","title":"Sensor RFID"},{"location":"rfid/#enunciado","text":"Detectar tarjetas y llaveros RFID mediante el sensor RC522 I2C. En la figura siguiente vemos los componentes habituales, el propio sensor y los dos transpondedores que lo acompa\u00f1an, el llavero y la tarjeta. Componentes del kit RFID Tambi\u00e9n existen pegatinas, etiquetas y otros elementos compatibles de peque\u00f1o tama\u00f1o para trabajar con ropa o peque\u00f1os art\u00edculos.","title":"Enunciado"},{"location":"rfid/#teoria","text":"RFID son las iniciales de Radio Frequency IDentification (identificaci\u00f3n por radiofrecuencia) y es un sistema de identificaci\u00f3n de productos que puede parecer similar al c\u00f3digo de barras tradicional, pero que tiene grandes ventajas con respecto a este. A diferencia del c\u00f3digo de barras que utiliza la imagen para identificar una etiqueta, el sistema RFID utiliza las ondas de radio para comunicarse con un circuito electr\u00f3nico. Puede estar montado sobre gran cantidad de soportes, como por ejemplo un tag o etiqueta RFID, una tarjeta o un transpondedor. Un circuito RFID tiene una gran capacidad de almacenamiento de datos, por lo que permite guardar mucha m\u00e1s informaci\u00f3n que las etiquetas de c\u00f3digo de barras tradicional. Su tecnolog\u00eda hace que sean muy dif\u00edciles de duplicar lo que aumenta su seguridad y permiten realizar la lectura de forma pr\u00e1cticamente instant\u00e1nea, a distancia y sin necesidad de l\u00ednea de visi\u00f3n. El sensor RFID de nuestro caso est\u00e1 basado en el m\u00f3dulo MF522-AN de Philips. Es f\u00e1cil de utilizar, de bajo costo y, adecuado para el desarrollo de equipos y el desarrollo de aplicaciones avanzadas para usuarios de lectores. Este m\u00f3dulo se puede conectar de forma sencilla a trav\u00e9s de sus cuatro terminales, ya que utiliza un sistema de comunicaci\u00f3n I2C para conectarse a un microcontrolador. En la figura siguiente vemos con mas detalle el aspecto del m\u00f3dulo sensor. Aspecto En la figura siguiente podemos ver los tres bloques necesarios para trabajar con RFID. Bloques El bloque superior inicializa la tarjeta e indica a que pines est\u00e1 conectada, el del centro es el encargado de decir si se ha detectado una tarjeta y el tercer bloque nos sirve para leer el c\u00f3digo que tiene configurado nuestra tarjeta o llavero.","title":"Teor\u00eda"},{"location":"rfid/#programando-la-actividad","text":"Lector ID o c\u00f3digo identificador En caso de detectar una tarjeta o llavero RFID cerca del lector, leeremos su ID y lo enviamos por la consola serie para visualizarlo. El programa de la imagen siguiente esta disponible como lector . Programa lector ID RFID El programa genera el siguiente resultado para cuatro llaveros diferentes: Resultado programa lector ID RFID Abre puertas RFID Vamos a mover el servo 180\u00ba simulando la apertura de una puerta abatible. Para ello utilizaremos como v\u00e1lido uno de los llaveros de la actividad anterior y si el ID coincide con el programado el servo semover\u00e1 a la posici\u00f3n 180\u00ba y tras 5 segundos volver\u00e1 al cero simulando que la puerta se ha cerrado. El programa de la imagen siguiente esta disponible como puerta . Apertura de puerta con RFID Control de acceso de m\u00faltiples usuarios Esta actividad la vamos a resolver utilizando listas de texto, el bloque contar longitud de la lista y bucles contadores as\u00ed como una funci\u00f3n que comprobar\u00e1 el c\u00f3digo y si es v\u00e1lido retornar\u00e1 un valor 1. El programa de la imagen siguiente esta disponible como multiples . Control de acceso de m\u00faltiples usuarios","title":"Programando la actividad"},{"location":"rfid/#retos-de-ampliacion","text":"RFID.R1 . Realiza un programa que muestra en una LCD el c\u00f3digo identificador de llaveros y tarjetas que se acerquen al lector. RFID.R2 . Analizar y probar el funcionamiento del programa de gesti\u00f3n de m\u00faltiples usuarios con diferentes niveles de permisos. Podemos almacenar los c\u00f3digos autorizados en diferentes listas y de esta forma establecer jerarqu\u00edas de accesos, clasificaciones de materiales, ofertas, etc. El programa de la imagen siguiente esta disponible como 2niveles . Control de acceso de m\u00faltiples usuarios con diferentes niveles","title":"Retos de ampliaci\u00f3n"},{"location":"servo/","text":"El servomotor \u00b6 Haremos diferentes movimientos del servomotor empleando funciones para distinguir un tipo de movimiento de otro. Teor\u00eda \u00b6 El servo \u00b6 Un servomotor o abreviado servo es un motor especial que puede posicionar su eje en un \u00e1ngulo determinado y lo puede mantener en esta posici\u00f3n. Los servos est\u00e1ndar suelen girar 180\u00ba, pero es habitual encontrar servos que giran 90\u00ba y otros 360\u00ba, que son los conocidos como servos de rotaci\u00f3n continua. En el interior del mismo est\u00e1n ubicados tanto la electr\u00f3nica de control como los engranajes reductores que a su vez pueden llevar o no topes f\u00edsicos que marquen el \u00e1ngulo de giro. Para su funcionamiento s\u00f3lo necesitan ser alimentados (conexiones GND y VCC o 5V) y una se\u00f1al de control. Los servomotores son en realidad motores de corriente continua a los que se les ha a\u00f1adido una reductora, para que giren m\u00e1s despacio y con m\u00e1s fuerza, y un controlador electr\u00f3nico que permite hacer que gire un determinado \u00e1ngulo. Adem\u00e1s, el servo en todo momento sabe en qu\u00e9 posici\u00f3n est\u00e1, aunque se apague o reinicie. Esto significa que si a un servo que hemos movido a un determinado punto, lo hemos dejado sin alimentaci\u00f3n y al alimentarlo de nuevo le indicamos que gire 90\u00ba, no va a girar 90\u00ba sino que se va a dirigir a su posici\u00f3n de 90\u00ba que tiene memorizada internamente. En la figura siguiente vemos el interior de un servo esquematizado. Interior de un servo 9g Su aspecto real lo vemos en esta otra figura, donde tambi\u00e9n se aprecian las palas y torniller\u00eda que lo acompa\u00f1an. Aspecto real servo 9g Veamos su principio b\u00e1sico de funcionamiento: La electr\u00f3nica de control del servomotor tiene un circuito de referencia incorporado que emite la se\u00f1al de referencia, que es un ciclo de 20 ms con un ancho de pulso de 1,5 ms. Se compara la tensi\u00f3n de control recibida con la de referencia y se genera una diferencia de tensi\u00f3n. El circuito de control en la placa decidir\u00e1 la direcci\u00f3n de rotaci\u00f3n en consecuencia y accionar\u00e1 el motor. El sistema de engranajes o reductora convierten el giro del motor en un par de fuerza a trav\u00e9s del eje. El sensor detecta que se ha alcanzado la posici\u00f3n enviada de acuerdo con la se\u00f1al de retroalimentaci\u00f3n. Cuando la diferencia de tensi\u00f3n existe el motor gira y cuando la diferencia se reduce a cero, el motor se detiene. Normalmente, el \u00e1ngulo de rotaci\u00f3n es de 0 a 180 grados. El servomotor viene con un conector hembra de tres pines para tres cables de conexi\u00f3n, que se distinguen por los colores marr\u00f3n, rojo y naranja (diferentes marcas pueden tener diferentes colores). El \u00e1ngulo de rotaci\u00f3n del servomotor se controla regulando el ciclo de trabajo de la se\u00f1al PWM cuyo est\u00e1ndar es de 20 ms (50 Hz). Hay que tener mucho cuidado de posicionar el conector de los servos en los tres pines macho de la shield en el orden correcto (el conector es reversible) o seguramente romperemos algo de manera irremediable. Existe un tipo especial de servomotor que permite la rotaci\u00f3n continua. En algunos casos se trata de servomotores \u201ctrucados\u201d de forma que se modifican para permitir la rotaci\u00f3n continua quitando los topes mec\u00e1nicos y se sustituye el potenci\u00f3metro por un divisor de tensi\u00f3n con dos resistencia iguales (en algunos casos no se ponen resistencias y se bloquea el potenci\u00f3metro para que no gire dej\u00e1ndolo justo en su punto central). Este tipo de modificaci\u00f3n la podemos realizar nosotros (en la web existen multitud de tutoriales) o tambi\u00e9n podemos comprar un servomotor de rotaci\u00f3n continua listo para funcionar sin tener que hacer ning\u00fan tipo de bricolaje. En el apartado de bloques de programaci\u00f3n, se encuentra en \"Motor / Servo\" y en la figura siguiente vemos los bloques disponibles. Bloques para servos Para controlar el servomotor, indicamos los grados de rotaci\u00f3n (\u00c1ngulo de giro) que queremos y el tiempo de retardo, o tiempo que tarda en ir de una posici\u00f3n a otra. El control de un servomotor de rotaci\u00f3n continua se realiza de igual manera, pero su reacci\u00f3n es diferente. Los bloques Servo-Oscilador nos permiten de una forma sencilla hacer que el servo repita una secuencia de movimientos u oscilaciones de forma indefinida. Un ejemplo t\u00edpico puede ser el que vemos en la figura siguiente, donde el servo oscila entre 0 y 90\u00ba en periodos de dos segundos. Oscilaci\u00f3n con servo El bloque Servo-I2C (PCA9685) es simplemente un bloque para manejar la tarjeta controladora para 16 servos PCA9685 utilizando el bus I2C. Posicionar el servo \u00b6 Antes de fijar con el tornillo la pala y, en nuestro caso la flecha, debemos averiguar cual es su posici\u00f3n de 0\u00ba o inicial. Para ello vamos a crear el programa Posicionar-servo que vemos en la figura siguiente o que podemos importar del archivo del enlace. Buscar la posici\u00f3n 0\u00ba del servo Ejecutamos el programa que hemos cargado en la placa, y lo tenemos que parar en el momento que el servo vuelve a la posici\u00f3n inicial (hace un giro repentino de 180\u00ba tras un tiempo de espera mas largo). En ese momento, quitamos la flecha y el soporte tipo aspa vigilando de que no se modifique la posici\u00f3n del servo. Sin que el servomotor se haya movido, montamos el soporte blanco y la flecha, de forma que la flecha apunte hacia abajo, tal y como se muestra en la figura siguiente, donde se aprecia todo el proceso. Colocaci\u00f3n de elementos en el servo Listas \u00b6 Las listas de datos nos permiten almacenar un listado de valores y acceder a ellos por su posici\u00f3n en la lista. Las listas pueden ser de tipo num\u00e9ricas o de texto, como vemos en la imagen siguiente: Tipos de listas en ArduinoBlocks En la animaci\u00f3n siguiente vemos el proceso de creaci\u00f3n de una lista num\u00e9rica y los elementos que se crean con la misma. Los bloques que se crean nos permiten asignarle valores, saber el n\u00famero de elementos que tiene una lista, obtener el valor de una posici\u00f3n de la lista o cambiar el valor de un elemento de la lista. De forma muy similar se pueden crear y trabajar con lista de textos. Programando la actividad \u00b6 Vamos a realizar un programa que vamos a dividir en varias partes: Parte 1: Mover el servo a partir de una lista de posiciones creada previamente. Parte 2: Mover de forma autom\u00e1tica el servo entre 0 y 180 grados con retardos de un segundo. Parte 3: Mover el servo a la posici\u00f3n 180\u00ba con un pulsador y a la posici\u00f3n 0\u00ba con el otro. Parte 4: Mover el servo entre 0\u00ba y 180\u00ba utilizando el potenci\u00f3metro para ello. Crearemos una funci\u00f3n para cada apartado y ser\u00e1n llamadas de forma consecutiva. La soluci\u00f3n la tenemos disponible en ESP32-SM-Actividad-servo que es el programa que vemos en la imagen siguiente: Soluci\u00f3n Actividad Servo Para probar las distintas partes vamos cambiando la funci\u00f3n que se pone en bucle y cargando el programa en la placa.","title":"El servo"},{"location":"servo/#el-servomotor","text":"Haremos diferentes movimientos del servomotor empleando funciones para distinguir un tipo de movimiento de otro.","title":"El servomotor"},{"location":"servo/#teoria","text":"","title":"Teor\u00eda"},{"location":"servo/#el-servo","text":"Un servomotor o abreviado servo es un motor especial que puede posicionar su eje en un \u00e1ngulo determinado y lo puede mantener en esta posici\u00f3n. Los servos est\u00e1ndar suelen girar 180\u00ba, pero es habitual encontrar servos que giran 90\u00ba y otros 360\u00ba, que son los conocidos como servos de rotaci\u00f3n continua. En el interior del mismo est\u00e1n ubicados tanto la electr\u00f3nica de control como los engranajes reductores que a su vez pueden llevar o no topes f\u00edsicos que marquen el \u00e1ngulo de giro. Para su funcionamiento s\u00f3lo necesitan ser alimentados (conexiones GND y VCC o 5V) y una se\u00f1al de control. Los servomotores son en realidad motores de corriente continua a los que se les ha a\u00f1adido una reductora, para que giren m\u00e1s despacio y con m\u00e1s fuerza, y un controlador electr\u00f3nico que permite hacer que gire un determinado \u00e1ngulo. Adem\u00e1s, el servo en todo momento sabe en qu\u00e9 posici\u00f3n est\u00e1, aunque se apague o reinicie. Esto significa que si a un servo que hemos movido a un determinado punto, lo hemos dejado sin alimentaci\u00f3n y al alimentarlo de nuevo le indicamos que gire 90\u00ba, no va a girar 90\u00ba sino que se va a dirigir a su posici\u00f3n de 90\u00ba que tiene memorizada internamente. En la figura siguiente vemos el interior de un servo esquematizado. Interior de un servo 9g Su aspecto real lo vemos en esta otra figura, donde tambi\u00e9n se aprecian las palas y torniller\u00eda que lo acompa\u00f1an. Aspecto real servo 9g Veamos su principio b\u00e1sico de funcionamiento: La electr\u00f3nica de control del servomotor tiene un circuito de referencia incorporado que emite la se\u00f1al de referencia, que es un ciclo de 20 ms con un ancho de pulso de 1,5 ms. Se compara la tensi\u00f3n de control recibida con la de referencia y se genera una diferencia de tensi\u00f3n. El circuito de control en la placa decidir\u00e1 la direcci\u00f3n de rotaci\u00f3n en consecuencia y accionar\u00e1 el motor. El sistema de engranajes o reductora convierten el giro del motor en un par de fuerza a trav\u00e9s del eje. El sensor detecta que se ha alcanzado la posici\u00f3n enviada de acuerdo con la se\u00f1al de retroalimentaci\u00f3n. Cuando la diferencia de tensi\u00f3n existe el motor gira y cuando la diferencia se reduce a cero, el motor se detiene. Normalmente, el \u00e1ngulo de rotaci\u00f3n es de 0 a 180 grados. El servomotor viene con un conector hembra de tres pines para tres cables de conexi\u00f3n, que se distinguen por los colores marr\u00f3n, rojo y naranja (diferentes marcas pueden tener diferentes colores). El \u00e1ngulo de rotaci\u00f3n del servomotor se controla regulando el ciclo de trabajo de la se\u00f1al PWM cuyo est\u00e1ndar es de 20 ms (50 Hz). Hay que tener mucho cuidado de posicionar el conector de los servos en los tres pines macho de la shield en el orden correcto (el conector es reversible) o seguramente romperemos algo de manera irremediable. Existe un tipo especial de servomotor que permite la rotaci\u00f3n continua. En algunos casos se trata de servomotores \u201ctrucados\u201d de forma que se modifican para permitir la rotaci\u00f3n continua quitando los topes mec\u00e1nicos y se sustituye el potenci\u00f3metro por un divisor de tensi\u00f3n con dos resistencia iguales (en algunos casos no se ponen resistencias y se bloquea el potenci\u00f3metro para que no gire dej\u00e1ndolo justo en su punto central). Este tipo de modificaci\u00f3n la podemos realizar nosotros (en la web existen multitud de tutoriales) o tambi\u00e9n podemos comprar un servomotor de rotaci\u00f3n continua listo para funcionar sin tener que hacer ning\u00fan tipo de bricolaje. En el apartado de bloques de programaci\u00f3n, se encuentra en \"Motor / Servo\" y en la figura siguiente vemos los bloques disponibles. Bloques para servos Para controlar el servomotor, indicamos los grados de rotaci\u00f3n (\u00c1ngulo de giro) que queremos y el tiempo de retardo, o tiempo que tarda en ir de una posici\u00f3n a otra. El control de un servomotor de rotaci\u00f3n continua se realiza de igual manera, pero su reacci\u00f3n es diferente. Los bloques Servo-Oscilador nos permiten de una forma sencilla hacer que el servo repita una secuencia de movimientos u oscilaciones de forma indefinida. Un ejemplo t\u00edpico puede ser el que vemos en la figura siguiente, donde el servo oscila entre 0 y 90\u00ba en periodos de dos segundos. Oscilaci\u00f3n con servo El bloque Servo-I2C (PCA9685) es simplemente un bloque para manejar la tarjeta controladora para 16 servos PCA9685 utilizando el bus I2C.","title":"El servo"},{"location":"servo/#posicionar-el-servo","text":"Antes de fijar con el tornillo la pala y, en nuestro caso la flecha, debemos averiguar cual es su posici\u00f3n de 0\u00ba o inicial. Para ello vamos a crear el programa Posicionar-servo que vemos en la figura siguiente o que podemos importar del archivo del enlace. Buscar la posici\u00f3n 0\u00ba del servo Ejecutamos el programa que hemos cargado en la placa, y lo tenemos que parar en el momento que el servo vuelve a la posici\u00f3n inicial (hace un giro repentino de 180\u00ba tras un tiempo de espera mas largo). En ese momento, quitamos la flecha y el soporte tipo aspa vigilando de que no se modifique la posici\u00f3n del servo. Sin que el servomotor se haya movido, montamos el soporte blanco y la flecha, de forma que la flecha apunte hacia abajo, tal y como se muestra en la figura siguiente, donde se aprecia todo el proceso. Colocaci\u00f3n de elementos en el servo","title":"Posicionar el servo "},{"location":"servo/#listas","text":"Las listas de datos nos permiten almacenar un listado de valores y acceder a ellos por su posici\u00f3n en la lista. Las listas pueden ser de tipo num\u00e9ricas o de texto, como vemos en la imagen siguiente: Tipos de listas en ArduinoBlocks En la animaci\u00f3n siguiente vemos el proceso de creaci\u00f3n de una lista num\u00e9rica y los elementos que se crean con la misma. Los bloques que se crean nos permiten asignarle valores, saber el n\u00famero de elementos que tiene una lista, obtener el valor de una posici\u00f3n de la lista o cambiar el valor de un elemento de la lista. De forma muy similar se pueden crear y trabajar con lista de textos.","title":"Listas"},{"location":"servo/#programando-la-actividad","text":"Vamos a realizar un programa que vamos a dividir en varias partes: Parte 1: Mover el servo a partir de una lista de posiciones creada previamente. Parte 2: Mover de forma autom\u00e1tica el servo entre 0 y 180 grados con retardos de un segundo. Parte 3: Mover el servo a la posici\u00f3n 180\u00ba con un pulsador y a la posici\u00f3n 0\u00ba con el otro. Parte 4: Mover el servo entre 0\u00ba y 180\u00ba utilizando el potenci\u00f3metro para ello. Crearemos una funci\u00f3n para cada apartado y ser\u00e1n llamadas de forma consecutiva. La soluci\u00f3n la tenemos disponible en ESP32-SM-Actividad-servo que es el programa que vemos en la imagen siguiente: Soluci\u00f3n Actividad Servo Para probar las distintas partes vamos cambiando la funci\u00f3n que se pone en bucle y cargando el programa en la placa.","title":"Programando la actividad"},{"location":"soft/","text":"Software \u00b6 ArduinoBlocks \u00b6 Principalmente vamos a utilizar el lenguaje de programaci\u00f3n visual por bloques denominado ArduinoBlocks. El aspecto de la plataforma al entrar lo vemos en la imagen siguiente: Portada de la plataforma ArduinoBlocks Podemos programar nuestra placa de control tipo UNO de diversas formas de las que las mas comunes son, a partir del IDE de Arduino o mediante bloques, que ser\u00e1 el m\u00e9todo que sigamos. Programar mediante el IDE requiere teclear instrucciones de c\u00f3digo mientras que con ArduinoBlocks estas instrucciones se sustituyen por bloques tipo puzzle que evitan errores de sintaxis. Evidentemente detr\u00e1s de cada bloque en realidad lo que hay son instrucciones y ArduinoBlocks nos va a permitir verlas y exportarlas. En la imagen siguiente tenemos una comparativa entre bloques de c\u00f3digo e instrucciones en el IDE. Comparativa entre bloques y c\u00f3digo Es importante entender que la programaci\u00f3n con ArduinoBlocks simplifica la iniciaci\u00f3n en el pensamiento computacional permitiendo realizar tareas complejas de una forma sencilla. Para el caso de la TdR STEAM cabe destacar que ArduinoBlocks incluye una serie de bloques espec\u00edficos que facilitan a\u00fan mas si cabe su programaci\u00f3n. ArduinoBlocks trabaja a trav\u00e9s de una plataforma online por lo que no requiere instalaci\u00f3n en nuestro sistema. No obstante, si que tenemos que instalar un peque\u00f1o programa que ser\u00e1 el encargado de conectar nuestro programa en el navegador con la placa Keyestudio UNO. Este programa basado en Python se llama Connector . Lo primero que deberemos hacer es crear una cuenta en ArduinoBlocks utilizando una direcci\u00f3n de correo electr\u00f3nico v\u00e1lida y despu\u00e9s instalar el software Connector . En los manuales de referencia disponibles en la plataforma est\u00e1n todos los detalles sobre como llevar a cabo estas tareas. La versi\u00f3n 5 del programa una vez iniciado la vemos en la imagen siguiente: Connector V5 Si no est\u00e1s muy avezado en estos temas es necesarios al menos ver los siguientes v\u00eddeos sobre el tema: Bloque 1: Puesta en marcha con ArduinoBlocks Empezando con ArduinoBlocks y la programaci\u00f3n por bloques Crear una cuenta en ArduinoBlocks e iniciar un proyecto personal Configurar la conexi\u00f3n a ArduinoBlocks y detectar la placa Arduino Carga del primer programa","title":"Software"},{"location":"soft/#software","text":"","title":"Software"},{"location":"soft/#arduinoblocks","text":"Principalmente vamos a utilizar el lenguaje de programaci\u00f3n visual por bloques denominado ArduinoBlocks. El aspecto de la plataforma al entrar lo vemos en la imagen siguiente: Portada de la plataforma ArduinoBlocks Podemos programar nuestra placa de control tipo UNO de diversas formas de las que las mas comunes son, a partir del IDE de Arduino o mediante bloques, que ser\u00e1 el m\u00e9todo que sigamos. Programar mediante el IDE requiere teclear instrucciones de c\u00f3digo mientras que con ArduinoBlocks estas instrucciones se sustituyen por bloques tipo puzzle que evitan errores de sintaxis. Evidentemente detr\u00e1s de cada bloque en realidad lo que hay son instrucciones y ArduinoBlocks nos va a permitir verlas y exportarlas. En la imagen siguiente tenemos una comparativa entre bloques de c\u00f3digo e instrucciones en el IDE. Comparativa entre bloques y c\u00f3digo Es importante entender que la programaci\u00f3n con ArduinoBlocks simplifica la iniciaci\u00f3n en el pensamiento computacional permitiendo realizar tareas complejas de una forma sencilla. Para el caso de la TdR STEAM cabe destacar que ArduinoBlocks incluye una serie de bloques espec\u00edficos que facilitan a\u00fan mas si cabe su programaci\u00f3n. ArduinoBlocks trabaja a trav\u00e9s de una plataforma online por lo que no requiere instalaci\u00f3n en nuestro sistema. No obstante, si que tenemos que instalar un peque\u00f1o programa que ser\u00e1 el encargado de conectar nuestro programa en el navegador con la placa Keyestudio UNO. Este programa basado en Python se llama Connector . Lo primero que deberemos hacer es crear una cuenta en ArduinoBlocks utilizando una direcci\u00f3n de correo electr\u00f3nico v\u00e1lida y despu\u00e9s instalar el software Connector . En los manuales de referencia disponibles en la plataforma est\u00e1n todos los detalles sobre como llevar a cabo estas tareas. La versi\u00f3n 5 del programa una vez iniciado la vemos en la imagen siguiente: Connector V5 Si no est\u00e1s muy avezado en estos temas es necesarios al menos ver los siguientes v\u00eddeos sobre el tema: Bloque 1: Puesta en marcha con ArduinoBlocks Empezando con ArduinoBlocks y la programaci\u00f3n por bloques Crear una cuenta en ArduinoBlocks e iniciar un proyecto personal Configurar la conexi\u00f3n a ArduinoBlocks y detectar la placa Arduino Carga del primer programa","title":"ArduinoBlocks"},{"location":"sonido/","text":"Sensor de sonido o micr\u00f3fono \u00b6 Enunciado \u00b6 Realizaremos pruebas b\u00e1sicas de detecci\u00f3n de nivel de sonido a\u00f1adiendo esta opci\u00f3n externa al pin anal\u00f3gico A3 disponible en el conector correspondiente. Teor\u00eda \u00b6 Un micro\u0301fono es un transductor (dispositivo que convierte energi\u0301a de una forma a otra) que convierte la energi\u0301a sonora en sen\u0303ales ele\u0301ctricas. Micro\u0301fonos hay una amplia diversidad tanto en formas como taman\u0303os. Dependiendo de la aplicacio\u0301n, un micro\u0301fono puede utilizar diferentes tecnologi\u0301as para convertir sonidos en sen\u0303ales ele\u0301ctricas. Para el caso de aplicaciones con placas tipo Arduino suelen usarse sensores basados en el micro\u0301fono de condensador electret que es un condensador de placas paralelas y trabaja como una capacitancia variable. Se forma con una placa fija (placa trasera) y una movible (diafragma) con una pequen\u0303a separacio\u0301n entre ellas. Cuando el sonido golpea al diafragma este se mueve cambiando asi\u0301 la capacitancia entre las placas. El sensor microf\u00f3nico de keyestudio se utiliza normalmente para detectar el nivel de ruido en el ambiente. El pin S del mismo es una salida anal\u00f3gica, es decir, una tensi\u00f3n de salida en tiempo real del micr\u00f3fono. El sensor viene con un potenci\u00f3metro que permite ajustar la ganancia de la se\u00f1al dentro de un determinado rango. Su aspecto es el de la imagen siguiente: Sensor de sonido con micr\u00f3fono KS0035 con potenci\u00f3metro En la TdR STEAM \u00b6 El conector micr\u00f3fono externo en A3 Programando la actividad \u00b6 Como programa sencillo inicial vamos simplemente a enviar a la consola el nivel de sonido que detecte nuestro micr\u00f3fono. El programa de la imagen siguiente esta disponible como ESP32-SM-micro-inicial . Actividad inicial con el micro Retos de ampliaci\u00f3n \u00b6 Micro.R1 . Modificar el programa de la actividad inicial para que muestre los datos por la LCD. Micro.R2 . Partiendo del programa del reto 2 de la actividad LCD (LCD.R2) modificarlo para que muestre los datos del micr\u00f3fono tanto al final de la cuenta ascendente como de la descendente.","title":"Sensor de sonido o micr\u00f3fono"},{"location":"sonido/#sensor-de-sonido-o-microfono","text":"","title":"Sensor de sonido o micr\u00f3fono"},{"location":"sonido/#enunciado","text":"Realizaremos pruebas b\u00e1sicas de detecci\u00f3n de nivel de sonido a\u00f1adiendo esta opci\u00f3n externa al pin anal\u00f3gico A3 disponible en el conector correspondiente.","title":"Enunciado"},{"location":"sonido/#teoria","text":"Un micro\u0301fono es un transductor (dispositivo que convierte energi\u0301a de una forma a otra) que convierte la energi\u0301a sonora en sen\u0303ales ele\u0301ctricas. Micro\u0301fonos hay una amplia diversidad tanto en formas como taman\u0303os. Dependiendo de la aplicacio\u0301n, un micro\u0301fono puede utilizar diferentes tecnologi\u0301as para convertir sonidos en sen\u0303ales ele\u0301ctricas. Para el caso de aplicaciones con placas tipo Arduino suelen usarse sensores basados en el micro\u0301fono de condensador electret que es un condensador de placas paralelas y trabaja como una capacitancia variable. Se forma con una placa fija (placa trasera) y una movible (diafragma) con una pequen\u0303a separacio\u0301n entre ellas. Cuando el sonido golpea al diafragma este se mueve cambiando asi\u0301 la capacitancia entre las placas. El sensor microf\u00f3nico de keyestudio se utiliza normalmente para detectar el nivel de ruido en el ambiente. El pin S del mismo es una salida anal\u00f3gica, es decir, una tensi\u00f3n de salida en tiempo real del micr\u00f3fono. El sensor viene con un potenci\u00f3metro que permite ajustar la ganancia de la se\u00f1al dentro de un determinado rango. Su aspecto es el de la imagen siguiente: Sensor de sonido con micr\u00f3fono KS0035 con potenci\u00f3metro","title":"Teor\u00eda"},{"location":"sonido/#en-la-tdr-steam","text":"El conector micr\u00f3fono externo en A3","title":"En la TdR STEAM"},{"location":"sonido/#programando-la-actividad","text":"Como programa sencillo inicial vamos simplemente a enviar a la consola el nivel de sonido que detecte nuestro micr\u00f3fono. El programa de la imagen siguiente esta disponible como ESP32-SM-micro-inicial . Actividad inicial con el micro","title":"Programando la actividad"},{"location":"sonido/#retos-de-ampliacion","text":"Micro.R1 . Modificar el programa de la actividad inicial para que muestre los datos por la LCD. Micro.R2 . Partiendo del programa del reto 2 de la actividad LCD (LCD.R2) modificarlo para que muestre los datos del micr\u00f3fono tanto al final de la cuenta ascendente como de la descendente.","title":"Retos de ampliaci\u00f3n"},{"location":"Miscelanea/about/","text":"Autor \u00b6 Federico Coca GitHub Twitter Instagram Mas informaci\u00f3n","title":"Autor"},{"location":"Miscelanea/about/#autor","text":"Federico Coca GitHub Twitter Instagram Mas informaci\u00f3n","title":"Autor"},{"location":"Miscelanea/lic/","text":"Licencias \u00b6 Licencia MIT incluida en la creaci\u00f3n del repositorio. Creative Commons Atribuci\u00f3n-CompartirIgual 4.0 International (\"CC BY-SA\"). CC BY-SA 4.0","title":"Licencias"},{"location":"Miscelanea/lic/#licencias","text":"Licencia MIT incluida en la creaci\u00f3n del repositorio. Creative Commons Atribuci\u00f3n-CompartirIgual 4.0 International (\"CC BY-SA\"). CC BY-SA 4.0","title":"Licencias"},{"location":"Miscelanea/soft/","text":"Software utilizado \u00b6 Dibujo 3D FreeCAD Sistema operativo: Ubuntu 22.04.1 LTS (Jammy Jellyfish) Paquete ofim\u00e1tico de referencia: LibreOffice Libreria Material para MkDocs Visual Studio Code Creaci\u00f3n de GIF animados para Ubuntu Peek Sistema principal de capturas de pantalla: Shutter Dibujo 2D vectorial Inkscape Retoque de im\u00e1genes GIMP Programaci\u00f3n por bloques con ArduinoBlocks Programaci\u00f3n mediante el IDE de Arduino","title":"Software utilizado"},{"location":"Miscelanea/soft/#software-utilizado","text":"Dibujo 3D FreeCAD Sistema operativo: Ubuntu 22.04.1 LTS (Jammy Jellyfish) Paquete ofim\u00e1tico de referencia: LibreOffice Libreria Material para MkDocs Visual Studio Code Creaci\u00f3n de GIF animados para Ubuntu Peek Sistema principal de capturas de pantalla: Shutter Dibujo 2D vectorial Inkscape Retoque de im\u00e1genes GIMP Programaci\u00f3n por bloques con ArduinoBlocks Programaci\u00f3n mediante el IDE de Arduino","title":"Software utilizado"},{"location":"Miscelanea/webgrafia/","text":"Webgraf\u00eda y bibliograf\u00eda \u00b6 Wikipedia Manual de la placa ESP32 Plus STEAMakers / Imagina TDR STEAM / ArduinoBlocks Versi\u00f3n 4.0 de Junio de 2022 Wiki de keyestudio sobre los elementos usados Wiki keyestudio Manuales de ArduinoBlocks","title":"Webgrafia/Bibliograf\u00eda"},{"location":"Miscelanea/webgrafia/#webgrafia-y-bibliografia","text":"Wikipedia Manual de la placa ESP32 Plus STEAMakers / Imagina TDR STEAM / ArduinoBlocks Versi\u00f3n 4.0 de Junio de 2022 Wiki de keyestudio sobre los elementos usados Wiki keyestudio Manuales de ArduinoBlocks","title":"Webgraf\u00eda y bibliograf\u00eda"}]}